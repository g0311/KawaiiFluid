// Copyright 2026 Team_Bruteforce. All Rights Reserved.

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidCommon.ush"

// -----------------------------------------------------------------------------
// Parameters
// -----------------------------------------------------------------------------
Texture2D<float> FluidDepthTexture;
Texture2D<float4> FluidNormalTexture;
Texture2D<float> FluidThicknessTexture;
Texture2D<float> OcclusionMaskTexture;  // 1.0 = visible, 0.0 = occluded by scene geometry
Texture2D<float> SceneDepthTexture;
Texture2D<float4> SceneColorTexture;

SamplerState InputSampler;
SamplerState PointClampSampler;  // Point sampling for depth textures to avoid edge interpolation artifacts

// UV scaling for SceneColor/SceneDepth (ViewRect / TextureSize)
// Needed when texture size differs from ViewRect (e.g., Screen Percentage)
float2 SceneUVScale;
float2 SceneUVOffset;
float2 FluidUVScale;
float2 FluidUVOffset;

float4x4 InverseProjectionMatrix;
float4x4 ProjectionMatrix;
float4x4 ViewMatrix;

float4 FluidColor;
float FresnelStrength;
float RefractiveIndex;
float Opacity;                       // Fluid opacity (0 = transparent, 1 = opaque)
float4 AbsorptionColorCoefficients;  // Per-channel absorption coefficients (Beer's Law)
float SpecularStrength;
float SpecularRoughness;
float AmbientIntensity;  // SkyLight contribution scale (default 0.15)
float LightingScale;     // Overall lighting scale for HDR compensation (default 0.2)

// -----------------------------------------------------------------------------
// Multi-Light Support
// Packed as float4 arrays for shader compatibility:
// - LightDirectionsAndIntensity[i] = (Direction.xyz, Intensity)
// - LightColors[i] = (Color.rgb, unused)
// -----------------------------------------------------------------------------
#define FLUID_MAX_LIGHTS 8

int NumLights;  // Number of active lights (0 = use View.DirectionalLight fallback)
float4 LightDirectionsAndIntensity[FLUID_MAX_LIGHTS];
float4 LightColors[FLUID_MAX_LIGHTS];

// Lighting Scale Parameters
float ThicknessSensitivity;          // How much thickness affects transparency (0 = uniform, 1 = thickness-dependent)
int bEnableThicknessClamping;        // 1 = clamp thickness to min/max, 0 = no clamping
float ThicknessMin;                  // Minimum thickness value (when clamping enabled)
float ThicknessMax;                  // Maximum thickness value (when clamping enabled)
float FresnelReflectionBlend;

// Refraction
int bEnableRefraction;               // 1 = enabled, 0 = disabled
float RefractionScale;

// Caustics
int bEnableCaustics;                 // 1 = enabled, 0 = disabled
float CausticIntensity;              // Brightness multiplier for caustic patterns

// Reflection Cubemap
TextureCube ReflectionCubemap;
SamplerState ReflectionCubemapSampler;
float ReflectionIntensity;
float ReflectionMipLevel;
int bUseReflectionCubemap;

// Reflection Mode (0=None, 1=Cubemap, 2=ScreenSpaceReflection, 3=SSR+Cubemap)
int ReflectionMode;
int ScreenSpaceReflectionMaxSteps;
float ScreenSpaceReflectionStepSize;
float ScreenSpaceReflectionThickness;
float ScreenSpaceReflectionIntensity;
float ScreenSpaceReflectionEdgeFade;
float2 ViewportSize;

// -----------------------------------------------------------------------------
// Vertex Shader
// -----------------------------------------------------------------------------
struct FCompositeVSToPS
{
	float4 Position : SV_POSITION;
	float2 UV : TEXCOORD0;
};

void MainVS(
	in uint VertexID : SV_VertexID,
	out FCompositeVSToPS Output
)
{
	// Fullscreen Triangle
	float2 UV = float2((VertexID << 1) & 2, VertexID & 2);
	Output.UV = UV;
	Output.Position = float4(UV * float2(2, -2) + float2(-1, 1), 0.5f, 1.0f);
}

// -----------------------------------------------------------------------------
// Helper Functions
// -----------------------------------------------------------------------------

// Background depth threshold (no fluid at very far distances)
#define BACKGROUND_DEPTH_THRESH 100000.0f

/**
 * Reconstruct view space position from screen UV and linear depth.
 * Wrapper for shared function in FluidCommon.ush using global InverseProjectionMatrix.
 */
float3 ReconstructViewPosition(float2 ScreenUV, float LinearDepth)
{
	return ReconstructViewPositionFromDepth(ScreenUV, LinearDepth, InverseProjectionMatrix);
}

/**
 * Project view space position to screen UV.
 * Wrapper for shared function in FluidCommon.ush using global ProjectionMatrix.
 */
float2 ProjectToScreenUV(float3 ViewPos)
{
	return ProjectViewPositionToScreenUV(ViewPos, ProjectionMatrix);
}

// -----------------------------------------------------------------------------
// Volume Scattering Functions
// -----------------------------------------------------------------------------

/**
 * Henyey-Greenstein Phase Function.
 * Models the angular distribution of scattered light.
 *
 * @param CosTheta Cosine of angle between view and light directions (dot(V, -L))
 * @param g Anisotropy parameter: -1 = backscatter, 0 = isotropic, +1 = forward scatter
 * @return Phase function value (probability density)
 */
float HenyeyGreenstein(float CosTheta, float g)
{
	// Prevent division by zero when g approaches ±1
	float g2 = g * g;
	float denom = 1.0 + g2 - 2.0 * g * CosTheta;

	// Avoid numerical issues
	denom = max(denom, 0.0001);

	return (1.0 - g2) / (4.0 * PI * pow(denom, 1.5));
}

/**
 * Schlick Phase Function (faster approximation of Henyey-Greenstein).
 * Use when performance is critical.
 *
 * @param CosTheta Cosine of angle between view and light directions
 * @param g Anisotropy parameter
 * @return Phase function value
 */
float SchlickPhase(float CosTheta, float g)
{
	float k = 1.55 * g - 0.55 * g * g * g;
	float tmp = 1.0 + k * CosTheta;
	return (1.0 - k * k) / (4.0 * PI * tmp * tmp + 0.0001);
}

// -----------------------------------------------------------------------------
// PBR Functions (Cook-Torrance BRDF)
// -----------------------------------------------------------------------------

/**
 * GGX/Trowbridge-Reitz Normal Distribution Function.
 * Models the statistical distribution of microfacet normals.
 *
 * @param NoH Dot product of Normal and Half vector
 * @param Roughness Surface roughness (0 = mirror, 1 = diffuse)
 * @return Distribution term D
 */
float D_GGX(float NoH, float Roughness)
{
	float a = Roughness * Roughness;
	float a2 = a * a;
	float NoH2 = NoH * NoH;

	float denom = NoH2 * (a2 - 1.0) + 1.0;
	return a2 / (PI * denom * denom + 0.0001);
}

/**
 * Schlick-GGX Geometry Function (single direction).
 * Models microfacet self-shadowing.
 *
 * @param NoX Dot product (NoV or NoL)
 * @param Roughness Surface roughness
 * @return Geometry term for one direction
 */
float G_SchlickGGX(float NoX, float Roughness)
{
	float r = Roughness + 1.0;
	float k = (r * r) / 8.0;  // Direct lighting remapping

	return NoX / (NoX * (1.0 - k) + k + 0.0001);
}

/**
 * Smith Geometry Function (combined view and light).
 * Combines shadowing from both view and light directions.
 *
 * @param NoV Normal dot View
 * @param NoL Normal dot Light
 * @param Roughness Surface roughness
 * @return Combined geometry term G
 */
float G_Smith(float NoV, float NoL, float Roughness)
{
	return G_SchlickGGX(NoV, Roughness) * G_SchlickGGX(NoL, Roughness);
}

/**
 * Fresnel-Schlick approximation.
 *
 * For direct lighting (point/directional), CosTheta should be HoV (Half·View).
 * This is physically correct for microfacet theory where each microfacet
 * reflects light along the half vector direction.
 *
 * @param CosTheta Typically dot(HalfVector, ViewDir) for direct lighting
 * @param F0 Reflectance at normal incidence
 * @return Fresnel reflectance
 */
float3 F_Schlick(float CosTheta, float3 F0)
{
	return F0 + (1.0 - F0) * pow(saturate(1.0 - CosTheta), 5.0);
}

/**
 * Cook-Torrance Specular BRDF.
 * Combines D, G, F terms for physically-based specular reflection.
 *
 * @param NoV Normal dot View
 * @param NoL Normal dot Light
 * @param NoH Normal dot Half
 * @param HoV Half dot View (for Fresnel)
 * @param Roughness Surface roughness
 * @param F0 Reflectance at normal incidence
 * @param OutFresnel Output Fresnel term (for energy conservation)
 * @return Specular BRDF value
 */
float3 CookTorranceBRDF(float NoV, float NoL, float NoH, float HoV, float Roughness, float3 F0, out float3 OutFresnel)
{
	// Distribution
	float D = D_GGX(NoH, Roughness);

	// Geometry
	float G = G_Smith(NoV, NoL, Roughness);

	// Fresnel
	OutFresnel = F_Schlick(HoV, F0);

	// Cook-Torrance specular BRDF
	// f_spec = DGF / (4 * NoV * NoL)
	float3 numerator = D * G * OutFresnel;
	float denominator = 4.0 * NoV * NoL + 0.0001;

	return numerator / denominator;
}

// -----------------------------------------------------------------------------
// Caustics (Jacobian Method)
// -----------------------------------------------------------------------------

/**
 * Calculate refracted ray hit position on floor plane using Snell's law.
 */
float2 CalculateRefractedFloorHit(float3 SurfacePos, float3 Normal, float3 ViewDir, float FloorZ, float IOR)
{
	// Snell's law: n1 * sin(theta1) = n2 * sin(theta2)
	float eta = 1.0 / IOR;

	float CosThetaI = dot(Normal, ViewDir);
	float Sin2ThetaT = eta * eta * (1.0 - CosThetaI * CosThetaI);

	// Total internal reflection check
	if (Sin2ThetaT > 1.0)
	{
		return SurfacePos.xy;
	}

	float CosThetaT = sqrt(1.0 - Sin2ThetaT);
	float3 RefractDir = eta * (-ViewDir) + (eta * CosThetaI - CosThetaT) * Normal;
	RefractDir = normalize(RefractDir);

	if (abs(RefractDir.z) < 0.001)
	{
		return SurfacePos.xy;
	}

	float t = (FloorZ - SurfacePos.z) / RefractDir.z;
	if (t < 0.0)
	{
		return SurfacePos.xy;
	}

	float3 HitPos = SurfacePos + t * RefractDir;
	return HitPos.xy;
}

/**
 * Calculate caustic intensity using Jacobian determinant.
 */
float CalculateCausticJacobian(
	float2 ScreenUV,
	float2 FluidUV,
	float3 CenterNormal,
	float FluidDepth,
	float FloorDepth,
	float4x4 ViewMat,
	float IOR,
	float PixelOffset)
{
	float2 PixelSize = 1.0 / ViewportSize;
	float2 Offset = PixelSize * PixelOffset;

	float3x3 ViewToWorld = transpose((float3x3)ViewMat);

	float3 CenterViewPos = ReconstructViewPosition(ScreenUV, FluidDepth);
	float3 CenterWorldPos = mul(CenterViewPos, ViewToWorld);

	float3 CameraWorldPos = mul(float3(0, 0, 0), ViewToWorld);
	float3 ViewDir = normalize(CameraWorldPos - CenterWorldPos);

	float3 FloorViewPos = ReconstructViewPosition(ScreenUV, FloorDepth);
	float3 FloorWorldPos = mul(FloorViewPos, ViewToWorld);
	float FloorZ = FloorWorldPos.z;

	// 8-direction sampling
	const float Diag = 0.707;
	float2 Dirs[8] = {
		float2(1, 0), float2(Diag, Diag), float2(0, 1), float2(-Diag, Diag),
		float2(-1, 0), float2(-Diag, -Diag), float2(0, -1), float2(Diag, -Diag)
	};

	float2 SampleUVs[8];
	float2 SampleFluidUVs[8];
	for (int i = 0; i < 8; i++)
	{
		SampleUVs[i] = saturate(ScreenUV + Dirs[i] * Offset);
		SampleFluidUVs[i] = SampleUVs[i] * FluidUVScale + FluidUVOffset;
	}

	// Bilinear sampling for smooth results
	float3 Normals[8];
	float Depths[8];
	int ValidCount = 0;

	for (int j = 0; j < 8; j++)
	{
		Normals[j] = FluidNormalTexture.SampleLevel(InputSampler, SampleFluidUVs[j], 0).xyz;
		Depths[j] = FluidDepthTexture.SampleLevel(InputSampler, SampleFluidUVs[j], 0).r;

		if (Depths[j] < BACKGROUND_DEPTH_THRESH && length(Normals[j]) > 0.1)
		{
			Normals[j] = normalize(Normals[j]);
			ValidCount++;
		}
	}

	float EdgeValidity = saturate((float(ValidCount) - 2.0) / 6.0);

	if (ValidCount < 3)
	{
		return 1.0;
	}

	float2 HitCenter = CalculateRefractedFloorHit(CenterWorldPos, CenterNormal, ViewDir, FloorZ, IOR);
	float2 Hits[8];
	float2 OrigPos[8];

	for (int k = 0; k < 8; k++)
	{
		if (Depths[k] < BACKGROUND_DEPTH_THRESH)
		{
			float3 WorldPos = mul(ReconstructViewPosition(SampleUVs[k], Depths[k]), ViewToWorld);
			Hits[k] = CalculateRefractedFloorHit(WorldPos, Normals[k], ViewDir, FloorZ, IOR);
			OrigPos[k] = WorldPos.xz;
		}
		else
		{
			Hits[k] = HitCenter;
			OrigPos[k] = CenterWorldPos.xz;
		}
	}

	// Cardinal Jacobian
	float2 dHit_du_cardinal = (Hits[0] - Hits[4]) / (2.0 * Offset.x);
	float2 dHit_dv_cardinal = (Hits[2] - Hits[6]) / (2.0 * Offset.y);
	float J_cardinal = abs(dHit_du_cardinal.x * dHit_dv_cardinal.y - dHit_du_cardinal.y * dHit_dv_cardinal.x);

	float2 dOrig_du_cardinal = (OrigPos[0] - OrigPos[4]) / (2.0 * Offset.x);
	float2 dOrig_dv_cardinal = (OrigPos[2] - OrigPos[6]) / (2.0 * Offset.y);
	float OrigJ_cardinal = abs(dOrig_du_cardinal.x * dOrig_dv_cardinal.y - dOrig_du_cardinal.y * dOrig_dv_cardinal.x);

	// Diagonal Jacobian
	float DiagScale = 1.414;
	float2 dHit_du_diag = (Hits[1] - Hits[5]) / (2.0 * Offset.x * DiagScale);
	float2 dHit_dv_diag = (Hits[3] - Hits[7]) / (2.0 * Offset.y * DiagScale);
	float J_diag = abs(dHit_du_diag.x * dHit_dv_diag.y - dHit_du_diag.y * dHit_dv_diag.x);

	float2 dOrig_du_diag = (OrigPos[1] - OrigPos[5]) / (2.0 * Offset.x * DiagScale);
	float2 dOrig_dv_diag = (OrigPos[3] - OrigPos[7]) / (2.0 * Offset.y * DiagScale);
	float OrigJ_diag = abs(dOrig_du_diag.x * dOrig_dv_diag.y - dOrig_du_diag.y * dOrig_dv_diag.x);

	float J = (J_cardinal + J_diag) * 0.5;
	float OrigJ = (OrigJ_cardinal + OrigJ_diag) * 0.5;

	float AreaRatio = OrigJ / max(J, 0.0001);
	AreaRatio = clamp(AreaRatio, 0.2, 5.0);

	float Caustic = smoothstep(0.3, 3.0, AreaRatio);
	float Brightness = lerp(0.7, 1.8, Caustic);

	return lerp(1.0, Brightness, EdgeValidity);
}

/**
 * Multi-scale caustic pattern using optical Jacobian.
 */
float CausticPattern(float2 ScreenUV, float2 FluidUV, float3 Normal, float FluidDepth, float FloorDepth,
                     float4x4 ViewMat, float IOR)
{
	float C1 = CalculateCausticJacobian(ScreenUV, FluidUV, Normal, FluidDepth, FloorDepth, ViewMat, IOR, 3.0);
	float C2 = CalculateCausticJacobian(ScreenUV, FluidUV, Normal, FluidDepth, FloorDepth, ViewMat, IOR, 6.0);
	float C3 = CalculateCausticJacobian(ScreenUV, FluidUV, Normal, FluidDepth, FloorDepth, ViewMat, IOR, 12.0);

	float Combined = C1 * 0.25 + C2 * 0.35 + C3 * 0.4;

	return Combined - 1.0;
}

/**
 * Screen Space Reflection using perspective-correct ray march.
 */
float TraceSSR(float3 RayOrigin, float3 RayDir, out float2 OutHitUV, out float3 OutHitColor)
{
	OutHitUV = float2(0, 0);
	OutHitColor = float3(0, 0, 0);

	// Early exit if reflection points toward camera
	if (RayDir.z > 0.1)
	{
		return 0.0;
	}

	// Calculate ray end point
	float RayLength = abs(RayOrigin.z) * 4.0;
	float3 RayEnd = RayOrigin + RayDir * RayLength;

	// Clamp end point to not go behind camera
	if (RayEnd.z > -0.1)
	{
		float t = (-0.1 - RayOrigin.z) / (RayEnd.z - RayOrigin.z);
		RayEnd = RayOrigin + (RayEnd - RayOrigin) * max(t, 0.01);
	}

	// Project start and end to clip space
	float4 StartClip = mul(float4(RayOrigin, 1.0), ProjectionMatrix);
	float4 EndClip = mul(float4(RayEnd, 1.0), ProjectionMatrix);

	// Calculate screen UV for ray length estimation
	float2 StartUV = float2(
		StartClip.x / StartClip.w * 0.5 + 0.5,
		-StartClip.y / StartClip.w * 0.5 + 0.5
	);
	float2 EndUV = float2(
		EndClip.x / EndClip.w * 0.5 + 0.5,
		-EndClip.y / EndClip.w * 0.5 + 0.5
	);

	float2 RayUV = EndUV - StartUV;
	float RayScreenLen = length(RayUV * ViewportSize);

	if (RayScreenLen < 1.0)
	{
		return 0.0;
	}

	int StepCount = ScreenSpaceReflectionMaxSteps;
	float InvStepCount = 1.0 / float(StepCount);

	float StartDepth = -RayOrigin.z;
	float EndDepth = -RayEnd.z;

	float PrevRayDepth = StartDepth;
	float PrevSceneDepth = StartDepth;

	for (int i = 1; i <= StepCount; i++)
	{
		float t = float(i) * InvStepCount;

		// Correct perspective interpolation: lerp in clip space, then perspective divide
		float4 ClipPos = lerp(StartClip, EndClip, t);
		float2 UV = float2(
			ClipPos.x / ClipPos.w * 0.5 + 0.5,
			-ClipPos.y / ClipPos.w * 0.5 + 0.5
		);

		if (any(UV < 0.0) || any(UV > 1.0))
		{
			break;
		}

		// Depth: linear interpolation in view space (RayOrigin.z to RayEnd.z)
		float RayDepth = lerp(StartDepth, EndDepth, t);

		float2 SampleUV = UV * SceneUVScale;
		float SceneDeviceZ = SceneDepthTexture.SampleLevel(PointClampSampler, SampleUV, 0).r;
		float SceneDepth = ConvertFromDeviceZ(SceneDeviceZ);

		if (SceneDepth > 50000.0)
		{
			PrevRayDepth = RayDepth;
			PrevSceneDepth = SceneDepth;
			continue;
		}

		bool bWasInFront = PrevRayDepth <= PrevSceneDepth;
		bool bNowBehind = RayDepth > SceneDepth;

		if (bWasInFront && bNowBehind)
		{
			float Penetration = RayDepth - SceneDepth;
			float MaxThickness = ScreenSpaceReflectionThickness * SceneDepth * 0.05;

			if (Penetration < MaxThickness)
			{
				// Binary search refinement
				float tLo = float(i - 1) * InvStepCount;
				float tHi = t;
				float2 HitUV = UV;

				for (int j = 0; j < 8; j++)
				{
					float tMid = (tLo + tHi) * 0.5;

					// Clip space interpolation (same as main loop)
					float4 MidClip = lerp(StartClip, EndClip, tMid);
					float2 MidUV = float2(
						MidClip.x / MidClip.w * 0.5 + 0.5,
						-MidClip.y / MidClip.w * 0.5 + 0.5
					);
					float MidRayDepth = lerp(StartDepth, EndDepth, tMid);

					float2 MidSampleUV = MidUV * SceneUVScale;
					float MidSceneDepth = ConvertFromDeviceZ(
						SceneDepthTexture.SampleLevel(PointClampSampler, MidSampleUV, 0).r
					);

					if (MidRayDepth > MidSceneDepth)
					{
						tHi = tMid;
						HitUV = MidUV;
					}
					else
					{
						tLo = tMid;
					}
				}

				OutHitUV = HitUV;
				OutHitColor = SceneColorTexture.SampleLevel(InputSampler, HitUV * SceneUVScale, 0).rgb;

				float2 ScreenEdgeDist = min(HitUV, 1.0 - HitUV);
				float EdgeFade = saturate(min(ScreenEdgeDist.x, ScreenEdgeDist.y) / max(ScreenSpaceReflectionEdgeFade, 0.01));
				float DistFade = 1.0 - smoothstep(0.5, 1.0, t);
				float AngleFade = saturate(-RayDir.z * 2.5);

				return EdgeFade * DistFade * AngleFade;
			}
		}

		PrevRayDepth = RayDepth;
		PrevSceneDepth = SceneDepth;
	}

	return 0.0;
}

// -----------------------------------------------------------------------------
// Fluid Surface Data Structure
// -----------------------------------------------------------------------------

/** Sampled fluid surface properties at a screen pixel. */
struct FFluidSurfaceData
{
	float  Depth;           // Linear depth from camera
	float3 Normal;          // World-space normal (normalized)
	float  Thickness;       // Accumulated fluid thickness
	float  OcclusionMask;   // 1.0 = visible, 0.0 = occluded
	float3 ViewPos;         // View-space position
	float3 ViewDir;         // Direction toward camera (normalized)
	float3 LightingNormal;  // Grazing-angle compensated normal for stable shading
	float3 ReflectionNormal;// Normal used for reflection calculations
};

/** Accumulated lighting result from PBR calculations. */
struct FLightingResult
{
	float3 Specular;        // Cook-Torrance specular contribution
	float3 Diffuse;         // Lambertian diffuse contribution
	float3 Ambient;         // Environment/ambient light
	float  Fresnel;         // Fresnel term for reflection blending
};

/** Parameters for reflection calculation. */
struct FReflectionResult
{
	float3 Color;           // Final reflection color
	float  BlendFactor;     // How much to blend reflection with base color
	float  SSRHitRatio;     // SSR hit ratio for Mode 3 blending
	float3 CubemapColor;    // Cubemap color (for Mode 3)
	float3 SSRColor;        // SSR color (for Mode 3)
};

// -----------------------------------------------------------------------------
// Fluid Surface Sampling
// -----------------------------------------------------------------------------

/**
 * Sample fluid surface properties from intermediate textures.
 * @param UV Original Screen UV coordinate (0-1)
 * @param FluidUV Transformed UV for fluid textures (with scale/offset applied)
 * @param SceneUV Scene texture UV coordinate (with SceneUVScale applied)
 * @param OutSurface Output surface data
 * @return true if valid fluid pixel, false if background or occluded
 */
bool SampleFluidSurface(float2 UV, float2 FluidUV, float2 SceneUV, out FFluidSurfaceData OutSurface)
{
	// Initialize output
	OutSurface = (FFluidSurfaceData)0;

	// Sample fluid depth (point sampling to avoid edge artifacts)
	OutSurface.Depth = FluidDepthTexture.Sample(PointClampSampler, FluidUV);

	// Discard background pixels (no fluid)
	if (OutSurface.Depth > BACKGROUND_DEPTH_THRESH)
	{
		return false;
	}

	// Check occlusion mask (precomputed in FluidDepth pass)
	OutSurface.OcclusionMask = OcclusionMaskTexture.SampleLevel(PointClampSampler, FluidUV, 0).r;
	if (OutSurface.OcclusionMask < 0.5)
	{
		return false;
	}

	// Sample normal and thickness
	OutSurface.Normal = FluidNormalTexture.Sample(PointClampSampler, FluidUV).xyz;
	OutSurface.Thickness = FluidThicknessTexture.Sample(PointClampSampler, FluidUV).r;

	// Apply thickness clamping if enabled
	if (bEnableThicknessClamping > 0)
	{
		OutSurface.Thickness = clamp(OutSurface.Thickness, ThicknessMin, ThicknessMax);
	}

	// Validate and normalize normal
	bool bInvalidNormal = any(isnan(OutSurface.Normal)) || any(isinf(OutSurface.Normal)) || length(OutSurface.Normal) < 0.1f;
	if (bInvalidNormal)
	{
		OutSurface.Normal = float3(0, 0, 1);
	}
	else
	{
		OutSurface.Normal = normalize(OutSurface.Normal);
	}

	// Reconstruct view-space position and direction
	OutSurface.ViewPos = ReconstructViewPosition(UV, OutSurface.Depth);
	OutSurface.ViewDir = normalize(-OutSurface.ViewPos);

	// Ensure normal faces camera with smooth transition to prevent rapid flipping/shimmering at grazing angles
	float NoV_Raw = dot(OutSurface.Normal, OutSurface.ViewDir);
	float FacingWeight = saturate(NoV_Raw * 10.0 + 0.5); // Smooth blend instead of hard if()
	OutSurface.Normal = normalize(lerp(OutSurface.ViewDir, OutSurface.Normal, FacingWeight));

	// Grazing angle compensation for stable shading
	float RawNoV = saturate(dot(OutSurface.Normal, OutSurface.ViewDir));
	float GrazingFade = smoothstep(0.0, 0.15, RawNoV);
	OutSurface.LightingNormal = normalize(lerp(OutSurface.ViewDir, OutSurface.Normal, GrazingFade));
	OutSurface.ReflectionNormal = OutSurface.Normal;

	return true;
}

// -----------------------------------------------------------------------------
// PBR Lighting Calculation
// -----------------------------------------------------------------------------

/**
 * Calculate PBR lighting using Cook-Torrance BRDF with multi-light support.
 * @param Surface Fluid surface data
 * @param OutLighting Output lighting result
 */
void CalculatePBRLighting(FFluidSurfaceData Surface, out FLightingResult OutLighting)
{
	OutLighting = (FLightingResult)0;

	// Calculate F0 from IOR
	float NoV = saturate(dot(Surface.LightingNormal, Surface.ViewDir));
	float IOR_Ratio = (1.0 - RefractiveIndex) / (1.0 + RefractiveIndex);
	float FinalF0 = IOR_Ratio * IOR_Ratio * FresnelStrength;
	float3 F0 = float3(FinalF0, FinalF0, FinalF0);

	// Clamp roughness to prevent divide by zero
	float Roughness = max(SpecularRoughness, 0.04);

	// Determine effective light count
	int EffectiveLightCount = (NumLights > 0) ? NumLights : 1;

	// Accumulate lighting from all lights
	for (int LightIndex = 0; LightIndex < EffectiveLightCount; LightIndex++)
	{
		float3 LightDir;
		float3 LightColor;

		if (NumLights > 0)
		{
			float4 DirAndIntensity = LightDirectionsAndIntensity[LightIndex];
			float4 ColorPacked = LightColors[LightIndex];
			LightDir = normalize(-DirAndIntensity.xyz);
			LightColor = ColorPacked.rgb * DirAndIntensity.w;
		}
		else
		{
			LightDir = normalize(-View.DirectionalLightDirection);
			LightColor = View.DirectionalLightColor.rgb;
		}

		// Calculate dot products
		float NoL = saturate(dot(Surface.LightingNormal, LightDir));
		float3 HalfDir = normalize(LightDir + Surface.ViewDir);
		float NoH = saturate(dot(Surface.LightingNormal, HalfDir));
		float HoV = saturate(dot(HalfDir, Surface.ViewDir));

		// Cook-Torrance BRDF
		float3 SpecularFresnel;
		float3 SpecularBRDF = CookTorranceBRDF(NoV, NoL, NoH, HoV, Roughness, F0, SpecularFresnel);
		OutLighting.Specular += SpecularBRDF * LightColor * NoL * SpecularStrength;

		// Energy-conserving diffuse
		float3 kD = 1.0 - SpecularFresnel;
		OutLighting.Diffuse += kD * NoL * LightColor;
	}

	// Apply lighting scale
	OutLighting.Specular *= LightingScale;

	// Calculate ambient
	float3 EnvironmentColor = View.SkyLightColor.rgb;
	if (dot(EnvironmentColor, float3(1, 1, 1)) < 0.001)
	{
		EnvironmentColor = View.DirectionalLightColor.rgb;
	}
	if (dot(EnvironmentColor, float3(1, 1, 1)) < 0.001)
	{
		EnvironmentColor = float3(1.0, 1.0, 1.0);
	}
	OutLighting.Ambient = EnvironmentColor * AmbientIntensity;

	// Calculate Fresnel for environment reflection (using NoV approximation)
	OutLighting.Fresnel = F0.r + (1.0 - F0.r) * pow(1.0 - NoV, 5.0);
}

// -----------------------------------------------------------------------------
// Volume Scattering
// -----------------------------------------------------------------------------

/**
 * Calculate volume scattering contribution using Henyey-Greenstein phase function.
 * @param Surface Fluid surface data
 * @return Scattering color contribution
 */
float3 CalculateVolumeScattering(FFluidSurfaceData Surface)
{
	// Derive scattering parameters from existing properties
	float ScatterAnisotropy = lerp(0.8, 0.2, Opacity);
	float3 ScatterColor = FluidColor.rgb;
	float ScatterStrength = ThicknessSensitivity;

	if (ScatterStrength < 0.001)
	{
		return float3(0, 0, 0);
	}

	float3 Contribution = float3(0, 0, 0);
	int ScatterLightCount = (NumLights > 0) ? NumLights : 1;

	for (int i = 0; i < ScatterLightCount; i++)
	{
		float3 LightDir;
		float3 LightColor;

		if (NumLights > 0)
		{
			float4 DirAndIntensity = LightDirectionsAndIntensity[i];
			float4 ColorPacked = LightColors[i];
			LightDir = normalize(-DirAndIntensity.xyz);
			LightColor = ColorPacked.rgb * DirAndIntensity.w;
		}
		else
		{
			LightDir = normalize(-View.DirectionalLightDirection);
			LightColor = View.DirectionalLightColor.rgb;
		}

		float VoL = dot(Surface.ViewDir, -LightDir);
		float Phase = HenyeyGreenstein(VoL, ScatterAnisotropy);
		float Extinction = 1.0 - exp(-Surface.Thickness * ScatterStrength * 0.1);

		Contribution += ScatterColor * LightColor * Phase * Extinction;
	}

	return Contribution * LightingScale;
}

// -----------------------------------------------------------------------------
// Refraction
// -----------------------------------------------------------------------------

/**
 * Calculate refracted background color with neighbor sampling fallback.
 * When refraction fails (points to object in front of fluid),
 * sample nearby valid refraction pixels and blend their colors.
 *
 * @param UV Screen UV coordinate
 * @param Surface Fluid surface data
 * @param SceneLinearDepth Scene depth at original UV
 * @param Fresnel Fresnel term (0=facing camera, 1=grazing angle)
 * @param OutRefractedColor Output refracted background color
 * @param OutRefractedDepth Output depth at refracted position (for caustics)
 * @param OutRefractionValidity Output validity factor (1.0 if direct refraction, 0.0~1.0 for neighbor blend)
 */
void CalculateRefraction(
	float2 UV,
	float2 FluidUV,
	FFluidSurfaceData Surface,
	float SceneLinearDepth,
	float Fresnel,
	out float3 OutRefractedColor,
	out float  OutRefractedDepth,
	out float  OutRefractionValidity)
{
	float2 SceneUV = UV * SceneUVScale + SceneUVOffset;

	if (!bEnableRefraction)
	{
		OutRefractedColor = SceneColorTexture.Sample(InputSampler, SceneUV).rgb;
		OutRefractedDepth = SceneLinearDepth;
		OutRefractionValidity = 0.0;
		return;
	}

	// Calculate depth difference for distance-based logic
	float DistToBackground = max(SceneLinearDepth - Surface.Depth, 1.0);

	// Calculate refraction mask (reduce at thin/edge areas for stability)
	float ThicknessMask = saturate(Surface.Thickness * 0.1);
	float EdgeMask = saturate(abs(Surface.Normal.z) * 2.0);
	float RefractionMask = ThicknessMask * EdgeMask;

	// Calculate refraction offset
	// 1. Normal-based displacement (for surface waves/ripples)
	float2 NormalOffset = Surface.Normal.xy * RefractiveIndex;

	// 2. Depth Compression (Apparent Depth)
	// Objects underwater appear shallower (closer to the surface).
	// This creates a parallax shift: the background is pulled toward the viewer along the view axis.
	// (1.0 - 1.0/n) is the lifting ratio (approx 0.25 for water).
	float DepthCompression = (1.0 - 1.0 / RefractiveIndex);
	float2 CompressionOffset = Surface.ViewDir.xy * DepthCompression * saturate(DistToBackground / 100.0);

	// Combined offset: even if Normal.xy is 0 (flat surface), CompressionOffset makes it look shallow.
	float2 RefractOffset = (NormalOffset + CompressionOffset) * RefractionScale * RefractionMask;

	// Edge fade: reduce refraction near screen edges
	float EdgeFadeDistance = 0.1;
	float2 EdgeFade = float2(
		(RefractOffset.x < 0) ? smoothstep(0.0, EdgeFadeDistance, UV.x) : smoothstep(0.0, EdgeFadeDistance, 1.0 - UV.x),
		(RefractOffset.y < 0) ? smoothstep(0.0, EdgeFadeDistance, UV.y) : smoothstep(0.0, EdgeFadeDistance, 1.0 - UV.y)
	);
	RefractOffset *= EdgeFade;

	float2 RefractedUV_Raw = UV + RefractOffset;

	// Out of bounds handling: fade to original color instead of hard fallback
	float2 OutOfBoundsLow = max(0.0 - RefractedUV_Raw, 0.0);
	float2 OutOfBoundsHigh = max(RefractedUV_Raw - 1.0, 0.0);
	float OutOfBoundsAmount = length(OutOfBoundsLow + OutOfBoundsHigh);
	float InBoundsBlend = saturate(1.0 - OutOfBoundsAmount / 0.05);

	float2 RefractedUV = saturate(RefractedUV_Raw);
	float2 RefractedSceneUV = RefractedUV * SceneUVScale;

	// Fluid view position for depth comparison
	float3 FluidViewPos = ReconstructViewPosition(UV, Surface.Depth);

	// Check if direct refraction is valid (simple and robust depth check)
	float RefractedDepth = ConvertFromDeviceZ(SceneDepthTexture.SampleLevel(PointClampSampler, RefractedSceneUV, 0).r);
	float3 RefractedViewPos = ReconstructViewPosition(RefractedUV, RefractedDepth);

	bool bNotSky = (RefractedDepth < BACKGROUND_DEPTH_THRESH);
	bool bDepthValid = (RefractedViewPos.z < FluidViewPos.z) && bNotSky;

	if (bDepthValid)
	{
		float3 RefractedColor = SceneColorTexture.Sample(InputSampler, RefractedSceneUV).rgb;
		float3 OriginalColor = SceneColorTexture.Sample(InputSampler, SceneUV).rgb;

		// Smoothly blend based on screen bounds validity
		OutRefractedColor = lerp(OriginalColor, RefractedColor, InBoundsBlend);
		OutRefractedDepth = RefractedDepth;
		OutRefractionValidity = InBoundsBlend;
		return;
	}

	// Direct refraction failed - sample valid neighbors (fallback)
	float2 PixelSize = 1.0 / ViewportSize;
	float SearchRadius = 8.0;

	// 8 directions
	float2 Directions[8] = {
		float2(1, 0), float2(-1, 0), float2(0, 1), float2(0, -1),
		float2(0.707, 0.707), float2(-0.707, 0.707), float2(0.707, -0.707), float2(-0.707, -0.707)
	};

	float3 AccumColor = float3(0, 0, 0);
	float AccumDepth = 0.0;
	float ValidWeight = 0.0;

	for (int i = 0; i < 8; i++)
	{
		float2 NeighborUV = UV + Directions[i] * PixelSize * SearchRadius;
		NeighborUV = saturate(NeighborUV);

		float NeighborFluidDepth = FluidDepthTexture.SampleLevel(PointClampSampler, NeighborUV, 0).r;
		if (NeighborFluidDepth > BACKGROUND_DEPTH_THRESH) continue;

		float3 NeighborNormal = FluidNormalTexture.SampleLevel(PointClampSampler, NeighborUV, 0).xyz;

		if (length(NeighborNormal) < 0.1) continue;
		NeighborNormal = normalize(NeighborNormal);

		float2 NeighborRefractOffset = NeighborNormal.xy * RefractiveIndex * RefractionScale * RefractionMask;
		float2 NeighborRefractedUV = saturate(NeighborUV + NeighborRefractOffset);

		float2 NeighborRefractedSceneUV = NeighborRefractedUV * SceneUVScale;
		float NeighborRefractedDepth = ConvertFromDeviceZ(SceneDepthTexture.SampleLevel(PointClampSampler, NeighborRefractedSceneUV, 0).r);

		float3 NeighborFluidViewPos = ReconstructViewPosition(NeighborUV, NeighborFluidDepth);
		float3 NeighborRefractedViewPos = ReconstructViewPosition(NeighborRefractedUV, NeighborRefractedDepth);

		bool bNeighborValid = (NeighborRefractedViewPos.z < NeighborFluidViewPos.z) && (NeighborRefractedDepth < BACKGROUND_DEPTH_THRESH);

		if (bNeighborValid)
		{
			AccumColor += SceneColorTexture.SampleLevel(InputSampler, NeighborRefractedSceneUV, 0).rgb;
			AccumDepth += NeighborRefractedDepth;
			ValidWeight += 1.0;
		}
	}

	if (ValidWeight > 0.0)
	{
		OutRefractedColor = AccumColor / ValidWeight;
		OutRefractedDepth = AccumDepth / ValidWeight;
		OutRefractionValidity = ValidWeight / 8.0;
	}
	else
	{
		OutRefractedColor = SceneColorTexture.Sample(InputSampler, SceneUV).rgb;
		OutRefractedDepth = SceneLinearDepth;
		OutRefractionValidity = 0.0;
	}
}

// -----------------------------------------------------------------------------
// Caustics
// -----------------------------------------------------------------------------

/**
 * Calculate caustic brightness multiplier.
 * @param UV Screen UV coordinate
 * @param FluidUV Transformed fluid UV
 * @param Surface Fluid surface data
 * @param RefractedDepth Depth at refracted position
 * @param RefractionValidity Whether refraction was used
 * @return Caustic brightness multiplier (1.0 = no effect)
 */
float CalculateCaustics(float2 UV, float2 FluidUV, FFluidSurfaceData Surface, float RefractedDepth, float RefractionValidity)
{
	// Caustics require refraction to be enabled (physically dependent)
	// User's bEnableCaustics choice is preserved in data for when refraction is re-enabled
	if (!bEnableCaustics || !bEnableRefraction)
	{
		return 1.0;
	}

	float Pattern = CausticPattern(UV, FluidUV, Surface.Normal, Surface.Depth, RefractedDepth, ViewMatrix, RefractiveIndex);
	float Brightness = 1.0 + Pattern * CausticIntensity;

	// Fade based on fluid properties
	// RefractionValidity removed - apply caustics even in fallback regions
	float DepthFade = saturate(1.0 - Surface.Depth * 0.0003);
	float ThicknessFade = exp(-Surface.Thickness * 0.015);
	float TransparencyFade = saturate(1.0 - Opacity * 0.7);
	float CausticFade = DepthFade * ThicknessFade * TransparencyFade;

	return lerp(1.0, Brightness, CausticFade);
}

// -----------------------------------------------------------------------------
// Beer's Law Transmittance
// -----------------------------------------------------------------------------

/**
 * Calculate Beer's Law transmittance and blend with fluid color.
 *
 * Beer's Law: T = exp(-μ * c * d)
 *   μ = absorption coefficient (computed from -log(FluidColor) in C++)
 *   c = concentration (Opacity parameter, 0-1)
 *   d = thickness
 *
 * @param RefractedBackground Refracted/caustic-modified background color
 * @param Thickness Fluid thickness at this pixel
 * @param TotalLighting Total lighting (diffuse + ambient)
 * @return Blended base color
 */
float3 CalculateTransmittance(float3 RefractedBackground, float Thickness, float3 TotalLighting)
{
	// Beer's Law: Transmittance = exp(-absorption * concentration * thickness)
	// AbsorptionColorCoefficients = -log(FluidColor), pre-computed in C++
	// Opacity acts as concentration multiplier (0 = fully transparent, 1 = normal density)
	float3 Transmittance = exp(-AbsorptionColorCoefficients.rgb * Opacity * Thickness);

	// Apply transmittance to background
	float3 TransmittedBackground = RefractedBackground * Transmittance;

	// Blend with fluid color based on overall absorption
	// As more light is absorbed, the fluid's own color becomes more visible
	float OverallAbsorption = 1.0 - dot(Transmittance, float3(0.333, 0.333, 0.333));
	float3 LitFluidColor = FluidColor.rgb * TotalLighting;

	return lerp(TransmittedBackground, LitFluidColor, saturate(OverallAbsorption));
}

// -----------------------------------------------------------------------------
// Reflection (Mode-based)
// -----------------------------------------------------------------------------

/**
 * Calculate cubemap reflection color.
 * @param ViewSpaceReflect Reflection vector in view space
 * @return Cubemap reflection color
 */
float3 SampleCubemapReflection(float3 ViewSpaceReflect)
{
	if (bUseReflectionCubemap > 0)
	{
		float3x3 ViewToWorld = transpose((float3x3)ViewMatrix);
		float3 WorldReflect = mul(ViewSpaceReflect, ViewToWorld);
		float MipLevel = ReflectionMipLevel + SpecularRoughness * 6.0;
		return ReflectionCubemap.SampleLevel(ReflectionCubemapSampler, WorldReflect, MipLevel).rgb * ReflectionIntensity;
	}

	// Fallback to environment light
	float3 FallbackColor = View.SkyLightColor.rgb;
	if (dot(FallbackColor, float3(1, 1, 1)) < 0.001)
	{
		FallbackColor = View.DirectionalLightColor.rgb;
	}
	if (dot(FallbackColor, float3(1, 1, 1)) < 0.001)
	{
		FallbackColor = float3(1.0, 1.0, 1.0);
	}
	return FallbackColor * 0.3;
}

/**
 * Calculate reflection based on ReflectionMode.
 * @param Surface Fluid surface data
 * @param Fresnel Fresnel term
 * @param OutResult Output reflection result
 */
void CalculateReflection(FFluidSurfaceData Surface, float Fresnel, out FReflectionResult OutResult)
{
	OutResult = (FReflectionResult)0;

	float3 ViewSpaceReflect = reflect(-Surface.ViewDir, Surface.ReflectionNormal);

	// Mode 0: No Reflection
	if (ReflectionMode == 0)
	{
		OutResult.BlendFactor = 0.0;
		return;
	}

	// Mode 1: Cubemap Only
	if (ReflectionMode == 1)
	{
		OutResult.Color = SampleCubemapReflection(ViewSpaceReflect);
		OutResult.BlendFactor = Fresnel * FresnelReflectionBlend;
		return;
	}

	// Mode 2: SSR Only
	if (ReflectionMode == 2)
	{
		float2 SSRHitUV;
		float3 SSRHitColor;
		float SSRHitStrength = TraceSSR(Surface.ViewPos, ViewSpaceReflect, SSRHitUV, SSRHitColor);

		OutResult.Color = (SSRHitStrength > 0.0) ? SSRHitColor * SSRHitStrength : float3(0, 0, 0);
		OutResult.BlendFactor = Fresnel * ScreenSpaceReflectionIntensity * SSRHitStrength;
		return;
	}

	// Mode 3: SSR + Cubemap Fallback
	if (ReflectionMode == 3)
	{
		float2 SSRHitUV;
		float3 SSRHitColor;
		float SSRHit = TraceSSR(Surface.ViewPos, ViewSpaceReflect, SSRHitUV, SSRHitColor);

		OutResult.CubemapColor = SampleCubemapReflection(ViewSpaceReflect);
		OutResult.SSRColor = SSRHitColor;
		OutResult.SSRHitRatio = SSRHit;
		OutResult.BlendFactor = 1.0;  // Handled specially in composite
		return;
	}
}

/**
 * Blend reflection with base color based on reflection mode.
 * @param BaseColor Input base color
 * @param Fresnel Fresnel term
 * @param Reflection Reflection result
 * @return Blended color
 */
float3 BlendReflection(float3 BaseColor, float Fresnel, FReflectionResult Reflection)
{
	if (ReflectionMode == 3)
	{
		// Mode 3: Blend each reflection type separately, then combine
		float3 CubemapResult = lerp(BaseColor, Reflection.CubemapColor, Fresnel * FresnelReflectionBlend);
		float3 SSRResult = lerp(BaseColor, Reflection.SSRColor, Fresnel * ScreenSpaceReflectionIntensity);
		return lerp(CubemapResult, SSRResult, Reflection.SSRHitRatio);
	}

	return lerp(BaseColor, Reflection.Color, Reflection.BlendFactor);
}

// -----------------------------------------------------------------------------
// Pixel Shader
// -----------------------------------------------------------------------------

void MainPS(
	FCompositeVSToPS Input,
	out float4 OutColor : SV_Target0)
{
	float2 UV = Input.UV;
	float2 SceneUV = UV * SceneUVScale + SceneUVOffset;
	float2 FluidUV = UV * FluidUVScale + FluidUVOffset;

	// Sample fluid surface properties
	FFluidSurfaceData Surface;
	if (!SampleFluidSurface(UV, FluidUV, SceneUV, Surface))
	{
		discard;
		return;
	}

	// Get scene depth
	float SceneDeviceZ = SceneDepthTexture.SampleLevel(PointClampSampler, SceneUV, 0).r;
	float SceneLinearDepth = ConvertFromDeviceZ(SceneDeviceZ);

	// Calculate PBR lighting
	FLightingResult Lighting;
	CalculatePBRLighting(Surface, Lighting);

	// Calculate volume scattering
	float3 VolumeScatter = CalculateVolumeScattering(Surface);

	// Calculate refraction
	float3 RefractedBackground;
	float RefractedDepth;
	float RefractionValidity;
	CalculateRefraction(UV, FluidUV, Surface, SceneLinearDepth, Lighting.Fresnel, RefractedBackground, RefractedDepth, RefractionValidity);

	// Apply caustics
	float CausticBrightness = CalculateCaustics(UV, FluidUV, Surface, RefractedDepth, RefractionValidity);
	RefractedBackground *= CausticBrightness;

	// Calculate transmittance and base color
	float3 TotalLighting = (Lighting.Diffuse + Lighting.Ambient) * LightingScale;
	float3 BaseColor = CalculateTransmittance(RefractedBackground, Surface.Thickness, TotalLighting);

	// Calculate reflection
	FReflectionResult Reflection;
	CalculateReflection(Surface, Lighting.Fresnel, Reflection);

	// Blend reflection with base color
	BaseColor = BlendReflection(BaseColor, Lighting.Fresnel, Reflection);

	// Final color composition
	float3 FinalColor = BaseColor + Lighting.Specular + VolumeScatter;

	// Apply PreExposure for UE5 HDR pipeline
	FinalColor *= View.PreExposure;

	// Always opaque within fluid region - Beer's Law already handles transparency
	// Original scene is sampled via refraction, not alpha blending
	OutColor = float4(FinalColor, 1.0);
}
