// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Fluid Physics - Extract Render Data Pass
// Converts physics particle buffer to render particle buffer (GPU â†’ GPU)

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"

//=============================================================================
// Render Particle Structure (must match FKawaiiRenderParticle - 32 bytes)
//=============================================================================

struct FRenderParticle
{
	float3 Position;
	float3 Velocity;
	float Radius;
	float Padding;
};

//=============================================================================
// Shader Parameters
//=============================================================================

StructuredBuffer<FGPUFluidParticle> PhysicsParticles;
RWStructuredBuffer<FRenderParticle> RenderParticles;
StructuredBuffer<uint> ParticleCountBuffer;
float ParticleRadius;

// SoA (Structure of Arrays) output buffers - Memory bandwidth optimization
RWStructuredBuffer<float3> RenderPositions;   // 12B per particle (SDF hot path)
RWStructuredBuffer<float3> RenderVelocities;  // 12B per particle (for motion blur)


//=============================================================================
// Main Compute Shader (Legacy AoS output)
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ExtractRenderDataCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	uint ParticleCount = ParticleCountBuffer[6];
	if (idx >= ParticleCount)
	{
		return;
	}

	FGPUFluidParticle physics = PhysicsParticles[idx];

	// Validate position - skip particles with invalid/extreme positions
	float3 pos = physics.Position;
	bool bValidPosition = !any(isnan(pos)) && !any(isinf(pos)) &&
						  abs(pos.x) < 1e10 && abs(pos.y) < 1e10 && abs(pos.z) < 1e10;

	FRenderParticle render;
	if (bValidPosition)
	{
		render.Position = pos;
		render.Velocity = physics.Velocity;
	}
	else
	{
		// Invalid particle - place at infinity so it won't be rendered
		render.Position = float3(1e20, 1e20, 1e20);
		render.Velocity = float3(0, 0, 0);
	}
	render.Radius = ParticleRadius;
	render.Padding = 0.0f;

	RenderParticles[idx] = render;
}

//=============================================================================
// SoA Compute Shader (Memory bandwidth optimization)
// - 32B/particle to 12B/particle (62% reduction when using Position only)
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ExtractRenderDataSoACS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	uint ParticleCount = ParticleCountBuffer[6];
	if (idx >= ParticleCount)
	{
		return;
	}

	FGPUFluidParticle physics = PhysicsParticles[idx];

	// Validate position - skip particles with invalid/extreme positions
	float3 pos = physics.Position;
	float3 vel = physics.Velocity;

	bool bValidPosition = !any(isnan(pos)) && !any(isinf(pos)) &&
						  abs(pos.x) < 1e10 && abs(pos.y) < 1e10 && abs(pos.z) < 1e10;

	if (!bValidPosition)
	{
		// Invalid particle - place at infinity so it won't be rendered
		pos = float3(1e20, 1e20, 1e20);
		vel = float3(0, 0, 0);
	}

	// SoA output - Store each attribute in separate buffer
	RenderPositions[idx] = pos;
	RenderVelocities[idx] = vel;
}
