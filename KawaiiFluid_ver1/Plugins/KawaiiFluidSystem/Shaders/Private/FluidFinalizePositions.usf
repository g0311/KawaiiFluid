// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Fluid Physics - Finalize Positions Pass
// Updates positions from predictions and recalculates velocities

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"

//=============================================================================
// Shader Parameters
//=============================================================================

RWStructuredBuffer<FGPUFluidParticle> Particles;
int ParticleCount;
float DeltaTime;
float MaxVelocity;      // Safety clamp to prevent divergence
float GlobalDamping;    // Velocity damping per substep (1.0 = no damping)

//=============================================================================
// Main Compute Shader
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void FinalizePositionsCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)ParticleCount)
	{
		return;
	}

	FGPUFluidParticle particle = Particles[idx];

	// Skip attached particles (CPU attachment or GPU boundary attachment)
	// Check both IS_ATTACHED and IS_BOUNDARY_ATTACHED flags
	if (HasFlag(particle.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED) || 
		HasFlag(particle.Flags, GPU_PARTICLE_FLAG_IS_BOUNDARY_ATTACHED))
	{
		// For attached particles, just sync position
		particle.Position = particle.PredictedPosition;
		Particles[idx] = particle;
		return;
	}

	// Store old position for velocity calculation
	float3 oldPosition = particle.Position;

	// Finalize position
	particle.Position = particle.PredictedPosition;

	// Recalculate velocity from position change (pure PBF formula per paper Algorithm 1 line 22)
	// v = (x* - x) / dt
	float invDt = 1.0f / max(DeltaTime, 0.0001f);
	particle.Velocity = (particle.Position - oldPosition) * invDt;

	// Safety clamp: prevent extreme velocities that could cause divergence
	float velocityMag = length(particle.Velocity);
	if (velocityMag > MaxVelocity)
	{
		particle.Velocity = (particle.Velocity / velocityMag) * MaxVelocity;
	}

	// Apply global damping to dissipate energy
	// GlobalDamping of 0.995 means 0.5% energy loss per substep
	particle.Velocity *= GlobalDamping;

	// Clear frame-specific flags
	particle.Flags = ClearFlag(particle.Flags, GPU_PARTICLE_FLAG_JUST_DETACHED);

	Particles[idx] = particle;
}
