// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Fluid Physics - Finalize Positions Pass
// Updates positions from predictions and recalculates velocities

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"

//=============================================================================
// Shader Parameters (SoA - Structure of Arrays)
//=============================================================================

RWBuffer<float> Positions;              // float3 as 3 floats
RWBuffer<float> PredictedPositions;     // float3 as 3 floats
RWBuffer<float> Velocities;             // float3 as 3 floats
RWBuffer<uint> Flags;

int ParticleCount;
float DeltaTime;
float MaxVelocity;      // Safety clamp to prevent divergence
float GlobalDamping;    // Velocity damping per substep (1.0 = no damping)

//=============================================================================
// Main Compute Shader
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void FinalizePositionsCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)ParticleCount)
	{
		return;
	}

	uint idx3 = idx * 3;
	uint flags = Flags[idx];

	// Read current values
	float3 position = float3(Positions[idx3], Positions[idx3 + 1], Positions[idx3 + 2]);
	float3 predictedPosition = float3(PredictedPositions[idx3], PredictedPositions[idx3 + 1], PredictedPositions[idx3 + 2]);
	float3 velocity = float3(Velocities[idx3], Velocities[idx3 + 1], Velocities[idx3 + 2]);

	// Skip CPU-attached particles (they follow bone position directly)
	if (HasFlag(flags, GPU_PARTICLE_FLAG_IS_ATTACHED))
	{
		// For CPU-attached particles, just sync position
		Positions[idx3] = predictedPosition.x;
		Positions[idx3 + 1] = predictedPosition.y;
		Positions[idx3 + 2] = predictedPosition.z;
		return;
	}

	// NEAR_BOUNDARY particles: position and velocity already set by ApplyBoneTransform
	// Don't recalculate velocity from position change (would cause explosion)
	if (HasFlag(flags, GPU_PARTICLE_FLAG_NEAR_BOUNDARY))
	{
		Positions[idx3] = predictedPosition.x;
		Positions[idx3 + 1] = predictedPosition.y;
		Positions[idx3 + 2] = predictedPosition.z;

		// Keep bone velocity, just apply damping
		velocity *= GlobalDamping;
		Velocities[idx3] = velocity.x;
		Velocities[idx3 + 1] = velocity.y;
		Velocities[idx3 + 2] = velocity.z;

		Flags[idx] = ClearFlag(flags, GPU_PARTICLE_FLAG_JUST_DETACHED);
		return;
	}

	// Store old position for velocity calculation
	float3 oldPosition = position;

	// Update position from predicted position
	position = predictedPosition;

	// Recalculate velocity from position change (pure PBF formula per paper Algorithm 1 line 22)
	// v = (x* - x) / dt
	float invDt = 1.0f / max(DeltaTime, 0.0001f);
	velocity = (position - oldPosition) * invDt;

	// Safety clamp: prevent extreme velocities that could cause divergence
	float velocityMag = length(velocity);
	if (velocityMag > MaxVelocity)
	{
		velocity = (velocity / velocityMag) * MaxVelocity;
	}

	// Apply global damping to dissipate energy
	// GlobalDamping of 0.995 means 0.5% energy loss per substep
	velocity *= GlobalDamping;

	// Clear frame-specific flags
	flags = ClearFlag(flags, GPU_PARTICLE_FLAG_JUST_DETACHED);

	// Write back
	Positions[idx3] = position.x;
	Positions[idx3 + 1] = position.y;
	Positions[idx3 + 2] = position.z;

	Velocities[idx3] = velocity.x;
	Velocities[idx3 + 1] = velocity.y;
	Velocities[idx3 + 2] = velocity.z;

	Flags[idx] = flags;
}
