// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Fluid Physics - Finalize Positions Pass
// Updates positions from predictions and recalculates velocities

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"

//=============================================================================
// Shader Parameters
//=============================================================================

RWStructuredBuffer<FGPUFluidParticle> Particles;
int ParticleCount;
float DeltaTime;
float MaxVelocity;  // Safety clamp to prevent divergence (high value, e.g., 50000 cm/s)

//=============================================================================
// Main Compute Shader
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void FinalizePositionsCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)ParticleCount)
	{
		return;
	}

	FGPUFluidParticle particle = Particles[idx];

	// Skip attached particles
	if (HasFlag(particle.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED))
	{
		// For attached particles, just sync position
		particle.Position = particle.PredictedPosition;
		Particles[idx] = particle;
		return;
	}

	// Store old position for velocity calculation
	float3 oldPosition = particle.Position;

	// Finalize position
	particle.Position = particle.PredictedPosition;

	// Recalculate velocity from position change (matches CPU behavior)
	// v = (x_new - x_old) / dt
	float invDt = 1.0f / max(DeltaTime, 0.0001f);
	particle.Velocity = (particle.Position - oldPosition) * invDt;

	// Safety clamp: prevent extreme velocities that could cause divergence
	// This is a high threshold (50000 cm/s = 500 m/s) that shouldn't affect normal simulation
	float velocityMag = length(particle.Velocity);
	if (velocityMag > MaxVelocity)
	{
		particle.Velocity = (particle.Velocity / velocityMag) * MaxVelocity;
	}

	// Clear frame-specific flags
	particle.Flags = ClearFlag(particle.Flags, GPU_PARTICLE_FLAG_JUST_DETACHED);

	Particles[idx] = particle;
}
