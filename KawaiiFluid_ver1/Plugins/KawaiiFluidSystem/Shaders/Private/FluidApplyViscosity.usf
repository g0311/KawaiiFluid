// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Fluid Physics - Viscosity Pass
//
// Components:
// 1. XSPH Viscosity: Velocity smoothing between particles
// 2. Laplacian Viscosity: Physical drag force
// 3. Boundary Viscosity: Fluid following moving boundaries
//
// Note: Cohesion is now handled in PredictPositions (Phase 2) as a Force

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"
#include "FluidSpatialHash.ush"
#include "FluidMortonUtils.ush"

//=============================================================================
// Shader Parameters
//=============================================================================

RWStructuredBuffer<FGPUFluidParticle> Particles;
StructuredBuffer<uint> CellCounts;
StructuredBuffer<uint> ParticleIndices;

// Neighbor caching buffers (reused from DensityPressure pass)
StructuredBuffer<uint> NeighborList;
StructuredBuffer<uint> NeighborCounts;

int ParticleCount;
float SmoothingRadius;
float CellSize;
float DeltaTime;
int bUseNeighborCache;

// Viscosity parameters
float ViscosityCoefficient;
float Poly6Coeff;
float ViscLaplacianCoeff;  // 45 / (PI * h^6)

// Viscosity tuning constants
#define LAPLACIAN_VISCOSITY_SCALE 0.0001f
#define VELOCITY_DRAG_SCALE 5.0f

//=============================================================================
// Boundary Particles
//=============================================================================
struct FGPUBoundaryParticle
{
	float3 Position;      // 12 bytes - World position
	float Psi;            // 4 bytes  - Boundary particle "mass" (total: 16)
	float3 Normal;        // 12 bytes - Surface normal
	int OwnerID;          // 4 bytes  - Owner component ID (total: 32)
	float3 Velocity;      // 12 bytes - World velocity
	float FrictionCoeff;  // 4 bytes  - Coulomb friction coefficient (total: 48)
};

StructuredBuffer<FGPUBoundaryParticle> BoundaryParticles;
int BoundaryParticleCount;
int bUseBoundaryViscosity;
float AdhesionForceStrength;     // Akinci 2013 adhesion force (0~50)
float AdhesionVelocityStrength;  // Velocity transfer strength (0~5)
float AdhesionRadius;

// Z-Order sorted boundary particles
StructuredBuffer<FGPUBoundaryParticle> SortedBoundaryParticles;
StructuredBuffer<uint> BoundaryCellStart;
StructuredBuffer<uint> BoundaryCellEnd;
int bUseBoundaryZOrder;
float3 MortonBoundsMin;

// Boundary velocity transfer
float BoundaryVelocityTransferStrength;
float BoundaryDetachSpeedThreshold;
float BoundaryMaxDetachSpeed;

//=============================================================================
// Z-Order Cell ID Calculation
//=============================================================================
uint GetMortonCellIDFromCellCoord(int3 cellCoord)
{
	int3 gridMin = int3(floor(MortonBoundsMin / CellSize));
	int3 offset = cellCoord - gridMin;
	uint3 uoffset = uint3(max(offset, int3(0, 0, 0)));
	uoffset = min(uoffset, uint3(MORTON_MAX_VALUE, MORTON_MAX_VALUE, MORTON_MAX_VALUE));
	return Morton3D(uoffset.x, uoffset.y, uoffset.z);
}

//=============================================================================
// Main Compute Shader
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ApplyViscosityCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)ParticleCount)
	{
		return;
	}

	FGPUFluidParticle particle = Particles[idx];

	// Skip CPU-attached particles only (they follow bone position directly)
	// Boundary-attached particles still receive physics - they just follow character movement
	if (HasFlag(particle.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED))
	{
		return;
	}

	// Skip if viscosity is disabled
	if (ViscosityCoefficient <= 0.0f)
	{
		return;
	}

	float3 pos = particle.PredictedPosition;
	float3 vel = particle.Velocity;

	// Convert smoothing radius to meters for kernel calculations
	float h_m = SmoothingRadius * CM_TO_M;
	float h2 = h_m * h_m;
	float smoothingRadiusSq_cm = SmoothingRadius * SmoothingRadius;

	// Viscosity accumulators
	float3 velocityCorrection = float3(0.0f, 0.0f, 0.0f);
	float weightSum = 0.0f;
	float3 laplacianForce = float3(0.0f, 0.0f, 0.0f);

	//=========================================================================
	// Neighbor loop: Viscosity calculation
	//=========================================================================
	if (bUseNeighborCache)
	{
		uint cachedCount = NeighborCounts[idx];
		uint baseIdx = idx * MAX_NEIGHBORS_PER_PARTICLE;

		for (uint n = 0; n < cachedCount; ++n)
		{
			uint neighborIdx = NeighborList[baseIdx + n];

			if (neighborIdx == idx)
			{
				continue;
			}

			FGPUFluidParticle neighbor = Particles[neighborIdx];

			// Skip CPU-attached neighbors only
			if (HasFlag(neighbor.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED))
			{
				continue;
			}

			float3 r_cm = pos - neighbor.PredictedPosition;
			float r2_cm = dot(r_cm, r_cm);

			if (r2_cm < SMALL_NUMBER || r2_cm > smoothingRadiusSq_cm)
			{
				continue;
			}

			float rLenInv_cm = rsqrt(r2_cm);
			float dist_cm = r2_cm * rLenInv_cm;
			float dist_m = dist_cm * CM_TO_M;
			float r2_m = dist_m * dist_m;

			// Viscosity calculation
			if (r2_m < h2)
			{
				float w = Poly6Kernel(r2_m, h2) * Poly6Coeff;
				float3 velDiff = neighbor.Velocity - vel;
				velocityCorrection += velDiff * w;
				weightSum += w;

				// Laplacian viscosity
				float laplacian = ViscosityLaplacian(dist_m, h_m, ViscLaplacianCoeff);
				float neighborDensity = max(neighbor.Density, 0.001f);
				laplacianForce += velDiff * laplacian * neighbor.Mass / neighborDensity;
			}
		}
	}
	else
	{
		//=====================================================================
		// Fallback: Hash-based neighbor search
		//=====================================================================
		int3 centerCell = WorldToCell(pos, CellSize);
		int cellRadius = (int)ceil(SmoothingRadius / CellSize);

		for (int dz = -cellRadius; dz <= cellRadius; ++dz)
		{
			for (int dy = -cellRadius; dy <= cellRadius; ++dy)
			{
				for (int dx = -cellRadius; dx <= cellRadius; ++dx)
				{
					int3 neighborCell = centerCell + int3(dx, dy, dz);
					uint hash = HashCell(neighborCell);
					uint count = min(CellCounts[hash], (uint)MAX_PARTICLES_PER_CELL);
					uint startIdx = hash * MAX_PARTICLES_PER_CELL;

					for (uint i = 0; i < count; ++i)
					{
						uint neighborIdx = ParticleIndices[startIdx + i];
						if (neighborIdx == idx || neighborIdx >= (uint)ParticleCount) continue;

						FGPUFluidParticle neighbor = Particles[neighborIdx];
						if (HasFlag(neighbor.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED)) continue;

						float3 r_cm = pos - neighbor.PredictedPosition;
						float r2_cm = dot(r_cm, r_cm);
						if (r2_cm < SMALL_NUMBER || r2_cm > smoothingRadiusSq_cm) continue;

						float rLenInv_cm = rsqrt(r2_cm);
						float dist_cm = r2_cm * rLenInv_cm;
						float dist_m = dist_cm * CM_TO_M;
						float r2_m = dist_m * dist_m;

						// Viscosity
						if (r2_m < h2)
						{
							float w = Poly6Kernel(r2_m, h2) * Poly6Coeff;
							float3 velDiff = neighbor.Velocity - vel;
							velocityCorrection += velDiff * w;
							weightSum += w;

							float laplacian = ViscosityLaplacian(dist_m, h_m, ViscLaplacianCoeff);
							float neighborDensity = max(neighbor.Density, 0.001f);
							laplacianForce += velDiff * laplacian * neighbor.Mass / neighborDensity;
						}
					}
				}
			}
		}
	}

	//=========================================================================
	// Boundary Viscosity (fluid following moving boundaries)
	//=========================================================================
	if (bUseBoundaryViscosity && BoundaryParticleCount > 0 && AdhesionForceStrength > 0.0f && AdhesionRadius > 0.0f)
	{
		float clampedAdhesion = saturate(AdhesionForceStrength);
		float adhesionRadius_m = AdhesionRadius * CM_TO_M;
		float adhesionRadius2 = adhesionRadius_m * adhesionRadius_m;

		if (bUseBoundaryZOrder)
		{
			int3 centerCell = WorldToCell(pos, CellSize);
			int cellRadius = (int)ceil(AdhesionRadius / CellSize);

			for (int dz = -cellRadius; dz <= cellRadius; ++dz)
			{
				for (int dy = -cellRadius; dy <= cellRadius; ++dy)
				{
					for (int dx = -cellRadius; dx <= cellRadius; ++dx)
					{
						int3 neighborCell = centerCell + int3(dx, dy, dz);
						uint cellID = GetMortonCellIDFromCellCoord(neighborCell);
						uint bCellStart = BoundaryCellStart[cellID];
						uint bCellEnd = BoundaryCellEnd[cellID];

						if (bCellStart == INVALID_INDEX || bCellEnd == INVALID_INDEX)
							continue;

						for (uint bi = bCellStart; bi <= bCellEnd; ++bi)
						{
							FGPUBoundaryParticle boundary = SortedBoundaryParticles[bi];
							float3 r_cm = pos - boundary.Position;
							float r2_cm = dot(r_cm, r_cm);
							float r2 = r2_cm * CM_TO_M_SQ;

							if (r2 < adhesionRadius2 && r2 > SMALL_NUMBER)
							{
								float w = Poly6Kernel(r2, adhesionRadius2) * Poly6Coeff;

								float3 relativeVelocity = vel - boundary.Velocity;
								float relativeSpeed = length(relativeVelocity);

								float detachFactor = smoothstep(BoundaryDetachSpeedThreshold, BoundaryMaxDetachSpeed, relativeSpeed);
								float transferFactor = (1.0f - detachFactor) * BoundaryVelocityTransferStrength;

								float3 velDiff = boundary.Velocity - vel;
								velocityCorrection += velDiff * w * boundary.Psi * clampedAdhesion * transferFactor;
								weightSum += w * boundary.Psi * clampedAdhesion * transferFactor;
							}
						}
					}
				}
			}
		}
		else
		{
			for (int bi = 0; bi < BoundaryParticleCount; ++bi)
			{
				FGPUBoundaryParticle boundary = BoundaryParticles[bi];
				float3 r_cm = pos - boundary.Position;
				float r2_cm = dot(r_cm, r_cm);
				float r2 = r2_cm * CM_TO_M_SQ;

				if (r2 < adhesionRadius2 && r2 > SMALL_NUMBER)
				{
					float w = Poly6Kernel(r2, adhesionRadius2) * Poly6Coeff;

					float3 relativeVelocity = vel - boundary.Velocity;
					float relativeSpeed = length(relativeVelocity);

					float detachFactor = smoothstep(BoundaryDetachSpeedThreshold, BoundaryMaxDetachSpeed, relativeSpeed);
					float transferFactor = (1.0f - detachFactor) * BoundaryVelocityTransferStrength;

					float3 velDiff = boundary.Velocity - vel;
					velocityCorrection += velDiff * w * boundary.Psi * clampedAdhesion * transferFactor;
					weightSum += w * boundary.Psi * clampedAdhesion * transferFactor;
				}
			}
		}
	}

	//=========================================================================
	// Apply Viscosity
	//=========================================================================
	// XSPH velocity smoothing
	if (weightSum > SMALL_NUMBER)
	{
		velocityCorrection /= weightSum;
		particle.Velocity += ViscosityCoefficient * velocityCorrection;
	}

	// Laplacian viscosity (drag force)
	float mu = ViscosityCoefficient * ViscosityCoefficient * LAPLACIAN_VISCOSITY_SCALE;
	if (mu > SMALL_NUMBER)
	{
		particle.Velocity += mu * laplacianForce * DeltaTime;
	}

	// Velocity drag (air resistance)
	float dragCoeff = ViscosityCoefficient * ViscosityCoefficient * VELOCITY_DRAG_SCALE;
	if (dragCoeff > SMALL_NUMBER)
	{
		float damping = 1.0f - dragCoeff * DeltaTime;
		damping = max(damping, 0.0f);
		particle.Velocity *= damping;
	}

	Particles[idx] = particle;
}
