// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Fluid Physics - Apply Viscosity Pass (OPTIMIZED)
// Applies XSPH viscosity for smoother fluid motion
//
// Optimizations:
// 1. Loop Unroll: Explicit 27-cell unrolling for cellRadius=1 case
// 2. Neighbor Caching: Reuses neighbor list from DensityPressure pass

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"
#include "FluidSpatialHash.ush"

//=============================================================================
// Shader Parameters
//=============================================================================

RWStructuredBuffer<FGPUFluidParticle> Particles;
StructuredBuffer<uint> CellCounts;
StructuredBuffer<uint> ParticleIndices;

// Neighbor caching buffers (reused from DensityPressure pass)
StructuredBuffer<uint> NeighborList;
StructuredBuffer<uint> NeighborCounts;

int ParticleCount;
float SmoothingRadius;
float ViscosityCoefficient;
float Poly6Coeff;
float CellSize;
int bUseNeighborCache;

//=============================================================================
// Boundary Particles for viscosity contribution
//=============================================================================
struct FGPUBoundaryParticle
{
	float3 Position;    // World position
	float Psi;          // Boundary particle "mass" (volume contribution)
	float3 Normal;      // Surface normal
	int OwnerID;        // Owner component ID
};

StructuredBuffer<FGPUBoundaryParticle> BoundaryParticles;
int BoundaryParticleCount;
int bUseBoundaryViscosity;

//=============================================================================
// Unrolled 27-Cell Viscosity Processing Macro (Fallback when cache not available)
//=============================================================================
#define PROCESS_VISCOSITY_CELL(DX, DY, DZ) \
{ \
	int3 neighborCell = centerCell + int3(DX, DY, DZ); \
	uint hash = HashCell(neighborCell); \
	uint count = min(CellCounts[hash], (uint)MAX_PARTICLES_PER_CELL); \
	uint startIdx = hash * MAX_PARTICLES_PER_CELL; \
	for (uint i = 0; i < count; ++i) \
	{ \
		uint neighborIdx = ParticleIndices[startIdx + i]; \
		if (neighborIdx == idx || neighborIdx >= (uint)ParticleCount) continue; \
		FGPUFluidParticle neighbor = Particles[neighborIdx]; \
		if (HasFlag(neighbor.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED)) continue; \
		float3 r_cm = pos - neighbor.PredictedPosition; \
		float r2_cm = dot(r_cm, r_cm); \
		float r2 = r2_cm * CM_TO_M_SQ; \
		if (r2 < h2) \
		{ \
			float w = Poly6Kernel(r2, h2) * Poly6Coeff; \
			float3 velDiff = neighbor.Velocity - vel; \
			velocityCorrection += velDiff * w; \
			weightSum += w; \
		} \
	} \
}

//=============================================================================
// Main Compute Shader
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ApplyViscosityCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)ParticleCount)
	{
		return;
	}

	FGPUFluidParticle particle = Particles[idx];

	// Skip attached particles
	if (HasFlag(particle.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED))
	{
		return;
	}

	// Skip if viscosity is disabled
	if (ViscosityCoefficient <= 0.0f)
	{
		return;
	}

	float3 pos = particle.PredictedPosition;
	float3 vel = particle.Velocity;

	// IMPORTANT: Convert smoothing radius from cm to m for kernel calculations
	// Kernel coefficients (Poly6Coeff) are precomputed with h in meters
	float h = SmoothingRadius * CM_TO_M;  // Convert to meters
	float h2 = h * h;

	// XSPH velocity correction accumulator
	float3 velocityCorrection = float3(0.0f, 0.0f, 0.0f);
	float weightSum = 0.0f;

	//=========================================================================
	// Use cached neighbor list if available (much faster!)
	//=========================================================================
	if (bUseNeighborCache)
	{
		uint cachedCount = NeighborCounts[idx];
		uint baseIdx = idx * MAX_NEIGHBORS_PER_PARTICLE;

		for (uint n = 0; n < cachedCount; ++n)
		{
			uint neighborIdx = NeighborList[baseIdx + n];

			// Skip self (shouldn't be in cache, but safety check)
			if (neighborIdx == idx)
			{
				continue;
			}

			FGPUFluidParticle neighbor = Particles[neighborIdx];

			// Skip attached neighbors
			if (HasFlag(neighbor.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED))
			{
				continue;
			}

			float3 r_cm = pos - neighbor.PredictedPosition;
			float r2_cm = dot(r_cm, r_cm);
			float r2 = r2_cm * CM_TO_M_SQ;

			// Distance check still needed as positions may have changed
			if (r2 < h2)
			{
				float w = Poly6Kernel(r2, h2) * Poly6Coeff;
				float3 velDiff = neighbor.Velocity - vel;
				velocityCorrection += velDiff * w;
				weightSum += w;
			}
		}
	}
	else
	{
		//=====================================================================
		// Fallback: Hash-based neighbor search (when cache not available)
		//=====================================================================
		int3 centerCell = WorldToCell(pos, CellSize);
		int cellRadius = (int)ceil(SmoothingRadius / CellSize);

		if (cellRadius == 1)
		{
			// Unrolled 27-cell neighbor search (3x3x3 grid)
			// Layer z = -1
			PROCESS_VISCOSITY_CELL(-1, -1, -1)
			PROCESS_VISCOSITY_CELL( 0, -1, -1)
			PROCESS_VISCOSITY_CELL( 1, -1, -1)
			PROCESS_VISCOSITY_CELL(-1,  0, -1)
			PROCESS_VISCOSITY_CELL( 0,  0, -1)
			PROCESS_VISCOSITY_CELL( 1,  0, -1)
			PROCESS_VISCOSITY_CELL(-1,  1, -1)
			PROCESS_VISCOSITY_CELL( 0,  1, -1)
			PROCESS_VISCOSITY_CELL( 1,  1, -1)
			// Layer z = 0
			PROCESS_VISCOSITY_CELL(-1, -1,  0)
			PROCESS_VISCOSITY_CELL( 0, -1,  0)
			PROCESS_VISCOSITY_CELL( 1, -1,  0)
			PROCESS_VISCOSITY_CELL(-1,  0,  0)
			PROCESS_VISCOSITY_CELL( 0,  0,  0)  // Self cell
			PROCESS_VISCOSITY_CELL( 1,  0,  0)
			PROCESS_VISCOSITY_CELL(-1,  1,  0)
			PROCESS_VISCOSITY_CELL( 0,  1,  0)
			PROCESS_VISCOSITY_CELL( 1,  1,  0)
			// Layer z = 1
			PROCESS_VISCOSITY_CELL(-1, -1,  1)
			PROCESS_VISCOSITY_CELL( 0, -1,  1)
			PROCESS_VISCOSITY_CELL( 1, -1,  1)
			PROCESS_VISCOSITY_CELL(-1,  0,  1)
			PROCESS_VISCOSITY_CELL( 0,  0,  1)
			PROCESS_VISCOSITY_CELL( 1,  0,  1)
			PROCESS_VISCOSITY_CELL(-1,  1,  1)
			PROCESS_VISCOSITY_CELL( 0,  1,  1)
			PROCESS_VISCOSITY_CELL( 1,  1,  1)
		}
		else
		{
			// Fallback for cellRadius > 1
			for (int dz = -cellRadius; dz <= cellRadius; ++dz)
			{
				for (int dy = -cellRadius; dy <= cellRadius; ++dy)
				{
					for (int dx = -cellRadius; dx <= cellRadius; ++dx)
					{
						int3 neighborCell = centerCell + int3(dx, dy, dz);
						uint hash = HashCell(neighborCell);
						uint count = min(CellCounts[hash], (uint)MAX_PARTICLES_PER_CELL);
						uint startIdx = hash * MAX_PARTICLES_PER_CELL;

						for (uint i = 0; i < count; ++i)
						{
							uint neighborIdx = ParticleIndices[startIdx + i];

							// Skip self and invalid indices
							if (neighborIdx == idx || neighborIdx >= (uint)ParticleCount)
							{
								continue;
							}

							FGPUFluidParticle neighbor = Particles[neighborIdx];

							// Skip attached neighbors
							if (HasFlag(neighbor.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED))
							{
								continue;
							}

							float3 r_cm = pos - neighbor.PredictedPosition;
							float r2_cm = dot(r_cm, r_cm);
							float r2 = r2_cm * CM_TO_M_SQ;

							// Within smoothing radius?
							if (r2 < h2)
							{
								float w = Poly6Kernel(r2, h2) * Poly6Coeff;
								float3 velDiff = neighbor.Velocity - vel;
								velocityCorrection += velDiff * w;
								weightSum += w;
							}
						}
					}
				}
			}
		}
	}

	//=========================================================================
	// Boundary Particles viscosity contribution
	// Boundary particles are treated as stationary (velocity = 0)
	// This causes fluid to slow down near surfaces, creating "sticky" flow
	//=========================================================================
	if (bUseBoundaryViscosity && BoundaryParticleCount > 0)
	{
		for (int bi = 0; bi < BoundaryParticleCount; ++bi)
		{
			FGPUBoundaryParticle boundary = BoundaryParticles[bi];
			float3 r_cm = pos - boundary.Position;
			float r2_cm = dot(r_cm, r_cm);
			float r2 = r2_cm * CM_TO_M_SQ;

			if (r2 < h2 && r2 > SMALL_NUMBER)
			{
				float w = Poly6Kernel(r2, h2) * Poly6Coeff;
				// Boundary velocity is 0, so velDiff = -vel (slows down fluid)
				float3 velDiff = -vel;
				// Weight by Psi (boundary particle's volume contribution)
				velocityCorrection += velDiff * w * boundary.Psi;
				weightSum += w * boundary.Psi;
			}
		}
	}

	// Apply XSPH correction
	// v' = v + c * Î£(v_j - v_i) * W(r, h)
	if (weightSum > SMALL_NUMBER)
	{
		velocityCorrection /= weightSum;
		particle.Velocity += ViscosityCoefficient * velocityCorrection;
	}

	Particles[idx] = particle;
}
