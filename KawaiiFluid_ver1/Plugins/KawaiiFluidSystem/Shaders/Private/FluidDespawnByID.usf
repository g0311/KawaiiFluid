// Copyright KawaiiFluid Team. All Rights Reserved.
// ID-Based Despawn Shader - Marks particles for removal by ParticleID matching

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"

// ===================================================================================
// Struct Definitions (Must match C++)
// ===================================================================================

struct FGPUFluidParticle
{
	float3 Position;           // 12 bytes
	float Mass;                // 4 bytes (total: 16)
	float3 PredictedPosition;  // 12 bytes
	float Density;             // 4 bytes (total: 32)
	float3 Velocity;           // 12 bytes
	float Lambda;              // 4 bytes (total: 48)
	int ParticleID;            // 4 bytes
	int SourceID;              // 4 bytes
	uint Flags;                // 4 bytes
	uint NeighborCount;        // 4 bytes (total: 64)
};

// ===================================================================================
// Parameter Definitions
// ===================================================================================

// Input: Sorted array of particle IDs to despawn
StructuredBuffer<int> DespawnIDs;

// Input: Particle buffer to check
StructuredBuffer<FGPUFluidParticle> Particles;

// Output: Alive mask (1 = alive, 0 = dead)
RWStructuredBuffer<uint> OutAliveMask;

// Per-source particle count (decrement when particle is marked for removal)
RWStructuredBuffer<uint> SourceCounters;

// Parameters
int DespawnIDCount;
int ParticleCount;
int MaxSourceCount;

// ===================================================================================
// Binary Search Function
// Searches for targetID in sorted DespawnIDs array
// Returns true if found, false otherwise
// ===================================================================================
bool BinarySearchID(int targetID)
{
	int left = 0;
	int right = DespawnIDCount - 1;

	while (left <= right)
	{
		int mid = (left + right) >> 1;
		int midID = DespawnIDs[mid];

		if (midID == targetID)
		{
			return true;
		}
		else if (midID < targetID)
		{
			left = mid + 1;
		}
		else
		{
			right = mid - 1;
		}
	}

	return false;
}

// ===================================================================================
// Kernel: MarkDespawnByIDCS
// Marks particles for removal if their ParticleID is in the despawn list
// ===================================================================================
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void MarkDespawnByIDCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	const uint Index = DispatchThreadId.x;

	if (Index >= (uint)ParticleCount)
		return;

	// Get this particle's ID and SourceID
	const int ParticleID = Particles[Index].ParticleID;
	const int SourceID = Particles[Index].SourceID;

	// Check if this ID is in the despawn list using binary search
	bool bShouldRemove = BinarySearchID(ParticleID);

	// Write result (1 = Alive, 0 = Dead)
	OutAliveMask[Index] = bShouldRemove ? 0 : 1;

	// Decrement source counter if particle is being removed
	if (bShouldRemove && SourceID >= 0 && SourceID < MaxSourceCount)
	{
		InterlockedAdd(SourceCounters[SourceID], -1);
	}
}
