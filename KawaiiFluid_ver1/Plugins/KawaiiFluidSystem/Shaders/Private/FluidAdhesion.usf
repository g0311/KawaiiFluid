// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Fluid Physics - Adhesion Pass
// Handles particle attachment to bone colliders and position tracking

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"
#include "FluidCollisionPrimitives.ush"

//=============================================================================
// Shader Parameters
//=============================================================================

// Particle SOA buffers
RWBuffer<float> Positions;
RWBuffer<float> PredictedPositions;
RWBuffer<float> Velocities;
RWBuffer<uint> Flags;
int ParticleCount;
float ParticleRadius;

// Attachment buffer (one per particle)
RWStructuredBuffer<FGPUParticleAttachment> Attachments;

// Bone transforms
StructuredBuffer<FGPUBoneTransform> BoneTransforms;
int BoneCount;

// Collision primitives
StructuredBuffer<FGPUCollisionSphere> CollisionSpheres;
int SphereCount;

StructuredBuffer<FGPUCollisionCapsule> CollisionCapsules;
int CapsuleCount;

StructuredBuffer<FGPUCollisionBox> CollisionBoxes;
int BoxCount;

StructuredBuffer<FGPUCollisionConvex> CollisionConvexes;
int ConvexCount;

StructuredBuffer<FGPUConvexPlane> ConvexPlanes;

// Adhesion parameters
float AdhesionStrength;
float AdhesionRadius;
float DetachAccelThreshold;
float DetachDistanceThreshold;
float ColliderContactOffset;
float BoneVelocityScale;
float SlidingFriction;
float CurrentTime;
float DeltaTime;
int bEnableAdhesion;

// Gravity sliding parameters
float3 Gravity;
float GravitySlidingScale;  // How much gravity affects sliding (0-1)

// Primitive type constants
#define PRIM_TYPE_SPHERE 0
#define PRIM_TYPE_CAPSULE 1
#define PRIM_TYPE_BOX 2
#define PRIM_TYPE_CONVEX 3

//=============================================================================
// Helper Functions
//=============================================================================

// Find closest point on sphere surface
float3 GetClosestPointOnSphere(float3 pos, FGPUCollisionSphere sphere, out float3 normal, out float distance)
{
	float3 toPoint = pos - sphere.Center;
	float dist = length(toPoint);
	normal = dist > 0.0001f ? toPoint / dist : float3(0, 0, 1);
	distance = dist - sphere.Radius;
	return sphere.Center + normal * sphere.Radius;
}

// Find closest point on capsule surface
float3 GetClosestPointOnCapsule(float3 pos, FGPUCollisionCapsule capsule, out float3 normal, out float distance)
{
	float3 ab = capsule.End - capsule.Start;
	float t = saturate(dot(pos - capsule.Start, ab) / dot(ab, ab));
	float3 closestOnAxis = capsule.Start + t * ab;
	float3 toPoint = pos - closestOnAxis;
	float dist = length(toPoint);
	normal = dist > 0.0001f ? toPoint / dist : float3(0, 0, 1);
	distance = dist - capsule.Radius;
	return closestOnAxis + normal * capsule.Radius;
}

// Find closest point on box surface (approximate)
float3 GetClosestPointOnBox(float3 pos, FGPUCollisionBox box, out float3 normal, out float distance)
{
	// Transform to local space
	float3 localP = InverseRotateByQuat(pos - box.Center, box.Rotation);

	// Clamp to box surface
	float3 clamped = clamp(localP, -box.Extent, box.Extent);
	float3 localNormal = localP - clamped;
	float dist = length(localNormal);

	if (dist > 0.0001f)
	{
		localNormal /= dist;
	}
	else
	{
		// Inside box - find closest face
		float3 toFace = box.Extent - abs(localP);
		if (toFace.x < toFace.y && toFace.x < toFace.z)
			localNormal = float3(sign(localP.x), 0, 0);
		else if (toFace.y < toFace.z)
			localNormal = float3(0, sign(localP.y), 0);
		else
			localNormal = float3(0, 0, sign(localP.z));
		dist = -min(toFace.x, min(toFace.y, toFace.z));
	}

	// Transform back to world space
	normal = RotateByQuat(localNormal, box.Rotation);
	distance = dist;
	return box.Center + RotateByQuat(clamped, box.Rotation);
}

void GetConvexSurfaceInfo(
	float3 pos,
	FGPUCollisionConvex convex,
	StructuredBuffer<FGPUConvexPlane> planes,
	out float distance,
	out float3 normal,
	out float3 surfacePoint)
{
	float3 toCenter = pos - convex.Center;
	float centerLen = length(toCenter);
	float3 boundNormal = centerLen > 0.0001f ? toCenter / centerLen : float3(0, 0, 1);
	float boundDistance = centerLen - convex.BoundingRadius;

	float maxPlaneDistance = -1e10f;
	float3 planeNormal = boundNormal;

	if (convex.PlaneCount > 0)
	{
		const int planeStart = convex.PlaneStartIndex;
		for (int pi = 0; pi < convex.PlaneCount; ++pi)
		{
			FGPUConvexPlane plane = planes[planeStart + pi];
			float planeDistance = dot(pos, plane.Normal) - plane.Distance;
			if (planeDistance > maxPlaneDistance)
			{
				maxPlaneDistance = planeDistance;
				planeNormal = plane.Normal;
			}
		}

		bool bUseBound = boundDistance > maxPlaneDistance;
		distance = bUseBound ? boundDistance : maxPlaneDistance;
		normal = bUseBound ? boundNormal : planeNormal;
		surfacePoint = pos - normal * distance;
	}
	else
	{
		distance = boundDistance;
		normal = boundNormal;
		surfacePoint = convex.Center + normal * convex.BoundingRadius;
	}
}

// Calculate absolute distance between an arbitrary position and the attached primitive surface
float ComputeAttachmentSurfaceDistance(float3 pos, FGPUParticleAttachment attachment)
{
	if (attachment.PrimitiveIndex < 0)
	{
		return 0.0f;
	}

	if (attachment.PrimitiveType == PRIM_TYPE_SPHERE && attachment.PrimitiveIndex < SphereCount)
	{
		FGPUCollisionSphere sphere = CollisionSpheres[attachment.PrimitiveIndex];
		return abs(length(pos - sphere.Center) - sphere.Radius);
	}
	else if (attachment.PrimitiveType == PRIM_TYPE_CAPSULE && attachment.PrimitiveIndex < CapsuleCount)
	{
		FGPUCollisionCapsule capsule = CollisionCapsules[attachment.PrimitiveIndex];
		float3 ab = capsule.End - capsule.Start;
		float t = saturate(dot(pos - capsule.Start, ab) / dot(ab, ab));
		float3 closestOnAxis = capsule.Start + t * ab;
		return abs(length(pos - closestOnAxis) - capsule.Radius);
	}
	else if (attachment.PrimitiveType == PRIM_TYPE_BOX && attachment.PrimitiveIndex < BoxCount)
	{
		FGPUCollisionBox box = CollisionBoxes[attachment.PrimitiveIndex];
		return abs(sdBox(pos, box.Center, box.Extent, box.Rotation));
	}
	else if (attachment.PrimitiveType == PRIM_TYPE_CONVEX && attachment.PrimitiveIndex < ConvexCount)
	{
		FGPUCollisionConvex convex = CollisionConvexes[attachment.PrimitiveIndex];
		float signedDistance;
		float3 tmpNormal;
		float3 tmpPoint;
		GetConvexSurfaceInfo(pos, convex, ConvexPlanes, signedDistance, tmpNormal, tmpPoint);
		return abs(signedDistance);
	}

	return 0.0f;
}

//=============================================================================
// Adhesion Compute Shader - Check and create attachments
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void AdhesionCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)ParticleCount || bEnableAdhesion == 0)
	{
		return;
	}

	uint idx3 = idx * 3;
	uint flags = Flags[idx];
	FGPUParticleAttachment attachment = Attachments[idx];
	const float EffectiveAdhesionRadius = max(0.0f, AdhesionRadius + ColliderContactOffset);

	float3 pos = float3(Positions[idx3], Positions[idx3 + 1], Positions[idx3 + 2]);

	// If already attached, skip adhesion check (handled by UpdateAttachedPositions)
	if (attachment.PrimitiveType >= 0)
	{
		return;
	}

	// Skip if just detached this frame
	if (HasFlag(flags, GPU_PARTICLE_FLAG_JUST_DETACHED))
	{
		return;
	}

	// Find closest primitive for potential attachment
	float closestDist = EffectiveAdhesionRadius;
	int closestPrimType = -1;
	int closestPrimIndex = -1;
	int closestBoneIndex = -1;
	float3 closestPoint = float3(0, 0, 0);
	float3 closestNormal = float3(0, 0, 1);

	// Check spheres
	for (int si = 0; si < SphereCount; ++si)
	{
		FGPUCollisionSphere sphere = CollisionSpheres[si];
		if (sphere.BoneIndex < 0) continue;  // Skip primitives without bone tracking

		float3 normal;
		float distance;
		float3 surfacePoint = GetClosestPointOnSphere(pos, sphere, normal, distance);

		if (distance < closestDist && distance < EffectiveAdhesionRadius)
		{
			closestDist = distance;
			closestPrimType = PRIM_TYPE_SPHERE;
			closestPrimIndex = si;
			closestBoneIndex = sphere.BoneIndex;
			closestPoint = surfacePoint;
			closestNormal = normal;
		}
	}

	// Check capsules
	for (int ci = 0; ci < CapsuleCount; ++ci)
	{
		FGPUCollisionCapsule capsule = CollisionCapsules[ci];
		if (capsule.BoneIndex < 0) continue;

		float3 normal;
		float distance;
		float3 surfacePoint = GetClosestPointOnCapsule(pos, capsule, normal, distance);

		if (distance < closestDist && distance < EffectiveAdhesionRadius)
		{
			closestDist = distance;
			closestPrimType = PRIM_TYPE_CAPSULE;
			closestPrimIndex = ci;
			closestBoneIndex = capsule.BoneIndex;
			closestPoint = surfacePoint;
			closestNormal = normal;
		}
	}

	// Check boxes
	for (int bi = 0; bi < BoxCount; ++bi)
	{
		FGPUCollisionBox box = CollisionBoxes[bi];
		if (box.BoneIndex < 0) continue;

		float3 normal;
		float distance;
		float3 surfacePoint = GetClosestPointOnBox(pos, box, normal, distance);

		if (distance < closestDist && distance < EffectiveAdhesionRadius)
		{
			closestDist = distance;
			closestPrimType = PRIM_TYPE_BOX;
			closestPrimIndex = bi;
			closestBoneIndex = box.BoneIndex;
			closestPoint = surfacePoint;
			closestNormal = normal;
		}
	}

	// Check convexes
	for (int cxi = 0; cxi < ConvexCount; ++cxi)
	{
		FGPUCollisionConvex convex = CollisionConvexes[cxi];
		if (convex.BoneIndex < 0) continue;

		float distance;
		float3 surfaceNormal;
		float3 surfacePoint;
		GetConvexSurfaceInfo(pos, convex, ConvexPlanes, distance, surfaceNormal, surfacePoint);

		if (distance < closestDist && distance < EffectiveAdhesionRadius)
		{
			closestDist = distance;
			closestPrimType = PRIM_TYPE_CONVEX;
			closestPrimIndex = cxi;
			closestBoneIndex = convex.BoneIndex;
			closestPoint = surfacePoint;
			closestNormal = surfaceNormal;
		}
	}

	// Create attachment if close enough
	if (closestPrimType >= 0 && closestBoneIndex >= 0 && closestBoneIndex < BoneCount)
	{
		FGPUBoneTransform bone = BoneTransforms[closestBoneIndex];

		// Store attachment info
		attachment.PrimitiveType = closestPrimType;
		attachment.PrimitiveIndex = closestPrimIndex;
		attachment.BoneIndex = closestBoneIndex;
		attachment.AdhesionStrength = AdhesionStrength;
		attachment.LocalOffset = WorldToBoneLocal(pos, bone);
		attachment.AttachmentTime = CurrentTime;
		attachment.RelativeVelocity = float3(0, 0, 0);  // No relative velocity on attach

		// Set attached flag
		flags = SetFlag(flags, GPU_PARTICLE_FLAG_IS_ATTACHED);

		Flags[idx] = flags;
		Attachments[idx] = attachment;
	}
}

//=============================================================================
// Update Attached Positions Compute Shader
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void UpdateAttachedPositionsCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)ParticleCount)
	{
		return;
	}

	FGPUParticleAttachment attachment = Attachments[idx];
	const float EffectiveDetachThreshold = max(0.0f, DetachDistanceThreshold + ColliderContactOffset);

	// Skip non-attached particles
	if (attachment.PrimitiveType < 0 || attachment.BoneIndex < 0 || attachment.BoneIndex >= BoneCount)
	{
		return;
	}

	uint idx3 = idx * 3;
	float3 position = float3(Positions[idx3], Positions[idx3 + 1], Positions[idx3 + 2]);
	float3 predictedPosition = float3(PredictedPositions[idx3], PredictedPositions[idx3 + 1], PredictedPositions[idx3 + 2]);
	float3 velocity = float3(Velocities[idx3], Velocities[idx3 + 1], Velocities[idx3 + 2]);
	uint flags = Flags[idx];
	FGPUBoneTransform bone = BoneTransforms[attachment.BoneIndex];
	float3 previousVelocity = velocity;

	// Desired bone-follow position and inferred speed
	float3 desiredPos = BoneLocalToWorld(attachment.LocalOffset, bone);
	float3 followDelta = desiredPos - predictedPosition;
	const float DesiredSpeed = length(followDelta) / max(DeltaTime, 0.0001f);

	// AdhesionStrength affects detach thresholds (0~1 ratio)
	// 0 = normal detach behavior
	// 1 = never detach
	// Formula: EffectiveThreshold = BaseThreshold / (1.0 - AdhesionStrength)
	const float ClampedStrength = saturate(attachment.AdhesionStrength);  // Clamp to 0~1
	bool bShouldDetach = false;

	if (ClampedStrength >= 0.999f)
	{
		// AdhesionStrength = 1 → never detach
		bShouldDetach = false;
	}
	else
	{
		// 0~0.999: progressively harder to detach
		const float StrengthMultiplier = 1.0f / (1.0f - ClampedStrength);
		const float EffectiveAccelThreshold = DetachAccelThreshold * StrengthMultiplier;
		const float EffectiveDistThreshold = EffectiveDetachThreshold * StrengthMultiplier;

		// Detach if the required follow speed exceeds threshold
		if (DesiredSpeed > EffectiveAccelThreshold)
		{
			bShouldDetach = true;
		}

		// Additional safety: detach if we drift too far from the surface
		float predictedSurfaceDistance = ComputeAttachmentSurfaceDistance(predictedPosition, attachment);
		if (predictedSurfaceDistance > EffectiveDistThreshold)
		{
			bShouldDetach = true;
		}

		float surfaceDistance = ComputeAttachmentSurfaceDistance(desiredPos, attachment);
		if (surfaceDistance > EffectiveDistThreshold)
		{
			bShouldDetach = true;
		}
	}

	// Calculate bone velocity for later velocity blending / sliding
	float3 boneVelocity = CalcBoneVelocity(attachment.LocalOffset, bone, DeltaTime);

	if (bShouldDetach)
	{
		// Detach: clear attachment, give particle bone velocity
		attachment.PrimitiveType = -1;
		attachment.PrimitiveIndex = -1;
		attachment.BoneIndex = -1;
		attachment.AdhesionStrength = 0;
		attachment.LocalOffset = float3(0, 0, 0);
		attachment.RelativeVelocity = float3(0, 0, 0);  // Reset relative velocity

		flags = ClearFlag(flags, GPU_PARTICLE_FLAG_IS_ATTACHED);
		flags = SetFlag(flags, GPU_PARTICLE_FLAG_JUST_DETACHED);

		// Clamp and dampen velocity on detach to prevent particles flying too far
		const float MaxDetachVelocity = 500.0f;  // cm/s (5 m/s max)
		const float DetachVelocityDamping = 0.3f; // 30% of bone velocity
		float3 clampedVelocity = boneVelocity * DetachVelocityDamping;
		float velMag = length(clampedVelocity);
		if (velMag > MaxDetachVelocity)
		{
			clampedVelocity = clampedVelocity * (MaxDetachVelocity / velMag);
		}
		float3 desiredVelocity = clampedVelocity;
		velocity = lerp(previousVelocity, desiredVelocity, saturate(BoneVelocityScale));
	}
	else
	{
		// === Gravity-based surface sliding ===
		// Calculate surface normal at current position
		float3 surfaceNormal = float3(0, 0, 1);
		float3 surfacePoint = desiredPos;

		if (attachment.PrimitiveType == PRIM_TYPE_SPHERE && attachment.PrimitiveIndex < SphereCount)
		{
			FGPUCollisionSphere sphere = CollisionSpheres[attachment.PrimitiveIndex];
			float3 toParticle = desiredPos - sphere.Center;
			float dist = length(toParticle);
			surfaceNormal = dist > 0.0001f ? toParticle / dist : float3(0, 0, 1);
			surfacePoint = sphere.Center + surfaceNormal * sphere.Radius;
		}
		else if (attachment.PrimitiveType == PRIM_TYPE_CAPSULE && attachment.PrimitiveIndex < CapsuleCount)
		{
			FGPUCollisionCapsule capsule = CollisionCapsules[attachment.PrimitiveIndex];
			float3 ab = capsule.End - capsule.Start;
			float t = saturate(dot(desiredPos - capsule.Start, ab) / dot(ab, ab));
			float3 closestOnAxis = capsule.Start + t * ab;
			float3 toParticle = desiredPos - closestOnAxis;
			float dist = length(toParticle);
			surfaceNormal = dist > 0.0001f ? toParticle / dist : float3(0, 0, 1);
			surfacePoint = closestOnAxis + surfaceNormal * capsule.Radius;
		}
		else if (attachment.PrimitiveType == PRIM_TYPE_BOX && attachment.PrimitiveIndex < BoxCount)
		{
			FGPUCollisionBox box = CollisionBoxes[attachment.PrimitiveIndex];
			float dummy;
			surfacePoint = GetClosestPointOnBox(desiredPos, box, surfaceNormal, dummy);
		}
		else if (attachment.PrimitiveType == PRIM_TYPE_CONVEX && attachment.PrimitiveIndex < ConvexCount)
		{
			FGPUCollisionConvex convex = CollisionConvexes[attachment.PrimitiveIndex];
			float signedDistance;
			GetConvexSurfaceInfo(desiredPos, convex, ConvexPlanes, signedDistance, surfaceNormal, surfacePoint);
		}

		// Calculate tangential gravity component (gravity projected onto surface)
		// tangentGravity = gravity - (gravity · normal) * normal
		float gravityNormalComponent = dot(Gravity, surfaceNormal);
		float3 tangentGravity = Gravity - gravityNormalComponent * surfaceNormal;

		// Apply sliding only if gravity has tangential component (surface is not horizontal)
		float tangentMagnitude = length(tangentGravity);
		if (tangentMagnitude > 0.1f && GravitySlidingScale > 0.0f)
		{
			// Calculate sliding velocity with friction
			// slidingAccel = tangentGravity * (1 - friction)
			float effectiveFriction = saturate(SlidingFriction);
			float3 slidingAccel = tangentGravity * (1.0f - effectiveFriction) * GravitySlidingScale;

			// Apply sliding displacement in world space
			float3 slidingDisplacement = slidingAccel * DeltaTime * DeltaTime * 0.5f;

			// Convert displacement to bone local space and update LocalOffset
			float3 newWorldPos = desiredPos + slidingDisplacement;

			// Re-project onto surface to prevent drifting away
			float3 toNewPos = newWorldPos - surfacePoint;
			float distToSurface = dot(toNewPos, surfaceNormal);
			newWorldPos = newWorldPos - distToSurface * surfaceNormal;

			// Update local offset for next frame
			attachment.LocalOffset = WorldToBoneLocal(newWorldPos, bone);

			// Update particle position
			position = newWorldPos;
			predictedPosition = newWorldPos;
			float3 desiredVelocity = boneVelocity + slidingAccel * DeltaTime;
			velocity = lerp(previousVelocity, desiredVelocity, saturate(BoneVelocityScale));
		}
		else
		{
			// No sliding - just follow bone
			position = desiredPos;
			predictedPosition = desiredPos;
			float3 desiredVelocity = boneVelocity;
			velocity = lerp(previousVelocity, desiredVelocity, saturate(BoneVelocityScale));
		}

		// Store relative velocity for anisotropy (particle velocity - bone velocity)
		// This ensures anisotropy only reflects movement ON the surface, not with the bone
		attachment.RelativeVelocity = velocity - boneVelocity;
	}

	// Write back to SoA buffers
	Positions[idx3] = position.x;
	Positions[idx3 + 1] = position.y;
	Positions[idx3 + 2] = position.z;
	PredictedPositions[idx3] = predictedPosition.x;
	PredictedPositions[idx3 + 1] = predictedPosition.y;
	PredictedPositions[idx3 + 2] = predictedPosition.z;
	Velocities[idx3] = velocity.x;
	Velocities[idx3 + 1] = velocity.y;
	Velocities[idx3 + 2] = velocity.z;
	Flags[idx] = flags;
	Attachments[idx] = attachment;
}

//=============================================================================
// Clear Just Detached Flag (run at end of frame)
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ClearDetachedFlagCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)ParticleCount)
	{
		return;
	}

	uint flags = Flags[idx];
	flags = ClearFlag(flags, GPU_PARTICLE_FLAG_JUST_DETACHED);
	Flags[idx] = flags;
}
