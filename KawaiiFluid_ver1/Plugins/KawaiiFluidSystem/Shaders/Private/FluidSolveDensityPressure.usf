// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Fluid Physics - Combined Density and Pressure Pass
// Merges ComputeDensity and SolvePressure into single neighbor traversal
//
// Optimizations:
// 1. Pass Integration: Reduces neighbor search from 2x to 1x per iteration
// 2. rsqrt: Uses fast inverse square root instead of sqrt
// 3. Loop Unroll: Explicit 27-cell unrolling for cellRadius=1 case

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"
#include "FluidSpatialHash.ush"

//=============================================================================
// Shader Parameters
//=============================================================================

RWStructuredBuffer<FGPUFluidParticle> Particles;
StructuredBuffer<uint> CellCounts;
StructuredBuffer<uint> ParticleIndices;

int ParticleCount;
float SmoothingRadius;
float RestDensity;
float Poly6Coeff;
float SpikyCoeff;
float CellSize;
float Compliance;
float DeltaTimeSq;

// Tensile Instability Correction (PBF paper Eq.13-14)
int bEnableTensileInstability;
float TensileK;
int TensileN;
float InvW_DeltaQ;

//=============================================================================
// Unrolled 27-Cell Neighbor Processing Macro
// Processes a single cell offset and accumulates density/pressure
//=============================================================================
#define PROCESS_CELL(DX, DY, DZ) \
{ \
	int3 neighborCell = centerCell + int3(DX, DY, DZ); \
	uint hash = HashCell(neighborCell); \
	uint count = min(CellCounts[hash], (uint)MAX_PARTICLES_PER_CELL); \
	uint startIdx = hash * MAX_PARTICLES_PER_CELL; \
	for (uint i = 0; i < count; ++i) \
	{ \
		uint neighborIdx = ParticleIndices[startIdx + i]; \
		if (neighborIdx >= (uint)ParticleCount) continue; \
		FGPUFluidParticle neighbor = Particles[neighborIdx]; \
		float3 neighborPos = neighbor.PredictedPosition; \
		float3 r_cm = pos - neighborPos; \
		float r2_cm = dot(r_cm, r_cm); \
		float r2 = r2_cm * CM_TO_M_SQ; \
		if (r2 < h2) \
		{ \
			float mass = neighbor.Mass; \
			float w = Poly6Kernel(r2, h2); \
			density += mass * Poly6Coeff * w; \
			if (neighborIdx != idx) neighborCount++; \
			float3 r = r_cm * CM_TO_M; \
			float3 gradW = SpikyGradientFast(r, r2, h, h2); \
			gradW *= SpikyCoeff * CM_TO_M; \
			float3 gradC_j = -gradW / RestDensity; \
			sumGradC2 += dot(gradC_j, gradC_j); \
			gradC_i += gradW / RestDensity; \
			if (neighborIdx != idx && r2 >= SMALL_NUMBER) \
			{ \
				float lambda_j_prev = neighbor.Lambda; \
				float scorr = 0.0f; \
				if (bEnableTensileInstability) \
				{ \
					float diff = h2 - r2; \
					float W_r = diff * diff * diff; \
					float deltaQ2 = 0.04f * h2; \
					float diffQ = h2 - deltaQ2; \
					float W_deltaQ = diffQ * diffQ * diffQ; \
					float ratio = (W_deltaQ > 0.0f) ? saturate(W_r / W_deltaQ) : 0.0f; \
					float ratio2 = ratio * ratio; \
					float ratioN = ratio2 * ratio2; \
					if (TensileN == 2) ratioN = ratio2; \
					else if (TensileN == 6) ratioN = ratio2 * ratio2 * ratio2; \
					scorr = -TensileK * ratioN; \
				} \
				deltaP += (lambda_i_prev + lambda_j_prev + scorr) * gradW; \
			} \
		} \
	} \
}

//=============================================================================
// Main Compute Shader - Combined Density + Pressure
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void SolveDensityPressureCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)ParticleCount)
	{
		return;
	}

	FGPUFluidParticle particle = Particles[idx];

	// Skip attached particles
	if (HasFlag(particle.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED))
	{
		particle.Density = RestDensity;
		particle.Lambda = 0.0f;
		Particles[idx] = particle;
		return;
	}

	float3 pos = particle.PredictedPosition;

	// Previous iteration's Lambda (for Jacobi-style update)
	float lambda_i_prev = particle.Lambda;

	// Convert smoothing radius from cm to m for kernel calculations
	float h = SmoothingRadius * CM_TO_M;
	float h2 = h * h;

	// Accumulators
	float density = 0.0f;
	float3 gradC_i = float3(0.0f, 0.0f, 0.0f);
	float sumGradC2 = 0.0f;
	float3 deltaP = float3(0.0f, 0.0f, 0.0f);
	uint neighborCount = 0;

	// Get cell coordinate for this particle
	int3 centerCell = WorldToCell(pos, CellSize);
	int cellRadius = (int)ceil(SmoothingRadius / CellSize);

	//=========================================================================
	// Optimized neighbor traversal with loop unrolling
	// Most common case: cellRadius == 1 (27 cells) - use unrolled version
	// Fallback: cellRadius > 1 - use dynamic loop with rsqrt optimization
	//=========================================================================

	if (cellRadius == 1)
	{
		// Unrolled 27-cell neighbor search (3x3x3 grid)
		// Eliminates loop overhead and enables better instruction scheduling
		// Layer z = -1
		PROCESS_CELL(-1, -1, -1)
		PROCESS_CELL( 0, -1, -1)
		PROCESS_CELL( 1, -1, -1)
		PROCESS_CELL(-1,  0, -1)
		PROCESS_CELL( 0,  0, -1)
		PROCESS_CELL( 1,  0, -1)
		PROCESS_CELL(-1,  1, -1)
		PROCESS_CELL( 0,  1, -1)
		PROCESS_CELL( 1,  1, -1)
		// Layer z = 0
		PROCESS_CELL(-1, -1,  0)
		PROCESS_CELL( 0, -1,  0)
		PROCESS_CELL( 1, -1,  0)
		PROCESS_CELL(-1,  0,  0)
		PROCESS_CELL( 0,  0,  0)  // Self cell
		PROCESS_CELL( 1,  0,  0)
		PROCESS_CELL(-1,  1,  0)
		PROCESS_CELL( 0,  1,  0)
		PROCESS_CELL( 1,  1,  0)
		// Layer z = 1
		PROCESS_CELL(-1, -1,  1)
		PROCESS_CELL( 0, -1,  1)
		PROCESS_CELL( 1, -1,  1)
		PROCESS_CELL(-1,  0,  1)
		PROCESS_CELL( 0,  0,  1)
		PROCESS_CELL( 1,  0,  1)
		PROCESS_CELL(-1,  1,  1)
		PROCESS_CELL( 0,  1,  1)
		PROCESS_CELL( 1,  1,  1)
	}
	else
	{
		// Fallback for cellRadius > 1 (still using rsqrt optimization)
		for (int dz = -cellRadius; dz <= cellRadius; ++dz)
		{
			for (int dy = -cellRadius; dy <= cellRadius; ++dy)
			{
				for (int dx = -cellRadius; dx <= cellRadius; ++dx)
				{
					int3 neighborCell = centerCell + int3(dx, dy, dz);
					uint hash = HashCell(neighborCell);
					uint count = min(CellCounts[hash], (uint)MAX_PARTICLES_PER_CELL);
					uint startIdx = hash * MAX_PARTICLES_PER_CELL;

					for (uint i = 0; i < count; ++i)
					{
						uint neighborIdx = ParticleIndices[startIdx + i];
						if (neighborIdx >= (uint)ParticleCount)
						{
							continue;
						}

						FGPUFluidParticle neighbor = Particles[neighborIdx];
						float3 neighborPos = neighbor.PredictedPosition;
						float3 r_cm = pos - neighborPos;
						float r2_cm = dot(r_cm, r_cm);
						float r2 = r2_cm * CM_TO_M_SQ;

						// Within smoothing radius?
						if (r2 < h2)
						{
							float mass = neighbor.Mass;

							//=========================================
							// PART 1: Density Calculation
							//=========================================
							float w = Poly6Kernel(r2, h2);
							density += mass * Poly6Coeff * w;

							// Count neighbors (excluding self)
							if (neighborIdx != idx)
							{
								neighborCount++;
							}

							// Gradient calculation using rsqrt optimization
							float3 r = r_cm * CM_TO_M;
							float3 gradW = SpikyGradientFast(r, r2, h, h2);
							gradW *= SpikyCoeff * CM_TO_M;

							float3 gradC_j = -gradW / RestDensity;
							sumGradC2 += dot(gradC_j, gradC_j);
							gradC_i += gradW / RestDensity;

							//=========================================
							// PART 2: Pressure Correction (skip self)
							// Uses PREVIOUS iteration's Lambda (Jacobi-style)
							//=========================================
							if (neighborIdx != idx && r2 >= SMALL_NUMBER)
							{
								float lambda_j_prev = neighbor.Lambda;

								// Tensile Instability Correction
								float scorr = 0.0f;
								if (bEnableTensileInstability)
								{
									float diff = h2 - r2;
									float W_r = diff * diff * diff;
									float deltaQ2 = 0.04f * h2;
									float diffQ = h2 - deltaQ2;
									float W_deltaQ = diffQ * diffQ * diffQ;
									float ratio = (W_deltaQ > 0.0f) ? saturate(W_r / W_deltaQ) : 0.0f;

									// Optimized power calculation
									float ratio2 = ratio * ratio;
									float ratioN = ratio2 * ratio2;  // Default N=4
									if (TensileN == 2)
									{
										ratioN = ratio2;
									}
									else if (TensileN == 6)
									{
										ratioN = ratio2 * ratio2 * ratio2;
									}
									scorr = -TensileK * ratioN;
								}

								// Position correction using previous Lambda
								deltaP += (lambda_i_prev + lambda_j_prev + scorr) * gradW;
							}
						}
					}
				}
			}
		}
	}

	// Self contribution to gradient sum
	sumGradC2 += dot(gradC_i, gradC_i);

	// Store density and neighbor count
	particle.Density = density;
	particle.NeighborCount = neighborCount;

	//=========================================
	// Calculate NEW Lambda (XPBD formulation)
	//=========================================
	float C = (density / RestDensity) - 1.0f;
	float alphaTilde = Compliance / max(DeltaTimeSq, 0.00001f);

	if (C > 0.0f)
	{
		float deltaLambda = (-C - alphaTilde * lambda_i_prev) / (sumGradC2 + alphaTilde);
		particle.Lambda = lambda_i_prev + deltaLambda;
	}
	// If C <= 0, keep previous Lambda

	//=========================================
	// Apply position correction
	//=========================================
	float3 deltaP_cm = deltaP / RestDensity;
	particle.PredictedPosition += deltaP_cm;

	Particles[idx] = particle;
}
