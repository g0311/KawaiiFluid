// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Fluid Physics - Combined Density and Pressure Pass
// Merges ComputeDensity and SolvePressure into single neighbor traversal
//
// Optimizations:
// 1. Pass Integration: Reduces neighbor search from 2x to 1x per iteration
// 2. rsqrt: Uses fast inverse square root instead of sqrt
// 3. Loop Unroll: Explicit 27-cell unrolling for cellRadius=1 case
// 4. Neighbor Caching: First iteration builds neighbor list, subsequent iterations reuse

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"
#include "FluidSpatialHash.ush"
#include "FluidMortonUtils.ush"  // Unified Morton code functions

//=============================================================================
// Shader Parameters
//=============================================================================

// SoA (Structure of Arrays) Particle Buffers
RWBuffer<float> Positions;                     // [ParticleCount * 3] float3 as 3 consecutive floats
RWBuffer<float> PredictedPositions;            // [ParticleCount * 3] float3 as 3 consecutive floats
RWBuffer<float> Velocities;                    // [ParticleCount * 3] float3 as 3 consecutive floats
RWBuffer<float> Masses;                        // [ParticleCount] float
RWBuffer<float> Densities;                     // [ParticleCount] float
RWBuffer<float> Lambdas;                       // [ParticleCount] float
RWBuffer<uint> Flags;                          // [ParticleCount] uint
RWBuffer<uint> NeighborCountsBuffer;           // [ParticleCount] uint (renamed to avoid collision with local variable)

// Hash table mode (legacy)
StructuredBuffer<uint> CellCounts;
StructuredBuffer<uint> ParticleIndices;

// Z-Order sorted mode (new)
StructuredBuffer<uint> CellStart;   // CellStart[cellID] = first particle index
StructuredBuffer<uint> CellEnd;     // CellEnd[cellID] = last particle index
int bUseZOrderSorting;              // 1 = use CellStart/End, 0 = use CellCounts/ParticleIndices

// Neighbor caching buffers
RWStructuredBuffer<uint> NeighborList;    // [ParticleCount * MAX_NEIGHBORS_PER_PARTICLE]
RWStructuredBuffer<uint> NeighborCounts;  // [ParticleCount]

int ParticleCount;
float SmoothingRadius;
float RestDensity;
float Poly6Coeff;
float SpikyCoeff;
float CellSize;
float Compliance;
float DeltaTimeSq;

// Cohesion via Artificial Pressure (PBF paper Eq.13-14)
// TensileK = Cohesion coefficient (scaled 100x from user-facing value)
//            User sets Cohesion=0.1 in editor → TensileK=10 here
// TensileN = CohesionExponent from Physics|Simulation|Cohesion (n value)
// InvW_DeltaQ = precomputed from CohesionDeltaQ (Δq value)
int bEnableTensileInstability;  // 1 if Cohesion > 0
float TensileK;                 // Scaled cohesion (Cohesion * 100, e.g., 5~20)
int TensileN;                   // Cohesion exponent (n = 1~8, typically 4)
float InvW_DeltaQ;              // 1/W(Δq*h), precomputed on CPU

// Iteration control
int IterationIndex;

// Z-Order (Morton Code) bounds for cell ID calculation
// Must match the bounds used in FluidMortonCode.usf
float3 MortonBoundsMin;     // Simulation bounds minimum
float3 MortonBoundsExtent;  // Simulation bounds extent (Max - Min)

// Hybrid Tiled Z-Order mode flag
// When enabled, uses 21-bit Hybrid keys (3-bit TileHash + 18-bit LocalMorton)
// for unlimited simulation range. Must match FluidMortonCode.usf
int bUseHybridTiledZOrder;

//=============================================================================
// Boundary Particles for density contribution (Akinci 2012)
//=============================================================================
struct FGPUBoundaryParticle
{
	float3 Position;      // 12 bytes - World position
	float Psi;            // 4 bytes  - Boundary particle "mass" (total: 16)
	float3 Normal;        // 12 bytes - Surface normal
	int OwnerID;          // 4 bytes  - Owner component ID (total: 32)
	float3 Velocity;      // 12 bytes - World velocity
	float FrictionCoeff;  // 4 bytes  - Coulomb friction coefficient (total: 48)
	int BoneIndex;        // 4 bytes  - Skeleton bone index (-1 for static mesh)
	float3 Padding;       // 12 bytes - Alignment padding (total: 64)
};

StructuredBuffer<FGPUBoundaryParticle> BoundaryParticles;
int BoundaryParticleCount;
int bUseBoundaryDensity;

// Z-Order sorted boundary particles (Akinci 2012 + Z-Order optimization)
StructuredBuffer<FGPUBoundaryParticle> SortedBoundaryParticles;
StructuredBuffer<uint> BoundaryCellStart;
StructuredBuffer<uint> BoundaryCellEnd;
int bUseBoundaryZOrder;

// Relative Velocity Pressure Damping (prevents fluid flying away from fast boundaries)
int bEnableRelativeVelocityDamping;
float RelativeVelocityDampingStrength;

// Boundary Velocity Transfer (moved from FluidApplyViscosity for optimization)
// Fluid following moving boundaries - applied during boundary density loop
int bEnableBoundaryVelocityTransfer;
float BoundaryVelocityTransferStrength;
float BoundaryDetachSpeedThreshold;
float BoundaryMaxDetachSpeed;
float BoundaryAdhesionStrength;  // Clamped adhesion (0~1)
int SolverIterationCount;        // Total iterations for strength scaling

// Position-Based Surface Tension (NVIDIA Flex style)
// Creates rounded droplets by minimizing surface area
// bEnablePositionBasedSurfaceTension: 0 = Akinci force-based (default), 1 = Position-Based (experimental)
int bEnablePositionBasedSurfaceTension;
float SurfaceTensionStrength;
float SurfaceTensionActivationDistance;   // cm (h * ratio)
float SurfaceTensionFalloffDistance;      // cm (h * ratio)
int SurfaceTensionSurfaceThreshold;       // Surface particles get stronger ST
float SurfaceTensionVelocityDamping;      // 0~1, under-relaxation (0=full correction, 1=no correction)
float SurfaceTensionTolerance;            // cm, dead zone around activation distance (prevents oscillation)

// Fluid Cohesion (NVIDIA FleX style) - stringy, honey-like effects
// Uses quadratic distance scaling for resistance to separation
// Separate from TensileK (Artificial Pressure) which handles tensile instability
//   0 = no cohesion (particles separate freely)
//   0.5~1.0 = sticky, stringy (honey-like)
float CohesionStrength;
float CohesionActivationDistance;         // cm (h * ratio), smaller = stringier
float CohesionFalloffDistance;            // cm (h * ratio), higher = longer strings
int CohesionExponent;                     // 1=linear, 2=quadratic (stringy), 3=cubic

// Surface Tension max correction
float MaxSurfaceTensionCorrection;        // Max correction per iteration (cm)

//=============================================================================
// Z-Order Cell ID Calculation (uses shader parameters)
// Morton code functions are provided by FluidMortonUtils.ush
//=============================================================================

// Compute Morton-based cell ID from cell coordinates (integer)
// This version uses shader parameters (MortonBoundsMin, CellSize) directly.
// IMPORTANT: Must match FluidMortonCode.usf's ComputeMortonCodesCellBasedCS
// IMPORTANT: Result is truncated to fit CellStart/CellEnd buffer size (MAX_CELLS)
uint GetMortonCellIDFromCellCoord(int3 cellCoord)
{
	// Hybrid mode: 21-bit key (3-bit TileHash + 18-bit LocalMorton)
	if (bUseHybridTiledZOrder)
	{
		// ComputeHybridTiledKey returns 21-bit key matching MAX_CELLS
		// Mask is a no-op but kept for consistency
		// Hash collisions (8 tile buckets) are filtered by distance check
		return ComputeHybridTiledKey(cellCoord) & (MAX_CELLS - 1);
	}

	// Classic mode: Use bounded Morton code
	// Compute grid minimum cell (same as in FluidMortonCode.usf)
	int3 gridMin = int3(floor(MortonBoundsMin / CellSize));

	// Offset cell coordinates to make them positive (relative to grid min)
	int3 offset = cellCoord - gridMin;

	// Clamp to valid range for current preset
	uint3 uoffset = uint3(max(offset, int3(0, 0, 0)));
	uoffset = min(uoffset, uint3(MORTON_MAX_VALUE, MORTON_MAX_VALUE, MORTON_MAX_VALUE));

	// Compute Morton code using preset-specific function from FluidMortonUtils.ush
	return Morton3D(uoffset.x, uoffset.y, uoffset.z);
}

//=============================================================================
// Z-Order Mode: Build Neighbor List using CellStart/End (Sequential Access)
// Particles are sorted by Morton code, so sequential access = cache coherent
// IMPORTANT: Cell ID must use Morton code (same as FluidCellStartEnd.usf)
//=============================================================================
#define BUILD_AND_PROCESS_CELL_ZORDER(DX, DY, DZ) \
{ \
	int3 neighborCell = centerCell + int3(DX, DY, DZ); \
	uint cellID = GetMortonCellIDFromCellCoord(neighborCell); \
	uint cellStart = CellStart[cellID]; \
	uint cellEnd = CellEnd[cellID]; \
	if (cellStart != INVALID_INDEX && cellEnd != INVALID_INDEX) \
	{ \
		uint maxNeighborIdx = min(cellEnd, (uint)(ParticleCount - 1)); \
		for (uint neighborIdx = cellStart; neighborIdx <= maxNeighborIdx; ++neighborIdx) \
		{ \
			uint neighborIdx3 = neighborIdx * 3; \
			uint neighborFlags = Flags[neighborIdx]; \
			if (HasFlag(neighborFlags, GPU_PARTICLE_FLAG_IS_ATTACHED)) continue; \
			float3 neighborPos = float3(PredictedPositions[neighborIdx3], PredictedPositions[neighborIdx3 + 1], PredictedPositions[neighborIdx3 + 2]); \
			float3 r_cm = pos - neighborPos; \
			float r2_cm = dot(r_cm, r_cm); \
			float r2 = r2_cm * CM_TO_M_SQ; \
			if (r2 < h2) \
			{ \
				if (cachedCount < MAX_NEIGHBORS_PER_PARTICLE) \
				{ \
					uint cacheIdx = idx * MAX_NEIGHBORS_PER_PARTICLE + cachedCount; \
					NeighborList[cacheIdx] = neighborIdx; \
					cachedCount++; \
				} \
				float mass = Masses[neighborIdx]; \
				float w = Poly6Kernel(r2, h2); \
				density += mass * Poly6Coeff * w; \
				if (neighborIdx != idx) neighborCount++; \
				float3 r = r_cm * CM_TO_M; \
				float3 gradW = SpikyGradientFast(r, r2, h, h2); \
				gradW *= SpikyCoeff * CM_TO_M; \
				float3 gradC_j = -gradW * invRestDensity; \
				sumGradC2 += dot(gradC_j, gradC_j); \
				gradC_i += gradW * invRestDensity; \
				if (neighborIdx != idx && r2 >= SMALL_NUMBER) \
				{ \
					float lambda_j_prev = Lambdas[neighborIdx]; \
					float diff = h2 - r2; \
					float W_r = diff * diff * diff; \
					float ratio = W_r * InvW_DeltaQ; \
					float ratio2 = ratio * ratio; \
					float ratioN = ratio2; \
					if (TensileN >= 4) ratioN *= ratio2; \
					if (TensileN >= 6) ratioN *= ratio2; \
					float scorr = -tensileK_scaled * ratioN; \
					deltaP += (lambda_i_prev + lambda_j_prev + scorr) * gradW; \
					constraintCount++; \
				} \
			} \
		} \
	} \
}

//=============================================================================
// First Iteration: Build Neighbor List + Compute (Legacy Hash Table Mode)
// Searches 27 cells, caches valid neighbors, and performs calculation
//=============================================================================
#define BUILD_AND_PROCESS_CELL(DX, DY, DZ) \
{ \
	int3 neighborCell = centerCell + int3(DX, DY, DZ); \
	uint hash = HashCell(neighborCell); \
	uint count = min(CellCounts[hash], (uint)MAX_PARTICLES_PER_CELL); \
	uint startIdx = hash * MAX_PARTICLES_PER_CELL; \
	for (uint i = 0; i < count; ++i) \
	{ \
		uint neighborIdx = ParticleIndices[startIdx + i]; \
		if (neighborIdx >= (uint)ParticleCount) continue; \
		uint neighborIdx3 = neighborIdx * 3; \
		uint neighborFlags = Flags[neighborIdx]; \
		if (HasFlag(neighborFlags, GPU_PARTICLE_FLAG_IS_ATTACHED)) continue; \
		float3 neighborPos = float3(PredictedPositions[neighborIdx3], PredictedPositions[neighborIdx3 + 1], PredictedPositions[neighborIdx3 + 2]); \
		float3 r_cm = pos - neighborPos; \
		float r2_cm = dot(r_cm, r_cm); \
		float r2 = r2_cm * CM_TO_M_SQ; \
		if (r2 < h2) \
		{ \
			/* Cache this neighbor for future iterations */ \
			if (cachedCount < MAX_NEIGHBORS_PER_PARTICLE) \
			{ \
				uint cacheIdx = idx * MAX_NEIGHBORS_PER_PARTICLE + cachedCount; \
				NeighborList[cacheIdx] = neighborIdx; \
				cachedCount++; \
			} \
			float mass = Masses[neighborIdx]; \
			float w = Poly6Kernel(r2, h2); \
			density += mass * Poly6Coeff * w; \
			if (neighborIdx != idx) neighborCount++; \
			float3 r = r_cm * CM_TO_M; \
			float3 gradW = SpikyGradientFast(r, r2, h, h2); \
			gradW *= SpikyCoeff * CM_TO_M; \
			float3 gradC_j = -gradW * invRestDensity; \
			sumGradC2 += dot(gradC_j, gradC_j); \
			gradC_i += gradW * invRestDensity; \
			if (neighborIdx != idx && r2 >= SMALL_NUMBER) \
			{ \
				float lambda_j_prev = Lambdas[neighborIdx]; \
				float diff = h2 - r2; \
				float W_r = diff * diff * diff; \
				float ratio = W_r * InvW_DeltaQ; \
				float ratio2 = ratio * ratio; \
				float ratioN = ratio2; \
				if (TensileN >= 4) ratioN *= ratio2; \
				if (TensileN >= 6) ratioN *= ratio2; \
				float scorr = -tensileK_scaled * ratioN; \
				deltaP += (lambda_i_prev + lambda_j_prev + scorr) * gradW; \
				constraintCount++; \
			} \
		} \
	} \
}

//=============================================================================
// Main Compute Shader - Combined Density + Pressure with Neighbor Caching
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void SolveDensityPressureCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)ParticleCount)
	{
		return;
	}

	// Read SOA buffers
	uint idx3 = idx * 3;
	uint flags = Flags[idx];

	// Skip attached particles
	if (HasFlag(flags, GPU_PARTICLE_FLAG_IS_ATTACHED))
	{
		Densities[idx] = RestDensity;
		Lambdas[idx] = 0.0f;
		return;
	}

	// Skip sleeping particles - they are excluded from constraint solving
	// This reduces micro-jitter and improves performance (NVIDIA Flex technique)
	if (HasFlag(flags, GPU_PARTICLE_FLAG_IS_SLEEPING))
	{
		// Keep density at rest for sleeping particles
		Densities[idx] = RestDensity;
		Lambdas[idx] = 0.0f;
		// Position remains unchanged - sleeping particles don't move
		return;
	}

	// NEAR_BOUNDARY flag check - used later to skip position corrections
	bool bIsNearBoundary = HasFlag(flags, GPU_PARTICLE_FLAG_NEAR_BOUNDARY);

	float3 pos = float3(PredictedPositions[idx3], PredictedPositions[idx3 + 1], PredictedPositions[idx3 + 2]);
	float3 vel = float3(Velocities[idx3], Velocities[idx3 + 1], Velocities[idx3 + 2]);

	// Previous iteration's Lambda (for Jacobi-style update)
	float lambda_i_prev = Lambdas[idx];

	// Convert smoothing radius from cm to m for kernel calculations
	float h = SmoothingRadius * CM_TO_M;
	float h2 = h * h;

	// Accumulators
	float density = 0.0f;
	float3 gradC_i = float3(0.0f, 0.0f, 0.0f);
	float sumGradC2 = 0.0f;
	float3 deltaP = float3(0.0f, 0.0f, 0.0f);
	uint neighborCount = 0;
	uint constraintCount = 0;  // Averaged Position Update: count constraints for averaging

	// Position-Based Surface Tension accumulator (surface particles only)
	float3 surfaceTensionCorrection = float3(0.0f, 0.0f, 0.0f);
	uint surfaceTensionConstraintCount = 0;

	//=========================================================================
	// FleX-style Cohesion accumulator (NVIDIA FleX) - stringy, honey-like effects
	// ★ Key insight: Pull towards REST-DISTANCE, not towards each other
	//
	// FleX documentation: "Cohesion acts between fluid particles to bring them
	// towards the rest-distance" - this is crucial for stringy effects!
	//
	// - cohesionStartDist = rest-distance (target particle spacing)
	// - dist < rest-distance: no cohesion (density constraint pushes apart)
	// - dist > rest-distance: cohesion pulls back towards rest-distance
	// - At rest-distance: particles maintain spacing → stable strings/filaments
	//=========================================================================
	float3 cohesionCorrection = float3(0.0f, 0.0f, 0.0f);
	uint cohesionConstraintCount = 0;

	// Rest-distance: target spacing between particles
	// Cohesion pulls particles BACK to this distance (not towards each other!)
	// Smaller value = tighter strings, Larger value = looser connections
	float cohesionStartDist = CohesionActivationDistance;

	// Pre-compute inverse RestDensity to convert divisions to multiplications
	// Division is expensive on GPU (~20-30 cycles), multiplication is cheap (~4 cycles)
	float invRestDensity = 1.0f / RestDensity;

	// Artificial Pressure (PBF Eq.13-14) for Tensile Instability Correction
	// TensileK = Artificial Pressure strength from Physics|Simulation|Stability
	// Higher value = stronger anti-clumping = particles spread evenly
	// When bEnableTensileInstability = 0, tensileK_scaled = 0, making scorr = 0
	float tensileK_scaled = TensileK * (float)bEnableTensileInstability;

	//=========================================================================
	// Branch based on iteration index for neighbor caching
	//=========================================================================
	if (IterationIndex == 0)
	{
		//=====================================================================
		// First Iteration: Build neighbor cache + Compute
		//=====================================================================
		uint cachedCount = 0;

		int3 centerCell = WorldToCell(pos, CellSize);
		int cellRadius = (int)ceil(SmoothingRadius / CellSize);

		// Alternate traversal direction per iteration to eliminate Jacobi bias
		// All threads use same direction (no warp divergence), but direction flips each iteration
		int dir = (IterationIndex & 1) ? -1 : 1;
		int startR = (dir > 0) ? -cellRadius : cellRadius;
		int endR = -startR + dir;

		if (bUseZOrderSorting)
		{
			//=================================================================
			// Z-Order Mode: Sequential memory access via CellStart/End
			// Uniform direction per iteration (no warp divergence + no Jacobi bias)
			//=================================================================
			for (int dz = startR; dz != endR; dz += dir)
			{
				for (int dy = startR; dy != endR; dy += dir)
				{
					for (int dx = startR; dx != endR; dx += dir)
					{
						int3 neighborCell = centerCell + int3(dx, dy, dz);
						uint cellID = GetMortonCellIDFromCellCoord(neighborCell);
						uint cellStart = CellStart[cellID];
						uint cellEnd = CellEnd[cellID];

						// CRITICAL: Check BOTH cellStart AND cellEnd to prevent infinite loop
						if (cellStart == INVALID_INDEX || cellEnd == INVALID_INDEX) continue;

						uint maxNeighborIdx = min(cellEnd, (uint)(ParticleCount - 1));
						for (uint neighborIdx = cellStart; neighborIdx <= maxNeighborIdx; ++neighborIdx)
						{
							uint neighborIdx3 = neighborIdx * 3;
							uint neighborFlags = Flags[neighborIdx];

							// Skip attached neighbors - they cluster at bone and cause explosion
							if (HasFlag(neighborFlags, GPU_PARTICLE_FLAG_IS_ATTACHED))
							{
								continue;
							}

							float3 neighborPos = float3(PredictedPositions[neighborIdx3], PredictedPositions[neighborIdx3 + 1], PredictedPositions[neighborIdx3 + 2]);
							float3 r_cm = pos - neighborPos;
							float r2_cm = dot(r_cm, r_cm);
							float r2 = r2_cm * CM_TO_M_SQ;

							if (r2 < h2)
							{
								if (cachedCount < MAX_NEIGHBORS_PER_PARTICLE)
								{
									uint cacheIdx = idx * MAX_NEIGHBORS_PER_PARTICLE + cachedCount;
									NeighborList[cacheIdx] = neighborIdx;
									cachedCount++;
								}

								float mass = Masses[neighborIdx];
								float w = Poly6Kernel(r2, h2);
								density += mass * Poly6Coeff * w;
								if (neighborIdx != idx) neighborCount++;

								float3 r = r_cm * CM_TO_M;
								float3 gradW = SpikyGradientFast(r, r2, h, h2);
								gradW *= SpikyCoeff * CM_TO_M;

								float3 gradC_j = -gradW * invRestDensity;
								sumGradC2 += dot(gradC_j, gradC_j);
								gradC_i += gradW * invRestDensity;

								if (neighborIdx != idx && r2 >= SMALL_NUMBER)
								{
									float lambda_j_prev = Lambdas[neighborIdx];
									// Branchless tensile instability using pre-computed tensileK_scaled
									// When disabled, tensileK_scaled = 0, so scorr = 0
									float diff = h2 - r2;
									float W_r = diff * diff * diff;
									float ratio = W_r * InvW_DeltaQ;
									float ratio2 = ratio * ratio;
									float ratioN = ratio2;
									if (TensileN >= 4) ratioN *= ratio2;
									if (TensileN >= 6) ratioN *= ratio2;
									float scorr = -tensileK_scaled * ratioN;
									deltaP += (lambda_i_prev + lambda_j_prev + scorr) * gradW;
									constraintCount++;

									float dist_cm = sqrt(r2_cm);
									float3 pullDirection = -r_cm / max(dist_cm, SMALL_NUMBER);

									//=============================================================
									// Surface Tension (NVIDIA FleX style)
									// Position-based constraint that pulls particles toward rest distance
									// Creates spherical droplets by minimizing surface area
									//=============================================================
									if (bEnablePositionBasedSurfaceTension && SurfaceTensionStrength > 0.0f)
									{
										float stActivationWithTolerance = SurfaceTensionActivationDistance + SurfaceTensionTolerance;
										if (dist_cm > stActivationWithTolerance)
										{
											float stStrength = SurfaceTensionStrength;

											// Falloff: linear decrease from FalloffDistance to SmoothingRadius
											if (dist_cm > SurfaceTensionFalloffDistance)
											{
												float falloffRange = SmoothingRadius - SurfaceTensionFalloffDistance;
												float falloffT = (dist_cm - SurfaceTensionFalloffDistance) / max(falloffRange, 0.001f);
												stStrength *= saturate(1.0f - falloffT);
											}

											// Quadratic correction near tolerance boundary
											float distFromTolerance = dist_cm - stActivationWithTolerance;
											float toleranceRange = SurfaceTensionFalloffDistance - stActivationWithTolerance;
											float normalizedDist = saturate(distFromTolerance / max(toleranceRange, 0.001f));
											float easedStrength = normalizedDist * normalizedDist;

											float stCorrectionMag = distFromTolerance * stStrength * easedStrength;
											surfaceTensionCorrection += pullDirection * stCorrectionMag;
											surfaceTensionConstraintCount++;
										}
									}

									//=============================================================
									// Fluid Cohesion (NVIDIA FleX style) - Rest-Distance Based
									// Key insight: Pull towards REST-DISTANCE, not towards each other
									// - cohesionStartDist = rest-distance (target spacing)
									// - Particles closer than rest-distance: no cohesion (density pushes apart)
									// - Particles farther than rest-distance: cohesion pulls them back
									// This maintains particle spacing → creates stable strings
									//=============================================================
									if (CohesionStrength > 0.0f && dist_cm > cohesionStartDist)
									{
										// Error from rest-distance (how far beyond target spacing)
										float errorFromRest = dist_cm - cohesionStartDist;

										// Normalize: 0 at rest-distance, 1 at SmoothingRadius boundary
										float cohesionRange = SmoothingRadius - cohesionStartDist;
										float normalizedCohesion = saturate(errorFromRest / max(cohesionRange, 0.001f));

										// Apply exponent: stronger pull as particles drift further apart
										float cohesionScale = (CohesionExponent == 2) ? (normalizedCohesion * normalizedCohesion) :
										                      (CohesionExponent == 3) ? (normalizedCohesion * normalizedCohesion * normalizedCohesion) :
										                      normalizedCohesion;

										// ★ FleX-style: Pull by ERROR amount (towards rest-distance, not towards 0)
										// At rest-distance: error=0, no pull
										// At SmoothingRadius edge: error=cohesionRange, max pull
										float cohesionMag = cohesionScale * CohesionStrength * errorFromRest;

										cohesionCorrection += pullDirection * cohesionMag;
										cohesionConstraintCount++;
									}
								}
							}
						}
					}
				}
			}
		}
		else
		{
			//=================================================================
			// Legacy Hash Table Mode
			// Uniform direction per iteration (no warp divergence + no Jacobi bias)
			//=================================================================
			for (int dz = startR; dz != endR; dz += dir)
			{
				for (int dy = startR; dy != endR; dy += dir)
				{
					for (int dx = startR; dx != endR; dx += dir)
					{
						int3 neighborCell = centerCell + int3(dx, dy, dz);
						uint hash = HashCell(neighborCell);
						uint count = min(CellCounts[hash], (uint)MAX_PARTICLES_PER_CELL);
						uint startIdx = hash * MAX_PARTICLES_PER_CELL;

						for (uint i = 0; i < count; ++i)
						{
							uint neighborIdx = ParticleIndices[startIdx + i];
							if (neighborIdx >= (uint)ParticleCount)
							{
								continue;
							}

							uint neighborIdx3 = neighborIdx * 3;
							uint neighborFlags = Flags[neighborIdx];

							// Skip attached neighbors - they cluster at bone and cause explosion
							if (HasFlag(neighborFlags, GPU_PARTICLE_FLAG_IS_ATTACHED))
							{
								continue;
							}

							float3 neighborPos = float3(PredictedPositions[neighborIdx3], PredictedPositions[neighborIdx3 + 1], PredictedPositions[neighborIdx3 + 2]);
							float3 r_cm = pos - neighborPos;
							float r2_cm = dot(r_cm, r_cm);
							float r2 = r2_cm * CM_TO_M_SQ;

							if (r2 < h2)
							{
								// Cache this neighbor
								if (cachedCount < MAX_NEIGHBORS_PER_PARTICLE)
								{
									uint cacheIdx = idx * MAX_NEIGHBORS_PER_PARTICLE + cachedCount;
									NeighborList[cacheIdx] = neighborIdx;
									cachedCount++;
								}

								float mass = Masses[neighborIdx];
								float w = Poly6Kernel(r2, h2);
								density += mass * Poly6Coeff * w;

								if (neighborIdx != idx)
								{
									neighborCount++;
								}

								float3 r = r_cm * CM_TO_M;
								float3 gradW = SpikyGradientFast(r, r2, h, h2);
								gradW *= SpikyCoeff * CM_TO_M;

								float3 gradC_j = -gradW * invRestDensity;
								sumGradC2 += dot(gradC_j, gradC_j);
								gradC_i += gradW * invRestDensity;

								if (neighborIdx != idx && r2 >= SMALL_NUMBER)
								{
									float lambda_j_prev = Lambdas[neighborIdx];
									// Branchless tensile instability using pre-computed tensileK_scaled
									float diff = h2 - r2;
									float W_r = diff * diff * diff;
									float ratio = W_r * InvW_DeltaQ;
									float ratio2 = ratio * ratio;
									float ratioN = ratio2;
									if (TensileN >= 4) ratioN *= ratio2;
									if (TensileN >= 6) ratioN *= ratio2;
									float scorr = -tensileK_scaled * ratioN;
									deltaP += (lambda_i_prev + lambda_j_prev + scorr) * gradW;
									constraintCount++;

									float dist_cm = sqrt(r2_cm);
									float3 pullDirection = -r_cm / max(dist_cm, SMALL_NUMBER);

									//=============================================================
									// Surface Tension (NVIDIA FleX style)
									//=============================================================
									if (bEnablePositionBasedSurfaceTension && SurfaceTensionStrength > 0.0f)
									{
										float stActivationWithTolerance2 = SurfaceTensionActivationDistance + SurfaceTensionTolerance;
										if (dist_cm > stActivationWithTolerance2)
										{
											float stStrength = SurfaceTensionStrength;
											if (dist_cm > SurfaceTensionFalloffDistance)
											{
												float falloffRange = SmoothingRadius - SurfaceTensionFalloffDistance;
												float falloffT = (dist_cm - SurfaceTensionFalloffDistance) / max(falloffRange, 0.001f);
												stStrength *= saturate(1.0f - falloffT);
											}
											float distFromTolerance2 = dist_cm - stActivationWithTolerance2;
											float toleranceRange2 = SurfaceTensionFalloffDistance - stActivationWithTolerance2;
											float normalizedDist2 = saturate(distFromTolerance2 / max(toleranceRange2, 0.001f));
											float easedStrength2 = normalizedDist2 * normalizedDist2;
											float stCorrectionMag = distFromTolerance2 * stStrength * easedStrength2;
											surfaceTensionCorrection += pullDirection * stCorrectionMag;
											surfaceTensionConstraintCount++;
										}
									}

									//=============================================================
									// Fluid Cohesion (NVIDIA FleX style) - Rest-Distance Based
									// Pull towards rest-distance, not towards each other
									//=============================================================
									if (CohesionStrength > 0.0f && dist_cm > cohesionStartDist)
									{
										// Error from rest-distance
										float errorFromRest2 = dist_cm - cohesionStartDist;
										float cohesionRange2 = SmoothingRadius - cohesionStartDist;
										float normalizedCohesion2 = saturate(errorFromRest2 / max(cohesionRange2, 0.001f));
										float cohesionScale2 = (CohesionExponent == 2) ? (normalizedCohesion2 * normalizedCohesion2) :
										                       (CohesionExponent == 3) ? (normalizedCohesion2 * normalizedCohesion2 * normalizedCohesion2) :
										                       normalizedCohesion2;
										// ★ FleX-style: Pull by error amount
										float cohesionMag2 = cohesionScale2 * CohesionStrength * errorFromRest2;

										cohesionCorrection += pullDirection * cohesionMag2;
										cohesionConstraintCount++;
									}
								}
							}
						}
					}
				}
			}
		}

		// Store cached neighbor count
		NeighborCounts[idx] = cachedCount;
	}
	else
	{
		//=====================================================================
		// Subsequent Iterations: Use cached neighbor list (NO hash lookup!)
		// Alternate iteration direction to eliminate Jacobi bias
		//=====================================================================
		uint cachedCount = NeighborCounts[idx];
		uint baseIdx = idx * MAX_NEIGHBORS_PER_PARTICLE;

		// Alternate direction through cached list based on iteration
		// Even iterations: forward (0 → count), Odd iterations: reverse (count → 0)
		bool reverseOrder = (IterationIndex & 1) != 0;

		for (uint ni = 0; ni < cachedCount; ++ni)
		{
			uint n = reverseOrder ? (cachedCount - 1 - ni) : ni;
			uint neighborIdx = NeighborList[baseIdx + n];

			uint neighborIdx3 = neighborIdx * 3;
			uint neighborFlags = Flags[neighborIdx];

			// Skip attached neighbors - they cluster at bone and cause explosion
			if (HasFlag(neighborFlags, GPU_PARTICLE_FLAG_IS_ATTACHED))
			{
				continue;
			}

			float3 neighborPos = float3(PredictedPositions[neighborIdx3], PredictedPositions[neighborIdx3 + 1], PredictedPositions[neighborIdx3 + 2]);
			float3 r_cm = pos - neighborPos;
			float r2_cm = dot(r_cm, r_cm);
			float r2 = r2_cm * CM_TO_M_SQ;

			// Still need distance check as positions changed
			if (r2 < h2)
			{
				float mass = Masses[neighborIdx];
				float w = Poly6Kernel(r2, h2);
				density += mass * Poly6Coeff * w;

				if (neighborIdx != idx)
				{
					neighborCount++;
				}

				float3 r = r_cm * CM_TO_M;
				float3 gradW = SpikyGradientFast(r, r2, h, h2);
				gradW *= SpikyCoeff * CM_TO_M;

				float3 gradC_j = -gradW * invRestDensity;
				sumGradC2 += dot(gradC_j, gradC_j);
				gradC_i += gradW * invRestDensity;

				if (neighborIdx != idx && r2 >= SMALL_NUMBER)
				{
					float lambda_j_prev = Lambdas[neighborIdx];
					// Branchless tensile instability using pre-computed tensileK_scaled
					float diff = h2 - r2;
					float W_r = diff * diff * diff;
					float ratio = W_r * InvW_DeltaQ;
					float ratio2 = ratio * ratio;
					float ratioN = ratio2;
					if (TensileN >= 4) ratioN *= ratio2;
					if (TensileN >= 6) ratioN *= ratio2;
					float scorr = -tensileK_scaled * ratioN;
					deltaP += (lambda_i_prev + lambda_j_prev + scorr) * gradW;
					constraintCount++;

					float dist_cm = sqrt(r2_cm);
					float3 pullDirection = -r_cm / max(dist_cm, SMALL_NUMBER);

					//=============================================================
					// Surface Tension (NVIDIA FleX style)
					//=============================================================
					if (bEnablePositionBasedSurfaceTension && SurfaceTensionStrength > 0.0f)
					{
						float stActivationWithTolerance3 = SurfaceTensionActivationDistance + SurfaceTensionTolerance;
						if (dist_cm > stActivationWithTolerance3)
						{
							float stStrength = SurfaceTensionStrength;
							if (dist_cm > SurfaceTensionFalloffDistance)
							{
								float falloffRange = SmoothingRadius - SurfaceTensionFalloffDistance;
								float falloffT = (dist_cm - SurfaceTensionFalloffDistance) / max(falloffRange, 0.001f);
								stStrength *= saturate(1.0f - falloffT);
							}
							float distFromTolerance3 = dist_cm - stActivationWithTolerance3;
							float toleranceRange3 = SurfaceTensionFalloffDistance - stActivationWithTolerance3;
							float normalizedDist3 = saturate(distFromTolerance3 / max(toleranceRange3, 0.001f));
							float easedStrength3 = normalizedDist3 * normalizedDist3;
							float stCorrectionMag = distFromTolerance3 * stStrength * easedStrength3;
							surfaceTensionCorrection += pullDirection * stCorrectionMag;
							surfaceTensionConstraintCount++;
						}
					}

					//=============================================================
					// Fluid Cohesion (NVIDIA FleX style) - Rest-Distance Based
					// Pull towards rest-distance, not towards each other
					//=============================================================
					if (CohesionStrength > 0.0f && dist_cm > cohesionStartDist)
					{
						// Error from rest-distance
						float errorFromRest3 = dist_cm - cohesionStartDist;
						float cohesionRange3 = SmoothingRadius - cohesionStartDist;
						float normalizedCohesion3 = saturate(errorFromRest3 / max(cohesionRange3, 0.001f));
						float cohesionScale3 = (CohesionExponent == 2) ? (normalizedCohesion3 * normalizedCohesion3) :
						                       (CohesionExponent == 3) ? (normalizedCohesion3 * normalizedCohesion3 * normalizedCohesion3) :
						                       normalizedCohesion3;
						// ★ FleX-style: Pull by error amount
						float cohesionMag3 = cohesionScale3 * CohesionStrength * errorFromRest3;

						cohesionCorrection += pullDirection * cohesionMag3;
						cohesionConstraintCount++;
					}
				}
			}
		}
	}

	// Self contribution to gradient sum
	sumGradC2 += dot(gradC_i, gradC_i);

	//=========================================================================
	// Boundary Particles contribution (Akinci 2012)
	// 1. Density: ρ_i += Σ_k ψ_k W(|x_i - x_k|, h)
	// 2. Pressure gradient: Δx_i += λ_i * ψ_k * ∇W(x_i - x_k) / ρ_0
	// 3. Velocity Transfer: Fluid following moving boundaries (moved from FluidApplyViscosity)
	// This makes fluid particles "see" the boundary as solid, preventing penetration
	// AND pushes fluid away from boundaries (prevents wall climbing)
	//
	// Two modes:
	// 1. Z-Order Mode: O(K) neighbor search using Morton-sorted BoundaryCellStart/End
	// 2. Legacy Mode: O(M) brute-force (fallback)
	//=========================================================================
	
	// Boundary Velocity Transfer accumulators (XSPH-style smoothing with boundary)
	float3 boundaryVelCorrection = float3(0.0f, 0.0f, 0.0f);
	float boundaryVelWeight = 0.0f;
	
	if (bUseBoundaryDensity && BoundaryParticleCount > 0)
	{
		// Alternate traversal direction per iteration to eliminate Jacobi bias
		int bDir = (IterationIndex & 1) ? -1 : 1;
		int3 bCenterCell = WorldToCell(pos, CellSize);
		int bCellRadius = (int)ceil(SmoothingRadius / CellSize);
		int bStartR = (bDir > 0) ? -bCellRadius : bCellRadius;
		int bEndR = -bStartR + bDir;

		if (bUseBoundaryZOrder)
		{
			//=================================================================
			// Z-Order Mode: O(K) neighbor search using Morton code
			// SortedBoundaryParticles are sorted by Morton code
			// Uniform direction per iteration (no warp divergence + no Jacobi bias)
			//=================================================================
			for (int dz = bStartR; dz != bEndR; dz += bDir)
			{
				for (int dy = bStartR; dy != bEndR; dy += bDir)
				{
					for (int dx = bStartR; dx != bEndR; dx += bDir)
					{
						int3 neighborCell = bCenterCell + int3(dx, dy, dz);
						uint cellID = GetMortonCellIDFromCellCoord(neighborCell);
						uint bCellStart = BoundaryCellStart[cellID];
						uint bCellEnd = BoundaryCellEnd[cellID];

						// Skip empty cells
						if (bCellStart == INVALID_INDEX || bCellEnd == INVALID_INDEX)
							continue;

						// Iterate through boundary particles in this cell
						for (uint bi = bCellStart; bi <= bCellEnd; ++bi)
						{
							FGPUBoundaryParticle boundary = SortedBoundaryParticles[bi];
							float3 r_cm = pos - boundary.Position;
							float r2_cm = dot(r_cm, r_cm);
							float r2 = r2_cm * CM_TO_M_SQ;

							if (r2 < h2 && r2 > SMALL_NUMBER)
							{
								// Poly6 kernel for density
								float w = Poly6Kernel(r2, h2);
								density += boundary.Psi * Poly6Coeff * w;

								// Pressure gradient contribution from boundary
								float3 r = r_cm * CM_TO_M;
								float3 gradW = SpikyGradientFast(r, r2, h, h2);
								gradW *= SpikyCoeff * CM_TO_M;

								// Relative velocity damping: reduce pressure when boundary approaches fluid
								float pressureDampFactor = 1.0f;
								if (bEnableRelativeVelocityDamping)
								{
									float r_len = sqrt(r2_cm);
									if (r_len > SMALL_NUMBER)
									{
										float3 r_dir = r_cm / r_len;  // Direction from boundary to fluid
										float3 relVel = vel - boundary.Velocity;

										// Negative dot = boundary catching up (approaching)
										float approachSpeed = -dot(relVel, r_dir);

										// Damp pressure only when approaching (approachSpeed > 0)
										if (approachSpeed > 0.0f)
										{
											// Smooth falloff based on approach speed (cm/s)
											float dampAmount = saturate(approachSpeed / 1000.0f);
											pressureDampFactor = 1.0f - dampAmount * RelativeVelocityDampingStrength;
										}
									}
								}

								deltaP += pressureDampFactor * lambda_i_prev * boundary.Psi * gradW;
								
								//=============================================================
								// Boundary Velocity Transfer (moved from FluidApplyViscosity)
								// Fluid following moving boundaries - XSPH-style smoothing
								//=============================================================
								if (bEnableBoundaryVelocityTransfer && BoundaryAdhesionStrength > 0.0f)
								{
									float3 relativeVelocity = vel - boundary.Velocity;
									float relativeSpeed = length(relativeVelocity);

									// Detach factor: high relative speed = less transfer
									float detachFactor = smoothstep(BoundaryDetachSpeedThreshold, BoundaryMaxDetachSpeed, relativeSpeed);
									float transferFactor = (1.0f - detachFactor) * BoundaryVelocityTransferStrength;

									float3 velDiff = boundary.Velocity - vel;
									float contribution = w * boundary.Psi * BoundaryAdhesionStrength * transferFactor;
									boundaryVelCorrection += velDiff * contribution;
									boundaryVelWeight += contribution;
								}
							}
						}
					}
				}
			}
		}
		else
		{
			//=================================================================
			// Legacy Mode: O(M) brute-force (fallback)
			//=================================================================
			for (int bi = 0; bi < BoundaryParticleCount; ++bi)
			{
				FGPUBoundaryParticle boundary = BoundaryParticles[bi];
				float3 r_cm = pos - boundary.Position;
				float r2_cm = dot(r_cm, r_cm);
				float r2 = r2_cm * CM_TO_M_SQ;

			if (r2 < h2 && r2 > SMALL_NUMBER)
				{
					// Poly6 kernel for density
					float w = Poly6Kernel(r2, h2);
					density += boundary.Psi * Poly6Coeff * w;

					// Pressure gradient contribution from boundary
					float3 r = r_cm * CM_TO_M;
					float3 gradW = SpikyGradientFast(r, r2, h, h2);
					gradW *= SpikyCoeff * CM_TO_M;

					// Relative velocity damping: reduce pressure when boundary approaches fluid
					float pressureDampFactor = 1.0f;
					if (bEnableRelativeVelocityDamping)
					{
						float r_len = sqrt(r2_cm);
						if (r_len > SMALL_NUMBER)
						{
							float3 r_dir = r_cm / r_len;  // Direction from boundary to fluid
							float3 relVel = vel - boundary.Velocity;

							// Negative dot = boundary catching up (approaching)
							float approachSpeed = -dot(relVel, r_dir);

							// Damp pressure only when approaching (approachSpeed > 0)
							if (approachSpeed > 0.0f)
							{
								// Smooth falloff based on approach speed (cm/s)
								float dampAmount = saturate(approachSpeed / 1000.0f);
								pressureDampFactor = 1.0f - dampAmount * RelativeVelocityDampingStrength;
							}
						}
					}

					deltaP += pressureDampFactor * lambda_i_prev * boundary.Psi * gradW;
					
					//=============================================================
					// Boundary Velocity Transfer (moved from FluidApplyViscosity)
					// Fluid following moving boundaries - XSPH-style smoothing
					//=============================================================
					if (bEnableBoundaryVelocityTransfer && BoundaryAdhesionStrength > 0.0f)
					{
						float3 relativeVelocity = vel - boundary.Velocity;
						float relativeSpeed = length(relativeVelocity);

						// Detach factor: high relative speed = less transfer
						float detachFactor = smoothstep(BoundaryDetachSpeedThreshold, BoundaryMaxDetachSpeed, relativeSpeed);
						float transferFactor = (1.0f - detachFactor) * BoundaryVelocityTransferStrength;

						float3 velDiff = boundary.Velocity - vel;
						float contribution = w * boundary.Psi * BoundaryAdhesionStrength * transferFactor;
						boundaryVelCorrection += velDiff * contribution;
						boundaryVelWeight += contribution;
					}
				}
			}
		}
	}
	
	//=========================================================================
	// Apply Boundary Velocity Transfer
	// Scale by 1/SolverIterationCount to avoid over-application in multi-iteration solver
	// Skip for NEAR_BOUNDARY particles (they follow bone velocity)
	//=========================================================================
	if (boundaryVelWeight > SMALL_NUMBER && SolverIterationCount > 0 && !bIsNearBoundary)
	{
		float iterationScale = 1.0f / (float)SolverIterationCount;
		vel += (boundaryVelCorrection / boundaryVelWeight) * iterationScale;
	}

	//=========================================
	// Calculate NEW Lambda (XPBD formulation)
	//=========================================
	float C = (density * invRestDensity) - 1.0f;
	float alphaTilde = Compliance / max(DeltaTimeSq, 0.00001f);

	float lambda = lambda_i_prev;
	if (C > 0.0f)
	{
		float deltaLambda = (-C - alphaTilde * lambda_i_prev) / (sumGradC2 + alphaTilde);
		lambda = lambda_i_prev + deltaLambda;
	}
	// If C <= 0, keep previous Lambda

	//=========================================
	// Apply position correction
	// PBF formula: Δp = (1/ρ₀) × Σⱼ (λᵢ + λⱼ + s_corr) × ∇W
	// This is a SUM over neighbors, not an average
	float3 deltaP_cm = deltaP * invRestDensity;
	pos += deltaP_cm;

	//=========================================
	// Apply Position-Based Surface Tension
	// SurfaceTensionSurfaceThreshold > 0: Surface particles only (water-like)
	// SurfaceTensionSurfaceThreshold == 0: All particles (jelly-like)
	// Skip for NEAR_BOUNDARY particles (they follow bone position)
	//=========================================
	float deltaTime = sqrt(max(DeltaTimeSq, 0.0001f));  // Recover DeltaTime from DeltaTimeSq
	float invDeltaTime = 1.0f / deltaTime;

	if (surfaceTensionConstraintCount > 0 && !bIsNearBoundary)
	{
		float3 avgSTCorrection = surfaceTensionCorrection / (float)surfaceTensionConstraintCount;

		// Clamp for stability
		float stCorrLen = length(avgSTCorrection);
		if (stCorrLen > MaxSurfaceTensionCorrection && stCorrLen > SMALL_NUMBER)
		{
			avgSTCorrection = avgSTCorrection * (MaxSurfaceTensionCorrection / stCorrLen);
		}

		// Surface scaling: only when SurfaceTensionSurfaceThreshold > 0
		float surfaceScale = 1.0f;
		if (SurfaceTensionSurfaceThreshold > 0)
		{
			// Surface particles (fewer neighbors) get full ST, interior gets less
			float surfaceRatio = saturate((float)neighborCount / (float)SurfaceTensionSurfaceThreshold);
			surfaceScale = 1.0f - surfaceRatio;
			surfaceScale = sqrt(surfaceScale);  // Smooth transition
		}
		// When SurfaceTensionSurfaceThreshold == 0, surfaceScale = 1.0 (all particles)

		if (surfaceScale > 0.01f)
		{
			float relaxation = 1.0f - SurfaceTensionVelocityDamping;
			float3 posCorrection = avgSTCorrection * surfaceScale * relaxation;
			pos += posCorrection;
			// Also update velocity to match position change (for viscosity compatibility)
			vel += posCorrection * invDeltaTime;
		}
	}

	//=========================================
	// Apply Fluid Cohesion (NVIDIA FleX style)
	// Position-based constraint pulling particles toward rest distance
	// Creates stringy, honey-like viscous effects
	// Skip for NEAR_BOUNDARY particles (they follow bone position)
	//=========================================
	if (cohesionConstraintCount > 0 && !bIsNearBoundary)
	{
		float3 avgCohesionCorrection = cohesionCorrection / (float)cohesionConstraintCount;

		// Clamp for stability
		float cohCorrLen = length(avgCohesionCorrection);
		if (cohCorrLen > MaxSurfaceTensionCorrection && cohCorrLen > SMALL_NUMBER)
		{
			avgCohesionCorrection = avgCohesionCorrection * (MaxSurfaceTensionCorrection / cohCorrLen);
		}

		// Apply with damping for stability
		float relaxation = 1.0f - SurfaceTensionVelocityDamping;
		float3 posCorrection = avgCohesionCorrection * relaxation;
		pos += posCorrection;
		// Also update velocity to match position change (for viscosity compatibility)
		vel += posCorrection * invDeltaTime;
	}

	// Write back to SOA buffers
	PredictedPositions[idx3] = pos.x;
	PredictedPositions[idx3 + 1] = pos.y;
	PredictedPositions[idx3 + 2] = pos.z;

	Velocities[idx3] = vel.x;
	Velocities[idx3 + 1] = vel.y;
	Velocities[idx3 + 2] = vel.z;

	Densities[idx] = density;
	Lambdas[idx] = lambda;
	NeighborCountsBuffer[idx] = neighborCount;
}
