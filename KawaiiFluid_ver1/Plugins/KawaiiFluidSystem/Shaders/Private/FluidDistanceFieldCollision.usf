// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Fluid Physics - Distance Field Collision Pass
// Applies collision with UE5 Global Distance Field (static mesh collision)

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"

// Enable Global Distance Field sampling
#define USE_GLOBAL_DISTANCE_FIELD 1
#include "FluidDistanceFieldCommon.ush"

//=============================================================================
// Shader Parameters
//=============================================================================

RWStructuredBuffer<FGPUFluidParticle> Particles;
int ParticleCount;
float ParticleRadius;

// Distance Field Volume Parameters (passed from CPU)
// Note: These override the common header parameters
// GDFVolumeCenter, GDFVolumeExtent, GDFVoxelSize, GDFMaxDistance are defined in common header

// Collision Response Parameters
// DFCollisionRestitution, DFCollisionFriction, DFCollisionThreshold are defined in common header

//=============================================================================
// Position-Level Friction for Distance Field Collision
// Based on Unified Particle Physics (Macklin et al. 2014)
//=============================================================================

void ApplyDFPositionLevelFriction(
	inout float3 predictedPos,
	float3 originalPos,
	float3 normal,
	float penetration,
	inout float3 vel)
{
	// Push out of collision
	predictedPos += normal * (penetration + 0.1f);

	// Calculate total displacement from original position
	float3 deltaX = predictedPos - originalPos;

	// Decompose into normal and tangent components
	float deltaXNormal = dot(deltaX, normal);
	float3 deltaXNormalVec = deltaXNormal * normal;
	float3 deltaXTangent = deltaX - deltaXNormalVec;

	float tangentLength = length(deltaXTangent);

	// Apply friction only if there's tangent movement
	if (tangentLength > SMALL_NUMBER)
	{
		// Reference distance for friction scaling
		float d = max(penetration, 0.1f);

		// Static friction threshold
		float staticThreshold = DFCollisionFriction * d;

		if (tangentLength < staticThreshold)
		{
			// Static friction: stop tangent movement completely
			deltaXTangent = float3(0, 0, 0);
		}
		else
		{
			// Kinetic friction: reduce tangent displacement
			float frictionScale = min(DFCollisionFriction * d / tangentLength, 1.0f);
			deltaXTangent *= (1.0f - frictionScale);
		}
	}

	// Reconstruct position with friction-adjusted displacement
	predictedPos = originalPos + deltaXNormalVec + deltaXTangent;

	// Apply restitution to velocity for next timestep's bounce
	float velNormal = dot(vel, normal);
	if (velNormal < 0.0f)
	{
		vel -= (1.0f + DFCollisionRestitution) * velNormal * normal;
	}
}

//=============================================================================
// Main Compute Shader
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void DistanceFieldCollisionCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)ParticleCount)
	{
		return;
	}

	FGPUFluidParticle particle = Particles[idx];

	// Skip attached particles (CPU attachment or GPU boundary attachment)
	if (HasFlag(particle.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED) ||
		HasFlag(particle.Flags, GPU_PARTICLE_FLAG_IS_BOUNDARY_ATTACHED))
	{
		return;
	}

	float3 pos = particle.PredictedPosition;
	float3 originalPos = particle.Position;  // Original position for position-level friction
	float3 vel = particle.Velocity;

	// Sample distance field at particle position
	float SDF = SampleGlobalDistanceField(pos);
	float EffectiveDistance = SDF - ParticleRadius;

	// Check for collision
	if (EffectiveDistance < DFCollisionThreshold)
	{
		// Calculate surface normal from distance field gradient
		float3 Normal = CalculateGDFGradient(pos);

		// Calculate penetration depth
		float Penetration = max(0.0f, -EffectiveDistance);

		// Apply position-level friction (handles push-out internally)
		ApplyDFPositionLevelFriction(pos, originalPos, Normal, Penetration, vel);

		// Mark particle as near ground if collision normal is mostly upward
		// This is used by the adhesion system
		if (Normal.z > 0.5f)
		{
			particle.Flags = SetFlag(particle.Flags, GPU_PARTICLE_FLAG_NEAR_GROUND);
		}
	}
	else if (EffectiveDistance > DFCollisionThreshold * 2.0f)
	{
		// Clear near ground flag if particle is away from surfaces
		particle.Flags = ClearFlag(particle.Flags, GPU_PARTICLE_FLAG_NEAR_GROUND);
	}

	// Write back updated particle state
	particle.PredictedPosition = pos;
	particle.Velocity = vel;

	Particles[idx] = particle;
}
