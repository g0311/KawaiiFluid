// Copyright 2026 Team_Bruteforce. All Rights Reserved.
// GPU Fluid Physics - Update Bone Delta Attachment Pass
//
// Runs at SIMULATION END: Updates attachment data after physics simulation
//
// Steps:
// 1. Detach check: If distance from PreviousPosition > DetachDistance, detach
// 2. For unattached particles: Find nearest boundary particle, store OriginalIndex
// 3. Update PreviousPosition for next frame's detach check
//
// Uses OriginalIndex (stored in each boundary particle) for stable attachment
// across Z-Order sorting. This ensures the same boundary particle is referenced
// even when the sorted order changes.
//
// This is part of the bone-following system:
// 1. BoundarySkinningCS: Transform local boundary particles to world space
// 2. ApplyBoneTransform: Move fluid particles to attached boundary positions
// 3. [Physics simulation: density, pressure, viscosity, collision]
// 4. UpdateBoneDeltaAttachment (this pass): Find/update attachments

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"
#include "FluidBoneDeltaAttachment.ush"
#include "FluidMortonUtils.ush"
#include "FluidCollisionPrimitives.ush"

//=============================================================================
// Boundary Particle Structure (must match C++ FGPUBoundaryParticle)
// Includes OriginalIndex for stable attachment across Z-Order sorting
//=============================================================================

struct FGPUBoundaryParticleWithBone
{
	float3 Position;      // 12 bytes - World position
	float Psi;            // 4 bytes  - Boundary particle "mass" (total: 16)
	float3 Normal;        // 12 bytes - Surface normal
	int OwnerID;          // 4 bytes  - Owner component ID (total: 32)
	float3 Velocity;      // 12 bytes - World velocity
	float FrictionCoeff;  // 4 bytes  - Coulomb friction coefficient (total: 48)
	int BoneIndex;        // 4 bytes  - Skeleton bone index (-1 for static mesh)
	int OriginalIndex;    // 4 bytes  - Original index before Z-Order sorting
	float Padding1;       // 4 bytes  - Alignment padding
	float Padding2;       // 4 bytes  - Alignment padding (total: 64)
};

//=============================================================================
// Shader Parameters
//=============================================================================

// Fluid particles
RWStructuredBuffer<FGPUFluidParticle> Particles;
int ParticleCount;

// Bone Delta Attachment buffer (read/write)
RWStructuredBuffer<FGPUBoneDeltaAttachment> BoneDeltaAttachments;

// Z-Order sorted boundary particles (for efficient neighbor search)
StructuredBuffer<FGPUBoundaryParticleWithBone> SortedBoundaryParticles;
StructuredBuffer<uint> BoundaryCellStart;
StructuredBuffer<uint> BoundaryCellEnd;
int BoundaryParticleCount;

// World boundary particles (unsorted, for LocalOffset calculation by OriginalIndex)
StructuredBuffer<FGPUBoundaryParticleWithBone> WorldBoundaryParticles;
int WorldBoundaryParticleCount;

// Parameters
float AttachRadius;        // Radius within which to attach to boundary (= BoundaryAttachRadius)
float DetachDistance;      // Distance threshold for detaching (= BoundaryAttachRadius * 5.0)
float AdhesionStrength;    // Adhesion strength - if 0, no attachment allowed

// Z-Order bounds (must match fluid simulation)
float3 MortonBoundsMin;
float CellSize;

// Hybrid Tiled Z-Order mode (for unlimited simulation range)
int bUseHybridTiledZOrder;

//=============================================================================
// Collision Primitives (for direct collider surface normal calculation)
//=============================================================================
StructuredBuffer<FGPUCollisionSphere> CollisionSpheres;
StructuredBuffer<FGPUCollisionCapsule> CollisionCapsules;
StructuredBuffer<FGPUCollisionBox> CollisionBoxes;
StructuredBuffer<FGPUBoneTransform> BoneTransforms;
int SphereCount;
int CapsuleCount;
int BoxCount;
int BoneCount;

//=============================================================================
// Collider Surface Normal Calculation
// Finds the closest collider and returns its surface normal at contact point
//=============================================================================

float3 GetClosestColliderNormal(float3 pos, float searchRadius)
{
	float closestDist = searchRadius;
	float3 closestNormal = float3(0, 0, 1);  // Fallback: world up
	bool foundCollider = false;

	// NOTE: Colliders are ALREADY in world space (transformed by C++ before upload)
	// Do NOT apply bone transforms here!

	// Check spheres
	for (int si = 0; si < SphereCount; ++si)
	{
		FGPUCollisionSphere sphere = CollisionSpheres[si];

		float3 toPoint = pos - sphere.Center;
		float dist = length(toPoint);
		float signedDist = dist - sphere.Radius;

		if (abs(signedDist) < closestDist)
		{
			closestDist = abs(signedDist);
			closestNormal = (dist > 0.001f) ? (toPoint / dist) : float3(0, 0, 1);
			foundCollider = true;
		}
	}

	// Check capsules
	for (int ci = 0; ci < CapsuleCount; ++ci)
	{
		FGPUCollisionCapsule capsule = CollisionCapsules[ci];

		float3 ab = capsule.End - capsule.Start;
		float abLenSq = dot(ab, ab);
		float t = (abLenSq > 0.0001f) ? saturate(dot(pos - capsule.Start, ab) / abLenSq) : 0.0f;
		float3 closestOnAxis = capsule.Start + t * ab;
		float3 toPoint = pos - closestOnAxis;
		float dist = length(toPoint);
		float signedDist = dist - capsule.Radius;

		if (abs(signedDist) < closestDist)
		{
			closestDist = abs(signedDist);
			closestNormal = (dist > 0.001f) ? (toPoint / dist) : float3(0, 0, 1);
			foundCollider = true;
		}
	}

	// Check boxes
	for (int bi = 0; bi < BoxCount; ++bi)
	{
		FGPUCollisionBox box = CollisionBoxes[bi];

		// Transform to box local space
		float3 localP = InverseRotateByQuat(pos - box.Center, box.Rotation);

		// Clamp to box surface
		float3 clamped = clamp(localP, -box.Extent, box.Extent);

		// Find which face is closest
		float3 localNormal = float3(0, 0, 1);
		float3 diff = localP - clamped;
		float diffLen = length(diff);

		if (diffLen > 0.001f)
		{
			// Outside box: normal points from surface to point
			localNormal = diff / diffLen;
		}
		else
		{
			// Inside box: find closest face
			float3 distToFace = box.Extent - abs(localP);
			if (distToFace.x <= distToFace.y && distToFace.x <= distToFace.z)
				localNormal = float3(sign(localP.x), 0, 0);
			else if (distToFace.y <= distToFace.z)
				localNormal = float3(0, sign(localP.y), 0);
			else
				localNormal = float3(0, 0, sign(localP.z));
		}

		// Transform normal back to world space
		float3 worldNormal = RotateByQuat(localNormal, box.Rotation);
		float signedDist = diffLen;

		if (signedDist < closestDist)
		{
			closestDist = signedDist;
			closestNormal = worldNormal;
			foundCollider = true;
		}
	}

	return foundCollider ? normalize(closestNormal) : float3(0, 0, 1);
}

//=============================================================================
// Z-Order Cell ID Calculation
//=============================================================================

uint GetMortonCellIDFromCellCoord_Update(int3 cellCoord)
{
	if (bUseHybridTiledZOrder)
	{
		// Hybrid Tiled Z-Order: 21-bit key (matches MAX_CELLS, no truncation needed)
		// Hash collisions (8 tile buckets) are filtered by distance check
		return ComputeHybridTiledKey(cellCoord) & (MAX_CELLS - 1);
	}
	else
	{
		// Classic Morton code with bounded range
		int3 gridMin = int3(floor(MortonBoundsMin / CellSize));
		int3 offset = cellCoord - gridMin;
		uint3 uoffset = uint3(max(offset, int3(0, 0, 0)));
		uoffset = min(uoffset, uint3(MORTON_MAX_VALUE, MORTON_MAX_VALUE, MORTON_MAX_VALUE));
		return Morton3D(uoffset.x, uoffset.y, uoffset.z);
	}
}

int3 WorldToCell_Update(float3 worldPos)
{
	return int3(floor(worldPos / CellSize));
}

//=============================================================================
// Main Compute Shader
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void UpdateBoneDeltaAttachmentCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)ParticleCount)
	{
		return;
	}

	FGPUFluidParticle particle = Particles[idx];
	FGPUBoneDeltaAttachment attachment = BoneDeltaAttachments[idx];
	float3 pos = particle.Position;

	//=========================================================================
	// Step 1: Detach Check (if already attached)
	// Detach if:
	//   1. Particle moved more than DetachDistance from previous position (Sudden movement)
	//   2. LocalOffset exceeds AttachRadius * 5 (Too far from Boundary)
	//=========================================================================
	if (attachment.BoundaryParticleIndex >= 0)
	{
		float moveDist = length(pos - attachment.PreviousPosition);

		// Check LocalOffset distance (distance from Boundary accumulated by physics)
		float3 localOffset = attachment.LocalOffset;
		float offsetDist = length(localOffset);

		// Condition 1: Sudden movement between frames (DetachDistance = BoundaryAttachRadius * 5)
		// Condition 2: LocalOffset exceeds 5x AttachRadius (Too far from Boundary)
		if (moveDist > DetachDistance || offsetDist > AttachRadius * 5.0f)
		{
			// Detach! Distance exceeded threshold
			attachment.BoundaryParticleIndex = BONE_DELTA_INVALID_INDEX;
			attachment.LocalNormal = float3(0, 0, 0);
			attachment.LocalOffset = float3(0, 0, 0);
			particle.Flags = ClearFlag(particle.Flags, GPU_PARTICLE_FLAG_NEAR_BOUNDARY);
		}
	}

	//=========================================================================
	// Step 1.5: Update LocalOffset and LocalNormal for attached particles
	// Physics simulation may have moved the particle - update LocalOffset to reflect this
	// LocalOffset = CurrentPosition - BoundaryPosition
	// LocalNormal = Surface normal from COLLIDER GEOMETRY (Sphere/Capsule/Box)
	//=========================================================================
	if (attachment.BoundaryParticleIndex >= 0 && attachment.BoundaryParticleIndex < WorldBoundaryParticleCount)
	{
		float3 boundaryPos = WorldBoundaryParticles[attachment.BoundaryParticleIndex].Position;
		attachment.LocalOffset = pos - boundaryPos;  // LocalOffset = particle pos - boundary pos

		// DEBUG: Test if CapsuleCount is received by shader
		// If CapsuleCount > 0, output (1, 0, 0) - red direction
		// If CapsuleCount == 0, output (0, 1, 0) - green direction
		if (CapsuleCount > 0)
		{
			attachment.LocalNormal = float3(1, 0, 0);  // RED = capsules exist
		}
		else
		{
			attachment.LocalNormal = float3(0, 1, 0);  // GREEN = no capsules
		}
	}

	//=========================================================================
	// Step 2: Find new attachment (if not attached)
	// Only attach particles that already have NEAR_BOUNDARY flag (set by collision)
	// This prevents ALL particles from attaching just because they spawned near player
	// Also requires AdhesionStrength > 0 (if adhesion is disabled, no attachment)
	//=========================================================================
	bool bHasNearBoundaryFlag = HasFlag(particle.Flags, GPU_PARTICLE_FLAG_NEAR_BOUNDARY);
	if (attachment.BoundaryParticleIndex < 0 && BoundaryParticleCount > 0 && bHasNearBoundaryFlag && AdhesionStrength > 0.0f)
	{
		int nearestOriginalIndex = BONE_DELTA_INVALID_INDEX;
		float nearestDist = AttachRadius;

		// Z-Order search for nearby boundary particles
		int3 centerCell = WorldToCell_Update(pos);
		int cellRadius = (int)ceil(AttachRadius / CellSize);
		cellRadius = min(cellRadius, 2);  // Limit search radius for performance

		for (int dz = -cellRadius; dz <= cellRadius; ++dz)
		{
			for (int dy = -cellRadius; dy <= cellRadius; ++dy)
			{
				for (int dx = -cellRadius; dx <= cellRadius; ++dx)
				{
					int3 neighborCell = centerCell + int3(dx, dy, dz);
					uint cellID = GetMortonCellIDFromCellCoord_Update(neighborCell);

					// Bounds check for cell ID
					if (cellID >= MAX_CELLS)
					{
						continue;
					}

					uint bStart = BoundaryCellStart[cellID];
					uint bEnd = BoundaryCellEnd[cellID];

					// Skip empty cells
					if (bStart == INVALID_INDEX || bStart > bEnd)
					{
						continue;
					}

					// Search boundary particles in this cell
					for (uint bi = bStart; bi <= bEnd && bi < (uint)BoundaryParticleCount; ++bi)
					{
						FGPUBoundaryParticleWithBone boundary = SortedBoundaryParticles[bi];
						float dist = length(pos - boundary.Position);

						// Track nearest boundary with valid OriginalIndex for attachment
						if (dist < nearestDist && boundary.OriginalIndex >= 0 && boundary.OriginalIndex < WorldBoundaryParticleCount)
						{
							nearestDist = dist;
							nearestOriginalIndex = boundary.OriginalIndex;
						}
					}
				}
			}
		}

		// Attach if found a nearby boundary
		if (nearestOriginalIndex >= 0)
		{
			attachment.BoundaryParticleIndex = nearestOriginalIndex;

			// Initialize LocalOffset to zero (will be updated by physics)
			attachment.LocalOffset = float3(0, 0, 0);

			// Calculate surface normal from ACTUAL COLLIDER GEOMETRY (Sphere/Capsule/Box)
			// This gives the precise contact normal at the particle's position
			// Calculate surface normal from ACTUAL COLLIDER GEOMETRY (Sphere/Capsule/Box)
			attachment.LocalNormal = GetClosestColliderNormal(pos, AttachRadius * 2.0f);

			particle.Flags = SetFlag(particle.Flags, GPU_PARTICLE_FLAG_NEAR_BOUNDARY);
		}
	}

	//=========================================================================
	// Step 3: Update PreviousPosition for next frame's detach check
	//=========================================================================
	attachment.PreviousPosition = pos;

	// Write back
	BoneDeltaAttachments[idx] = attachment;
	Particles[idx] = particle;
}

