// Copyright 2026 Team_Bruteforce. All Rights Reserved.
// GPU Fluid Physics - Update Bone Delta Attachment Pass
//
// Runs at SIMULATION END: Updates attachment data after physics simulation
//
// Steps:
// 1. Detach check: If distance from PreviousPosition > DetachDistance, detach
// 2. For unattached particles: Find nearest boundary particle, store OriginalIndex
// 3. Update PreviousPosition for next frame's detach check
//
// Uses OriginalIndex (stored in each boundary particle) for stable attachment
// across Z-Order sorting. This ensures the same boundary particle is referenced
// even when the sorted order changes.
//
// This is part of the bone-following system:
// 1. BoundarySkinningCS: Transform local boundary particles to world space
// 2. ApplyBoneTransform: Move fluid particles to attached boundary positions
// 3. [Physics simulation: density, pressure, viscosity, collision]
// 4. UpdateBoneDeltaAttachment (this pass): Find/update attachments

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"
#include "FluidBoneDeltaAttachment.ush"
#include "FluidMortonUtils.ush"

//=============================================================================
// Boundary Particle Structure (must match C++ FGPUBoundaryParticle)
// Includes OriginalIndex for stable attachment across Z-Order sorting
//=============================================================================

struct FGPUBoundaryParticleWithBone
{
	float3 Position;      // 12 bytes - World position
	float Psi;            // 4 bytes  - Boundary particle "mass" (total: 16)
	float3 Normal;        // 12 bytes - Surface normal
	int OwnerID;          // 4 bytes  - Owner component ID (total: 32)
	float3 Velocity;      // 12 bytes - World velocity
	float FrictionCoeff;  // 4 bytes  - Coulomb friction coefficient (total: 48)
	int BoneIndex;        // 4 bytes  - Skeleton bone index (-1 for static mesh)
	int OriginalIndex;    // 4 bytes  - Original index before Z-Order sorting
	float Padding1;       // 4 bytes  - Alignment padding
	float Padding2;       // 4 bytes  - Alignment padding (total: 64)
};

//=============================================================================
// Shader Parameters
//=============================================================================

// Fluid particles
RWStructuredBuffer<FGPUFluidParticle> Particles;
int ParticleCount;

// Bone Delta Attachment buffer (read/write)
RWStructuredBuffer<FGPUBoneDeltaAttachment> BoneDeltaAttachments;

// Z-Order sorted boundary particles (for efficient neighbor search)
StructuredBuffer<FGPUBoundaryParticleWithBone> SortedBoundaryParticles;
StructuredBuffer<uint> BoundaryCellStart;
StructuredBuffer<uint> BoundaryCellEnd;
int BoundaryParticleCount;

// World boundary particles (unsorted, for LocalOffset calculation by OriginalIndex)
StructuredBuffer<FGPUBoundaryParticleWithBone> WorldBoundaryParticles;
int WorldBoundaryParticleCount;

// Parameters
float AttachRadius;        // Radius within which to attach to boundary (= BoundaryAttachRadius)
float DetachDistance;      // Distance threshold for detaching (= BoundaryAttachRadius * 5.0)
float AdhesionStrength;    // Adhesion strength - if 0, no attachment allowed

// Z-Order bounds (must match fluid simulation)
float3 MortonBoundsMin;
float CellSize;

//=============================================================================
// Z-Order Cell ID Calculation
//=============================================================================

uint GetMortonCellIDFromCellCoord_Update(int3 cellCoord)
{
	int3 gridMin = int3(floor(MortonBoundsMin / CellSize));
	int3 offset = cellCoord - gridMin;
	uint3 uoffset = uint3(max(offset, int3(0, 0, 0)));
	uoffset = min(uoffset, uint3(MORTON_MAX_VALUE, MORTON_MAX_VALUE, MORTON_MAX_VALUE));
	return Morton3D(uoffset.x, uoffset.y, uoffset.z);
}

int3 WorldToCell_Update(float3 worldPos)
{
	return int3(floor(worldPos / CellSize));
}

//=============================================================================
// Main Compute Shader
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void UpdateBoneDeltaAttachmentCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)ParticleCount)
	{
		return;
	}

	FGPUFluidParticle particle = Particles[idx];
	FGPUBoneDeltaAttachment attachment = BoneDeltaAttachments[idx];
	float3 pos = particle.Position;

	//=========================================================================
	// Step 1: Detach Check (if already attached)
	// Detach if:
	//   1. Particle moved more than DetachDistance from previous position (급격한 이동)
	//   2. LocalOffset exceeds AttachRadius * 2 (Boundary에서 너무 멀어짐)
	//=========================================================================
	if (attachment.BoundaryParticleIndex >= 0)
	{
		float moveDist = length(pos - attachment.PreviousPosition);

		// LocalOffset 거리 체크 (물리에 의해 누적된 Boundary로부터의 거리)
		float3 localOffset = attachment.Reserved;
		float offsetDist = length(localOffset);

		// 조건 1: 프레임 간 급격한 이동 (DetachDistance = BoundaryAttachRadius * 5)
		// 조건 2: LocalOffset이 AttachRadius의 5배 초과 (Boundary에서 너무 멀어짐)
		if (moveDist > DetachDistance || offsetDist > AttachRadius * 5.0f)
		{
			// Detach! Distance exceeded threshold
			attachment.BoundaryParticleIndex = BONE_DELTA_INVALID_INDEX;
			attachment.Reserved = float3(0, 0, 0);
			particle.Flags = ClearFlag(particle.Flags, GPU_PARTICLE_FLAG_NEAR_BOUNDARY);
		}
	}

	//=========================================================================
	// Step 1.5: Update LocalOffset for attached particles
	// Physics simulation may have moved the particle - update LocalOffset to reflect this
	// LocalOffset = CurrentPosition - BoundaryPosition
	//=========================================================================
	if (attachment.BoundaryParticleIndex >= 0 && attachment.BoundaryParticleIndex < WorldBoundaryParticleCount)
	{
		float3 boundaryPos = WorldBoundaryParticles[attachment.BoundaryParticleIndex].Position;
		attachment.Reserved = pos - boundaryPos;  // LocalOffset = particle pos - boundary pos
	}

	//=========================================================================
	// Step 2: Find new attachment (if not attached)
	// Only attach particles that already have NEAR_BOUNDARY flag (set by collision)
	// This prevents ALL particles from attaching just because they spawned near player
	// Also requires AdhesionStrength > 0 (if adhesion is disabled, no attachment)
	//=========================================================================
	bool bHasNearBoundaryFlag = HasFlag(particle.Flags, GPU_PARTICLE_FLAG_NEAR_BOUNDARY);
	if (attachment.BoundaryParticleIndex < 0 && BoundaryParticleCount > 0 && bHasNearBoundaryFlag && AdhesionStrength > 0.0f)
	{
		int nearestOriginalIndex = BONE_DELTA_INVALID_INDEX;
		float nearestDist = AttachRadius;

		// Z-Order search for nearby boundary particles
		int3 centerCell = WorldToCell_Update(pos);
		int cellRadius = (int)ceil(AttachRadius / CellSize);
		cellRadius = min(cellRadius, 2);  // Limit search radius for performance

		for (int dz = -cellRadius; dz <= cellRadius; ++dz)
		{
			for (int dy = -cellRadius; dy <= cellRadius; ++dy)
			{
				for (int dx = -cellRadius; dx <= cellRadius; ++dx)
				{
					int3 neighborCell = centerCell + int3(dx, dy, dz);
					uint cellID = GetMortonCellIDFromCellCoord_Update(neighborCell);

					// Bounds check for cell ID
					if (cellID >= MAX_CELLS)
					{
						continue;
					}

					uint bStart = BoundaryCellStart[cellID];
					uint bEnd = BoundaryCellEnd[cellID];

					// Skip empty cells
					if (bStart == INVALID_INDEX || bStart > bEnd)
					{
						continue;
					}

					// Search boundary particles in this cell
					for (uint bi = bStart; bi <= bEnd && bi < (uint)BoundaryParticleCount; ++bi)
					{
						FGPUBoundaryParticleWithBone boundary = SortedBoundaryParticles[bi];
						float dist = length(pos - boundary.Position);

						// Check if this is the nearest boundary with valid OriginalIndex
						// OriginalIndex is used to reference the unsorted WorldBoundaryParticles buffer
						if (dist < nearestDist && boundary.OriginalIndex >= 0 && boundary.OriginalIndex < WorldBoundaryParticleCount)
						{
							nearestDist = dist;
							nearestOriginalIndex = boundary.OriginalIndex;
						}
					}
				}
			}
		}

		// Attach if found a nearby boundary
		if (nearestOriginalIndex >= 0)
		{
			attachment.BoundaryParticleIndex = nearestOriginalIndex;
			attachment.Reserved = float3(0, 0, 0);
			particle.Flags = SetFlag(particle.Flags, GPU_PARTICLE_FLAG_NEAR_BOUNDARY);
		}
	}

	//=========================================================================
	// Step 3: Update PreviousPosition for next frame's detach check
	//=========================================================================
	attachment.PreviousPosition = pos;

	// Write back
	BoneDeltaAttachments[idx] = attachment;
	Particles[idx] = particle;
}

