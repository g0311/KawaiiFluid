// Copyright 2026 Team_Bruteforce. All Rights Reserved.
// GPU Fluid Physics - Heightmap Collision Pass
// Applies collision with terrain heightmap for Landscape support

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"
#include "FluidCollisionPrimitives.ush"

//=============================================================================
// Shader Parameters
//=============================================================================

// Particle buffers (SoA - Structure of Arrays)
RWBuffer<float> Positions;
RWBuffer<float> PredictedPositions;
RWBuffer<float> Velocities;
RWBuffer<uint> Flags;

int ParticleCount;
float ParticleRadius;

// Heightmap texture
Texture2D<float> HeightmapTexture;
SamplerState HeightmapSampler;

// World space transform parameters
float3 WorldMin;         // Heightmap coverage min XYZ
float3 WorldMax;         // Heightmap coverage max XYZ
float2 InvWorldExtent;   // 1/(Max.xy - Min.xy) for UV transform
int TextureWidth;
int TextureHeight;
float InvTextureWidth;   // 1/TextureWidth for texel offset
float InvTextureHeight;  // 1/TextureHeight for texel offset

// Collision response parameters
float Friction;
float Restitution;
float NormalStrength;    // Normal calculation strength (gradient scale)
float CollisionOffset;   // Extra offset for collision detection

//=============================================================================
// Helper Functions
//=============================================================================

// Convert world XY position to heightmap UV coordinates
float2 WorldToUV(float2 worldXY)
{
	return (worldXY - WorldMin.xy) * InvWorldExtent;
}

// Check if world position is within heightmap bounds (XY only)
bool IsInHeightmapBounds(float2 worldXY)
{
	return worldXY.x >= WorldMin.x && worldXY.x <= WorldMax.x &&
	       worldXY.y >= WorldMin.y && worldXY.y <= WorldMax.y;
}

// Sample terrain height at UV coordinates
// Returns world Z position of terrain surface
float SampleTerrainHeight(float2 uv)
{
	// Clamp UV to valid range
	uv = saturate(uv);

	// Sample heightmap (normalized 0-1 value)
	float normalizedHeight = HeightmapTexture.SampleLevel(HeightmapSampler, uv, 0);

	// Convert to world Z
	return lerp(WorldMin.z, WorldMax.z, normalizedHeight);
}

// Calculate terrain normal using Sobel gradient
// Uses central differences for smooth normal calculation
float3 CalculateTerrainNormal(float2 uv)
{
	// Texel size for gradient calculation
	float2 texelSize = float2(InvTextureWidth, InvTextureHeight);

	// Sample heights in a cross pattern (Sobel-like)
	float hL = SampleTerrainHeight(uv + float2(-texelSize.x, 0));  // Left
	float hR = SampleTerrainHeight(uv + float2(texelSize.x, 0));   // Right
	float hD = SampleTerrainHeight(uv + float2(0, -texelSize.y));  // Down
	float hU = SampleTerrainHeight(uv + float2(0, texelSize.y));   // Up

	// Calculate gradient (dZ/dX, dZ/dY)
	// World space extent per texel
	float worldTexelX = (WorldMax.x - WorldMin.x) * InvTextureWidth;
	float worldTexelY = (WorldMax.y - WorldMin.y) * InvTextureHeight;

	float dZdX = (hR - hL) / (2.0f * worldTexelX);
	float dZdY = (hU - hD) / (2.0f * worldTexelY);

	// Normal = normalize(-dZ/dX, -dZ/dY, 1)
	// The -gradient points uphill, we want the surface normal pointing up
	float3 normal = normalize(float3(-dZdX * NormalStrength, -dZdY * NormalStrength, 1.0f));

	return normal;
}

//=============================================================================
// Main Compute Shader
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void HeightmapCollisionCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)ParticleCount)
	{
		return;
	}

	uint idx3 = idx * 3;
	uint flags = Flags[idx];

	// Skip CPU-attached particles (they follow bone position directly)
	if (HasFlag(flags, GPU_PARTICLE_FLAG_IS_ATTACHED))
	{
		return;
	}

	// Read SoA buffers
	float3 pos = float3(PredictedPositions[idx3], PredictedPositions[idx3 + 1], PredictedPositions[idx3 + 2]);
	float3 originalPos = float3(Positions[idx3], Positions[idx3 + 1], Positions[idx3 + 2]);
	float3 vel = float3(Velocities[idx3], Velocities[idx3 + 1], Velocities[idx3 + 2]);

	// Check if particle is within heightmap XY bounds
	if (!IsInHeightmapBounds(pos.xy))
	{
		return;
	}

	// Convert world XY to UV
	float2 uv = WorldToUV(pos.xy);

	// Sample terrain height at particle XY position
	float terrainZ = SampleTerrainHeight(uv);

	// Calculate terrain normal from heightmap gradient
	float3 normal = CalculateTerrainNormal(uv);

	// Terrain surface point directly below particle (in XY)
	float3 terrainPoint = float3(pos.xy, terrainZ);

	// Calculate signed distance from particle CENTER to terrain PLANE
	// This is geometrically correct for sloped terrain!
	// Positive = particle center is above terrain plane
	// Negative = particle center is below terrain plane
	float signedDistance = dot(pos - terrainPoint, normal);

	// Penetration depth (how much particle radius penetrates terrain)
	// penetration > 0 means collision
	float penetration = (ParticleRadius + CollisionOffset) - signedDistance;

	if (penetration > 0.0f)
	{
		// === Heightmap-specific collision response (no hardcoded offset) ===
		// Push out with minimal skin offset to prevent flickering
		const float skinOffset = 0.01f;  // Much smaller than the 0.1f in shared function
		pos += normal * (penetration + skinOffset);

		// Position-level friction (Coulomb model)
		// Calculate displacement from original position
		float3 deltaX = pos - originalPos;
		float deltaXNormal = dot(deltaX, normal);
		float3 deltaXTangent = deltaX - deltaXNormal * normal;
		float tangentLength = length(deltaXTangent);

		// Apply friction using penetration depth as normal force proxy
		if (tangentLength > 0.001f)
		{
			float maxTangent = Friction * penetration;
			if (tangentLength < maxTangent)
			{
				// Static friction: stop tangent motion
				pos = originalPos + deltaXNormal * normal;
			}
			else
			{
				// Kinetic friction: reduce tangent motion
				float scale = maxTangent / tangentLength;
				pos = originalPos + deltaXNormal * normal + deltaXTangent * (1.0f - scale);
			}
		}

		// Apply restitution to velocity for bounce effect
		float velNormal = dot(vel, normal);
		if (velNormal < 0.0f)
		{
			vel -= (1.0f + Restitution) * velNormal * normal;
		}

		// Mark particle as near ground (used by adhesion system)
		if (normal.z > 0.5f)
		{
			flags = SetFlag(flags, GPU_PARTICLE_FLAG_NEAR_GROUND);
		}

		// Mark as collided this frame
		flags = SetFlag(flags, GPU_PARTICLE_FLAG_HAS_COLLIDED);
	}
	else if (signedDistance > ParticleRadius * 3.0f)
	{
		// Clear near ground flag if particle is well above terrain
		// (signedDistance > 0 means above terrain plane)
		flags = ClearFlag(flags, GPU_PARTICLE_FLAG_NEAR_GROUND);
	}

	// Write back to SoA buffers
	PredictedPositions[idx3] = pos.x;
	PredictedPositions[idx3 + 1] = pos.y;
	PredictedPositions[idx3 + 2] = pos.z;

	Velocities[idx3] = vel.x;
	Velocities[idx3 + 1] = vel.y;
	Velocities[idx3 + 2] = vel.z;

	Flags[idx] = flags;
}
