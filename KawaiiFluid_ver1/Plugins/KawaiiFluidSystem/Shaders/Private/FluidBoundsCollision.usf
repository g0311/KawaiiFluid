// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Fluid Physics - Bounds Collision Pass
// Applies AABB/OBB bounds collision with velocity response

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"

//=============================================================================
// Shader Parameters
//=============================================================================

RWStructuredBuffer<FGPUFluidParticle> Particles;
int ParticleCount;
float ParticleRadius;

// OBB parameters
float3 BoundsCenter;
float3 BoundsExtent;
float4 BoundsRotation;  // Quaternion (x, y, z, w)
int bUseOBB;

// Legacy AABB parameters
float3 BoundsMin;
float3 BoundsMax;

// Collision response
float Restitution;
float Friction;

//=============================================================================
// Quaternion Helpers
//=============================================================================

// Rotate vector by quaternion: q * v * q^-1
float3 QuatRotateVector(float4 q, float3 v)
{
	// Optimized quaternion-vector rotation
	// q = (x, y, z, w) where w is scalar part
	float3 qv = float3(q.x, q.y, q.z);
	float qw = q.w;

	float3 t = 2.0f * cross(qv, v);
	return v + qw * t + cross(qv, t);
}

// Rotate vector by inverse (conjugate) of quaternion
float3 QuatRotateVectorInverse(float4 q, float3 v)
{
	// For unit quaternion, inverse = conjugate = (-x, -y, -z, w)
	float4 qConj = float4(-q.x, -q.y, -q.z, q.w);
	return QuatRotateVector(qConj, v);
}

//=============================================================================
// Position-Level Friction Helper for Axis-Aligned Collision
// Applies friction at position level per Unified Particle Physics (Macklin 2014)
//=============================================================================

void ApplyAxisFriction(
	inout float3 predictedPos,
	float3 originalPos,
	float3 normal,
	float penetration,
	inout float3 vel)
{
	// Push out of collision
	predictedPos += normal * penetration;

	// Calculate displacement from original position
	float3 deltaX = predictedPos - originalPos;

	// Decompose into normal and tangent
	float deltaXN = dot(deltaX, normal);
	float3 deltaXNormalVec = deltaXN * normal;
	float3 deltaXTangent = deltaX - deltaXNormalVec;

	float tangentLen = length(deltaXTangent);

	if (tangentLen > SMALL_NUMBER)
	{
		// Reference distance for friction scaling
		float d = max(penetration, 0.1f);

		// Static friction threshold
		float staticThreshold = Friction * d;

		if (tangentLen < staticThreshold)
		{
			// Static friction: stop movement
			deltaXTangent = float3(0, 0, 0);
		}
		else
		{
			// Kinetic friction: reduce tangent displacement
			float frictionScale = min(Friction * d / tangentLen, 1.0f);
			deltaXTangent *= (1.0f - frictionScale);
		}
	}

	// Reconstruct position
	predictedPos = originalPos + deltaXNormalVec + deltaXTangent;

	// Apply restitution to velocity for next timestep's bounce
	float velN = dot(vel, normal);
	if (velN < 0.0f)
	{
		vel -= (1.0f + Restitution) * velN * normal;
	}
}

//=============================================================================
// AABB Collision with Position-Level Friction
//=============================================================================

void ApplyAABBCollision(inout float3 pos, float3 originalPos, inout float3 vel, inout uint flags)
{
	// Effective bounds considering particle radius
	float3 effectiveMin = BoundsMin + ParticleRadius;
	float3 effectiveMax = BoundsMax - ParticleRadius;

	bool hitGround = false;

	// X axis collision
	if (pos.x < effectiveMin.x)
	{
		float penetration = effectiveMin.x - pos.x;
		ApplyAxisFriction(pos, originalPos, float3(1, 0, 0), penetration, vel);
		originalPos = pos; // Update for subsequent axis checks
	}
	else if (pos.x > effectiveMax.x)
	{
		float penetration = pos.x - effectiveMax.x;
		ApplyAxisFriction(pos, originalPos, float3(-1, 0, 0), penetration, vel);
		originalPos = pos;
	}

	// Y axis collision
	if (pos.y < effectiveMin.y)
	{
		float penetration = effectiveMin.y - pos.y;
		ApplyAxisFriction(pos, originalPos, float3(0, 1, 0), penetration, vel);
		originalPos = pos;
	}
	else if (pos.y > effectiveMax.y)
	{
		float penetration = pos.y - effectiveMax.y;
		ApplyAxisFriction(pos, originalPos, float3(0, -1, 0), penetration, vel);
		originalPos = pos;
	}

	// Z axis collision (typically ground collision)
	if (pos.z < effectiveMin.z)
	{
		float penetration = effectiveMin.z - pos.z;
		ApplyAxisFriction(pos, originalPos, float3(0, 0, 1), penetration, vel);
		hitGround = true;
	}
	else if (pos.z > effectiveMax.z)
	{
		float penetration = pos.z - effectiveMax.z;
		ApplyAxisFriction(pos, originalPos, float3(0, 0, -1), penetration, vel);
	}

	// Update ground flag
	if (hitGround)
	{
		flags = SetFlag(flags, GPU_PARTICLE_FLAG_NEAR_GROUND);
	}
	else
	{
		flags = ClearFlag(flags, GPU_PARTICLE_FLAG_NEAR_GROUND);
	}
}

//=============================================================================
// OBB Collision with Position-Level Friction
//=============================================================================

void ApplyOBBCollision(inout float3 pos, float3 originalPos, inout float3 vel, inout uint flags)
{
	// Transform positions from world space to OBB local space
	float3 localPos = QuatRotateVectorInverse(BoundsRotation, pos - BoundsCenter);
	float3 localOriginalPos = QuatRotateVectorInverse(BoundsRotation, originalPos - BoundsCenter);
	float3 localVel = QuatRotateVectorInverse(BoundsRotation, vel);

	// Effective extents considering particle radius
	float3 effectiveExtent = BoundsExtent - ParticleRadius;
	effectiveExtent = max(effectiveExtent, float3(0.001f, 0.001f, 0.001f));  // Prevent negative

	bool hitGround = false;

	// X axis collision (in local space)
	if (localPos.x < -effectiveExtent.x)
	{
		float penetration = -effectiveExtent.x - localPos.x;
		ApplyAxisFriction(localPos, localOriginalPos, float3(1, 0, 0), penetration, localVel);
		localOriginalPos = localPos;
	}
	else if (localPos.x > effectiveExtent.x)
	{
		float penetration = localPos.x - effectiveExtent.x;
		ApplyAxisFriction(localPos, localOriginalPos, float3(-1, 0, 0), penetration, localVel);
		localOriginalPos = localPos;
	}

	// Y axis collision (in local space)
	if (localPos.y < -effectiveExtent.y)
	{
		float penetration = -effectiveExtent.y - localPos.y;
		ApplyAxisFriction(localPos, localOriginalPos, float3(0, 1, 0), penetration, localVel);
		localOriginalPos = localPos;
	}
	else if (localPos.y > effectiveExtent.y)
	{
		float penetration = localPos.y - effectiveExtent.y;
		ApplyAxisFriction(localPos, localOriginalPos, float3(0, -1, 0), penetration, localVel);
		localOriginalPos = localPos;
	}

	// Z axis collision (in local space - typically floor/ceiling)
	if (localPos.z < -effectiveExtent.z)
	{
		float penetration = -effectiveExtent.z - localPos.z;
		ApplyAxisFriction(localPos, localOriginalPos, float3(0, 0, 1), penetration, localVel);
		hitGround = true;
	}
	else if (localPos.z > effectiveExtent.z)
	{
		float penetration = localPos.z - effectiveExtent.z;
		ApplyAxisFriction(localPos, localOriginalPos, float3(0, 0, -1), penetration, localVel);
	}

	// Update ground flag
	if (hitGround)
	{
		flags = SetFlag(flags, GPU_PARTICLE_FLAG_NEAR_GROUND);
	}
	else
	{
		flags = ClearFlag(flags, GPU_PARTICLE_FLAG_NEAR_GROUND);
	}

	// Transform back to world space
	pos = QuatRotateVector(BoundsRotation, localPos) + BoundsCenter;
	vel = QuatRotateVector(BoundsRotation, localVel);
}

//=============================================================================
// Main Compute Shader
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void BoundsCollisionCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)ParticleCount)
	{
		return;
	}

	FGPUFluidParticle particle = Particles[idx];

	// Skip attached particles (CPU attachment or GPU boundary attachment)
	if (HasFlag(particle.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED) ||
		HasFlag(particle.Flags, GPU_PARTICLE_FLAG_IS_BOUNDARY_ATTACHED))
	{
		return;
	}

	float3 pos = particle.PredictedPosition;
	float3 originalPos = particle.Position;  // Original position for position-level friction
	float3 vel = particle.Velocity;
	uint flags = particle.Flags;

	// Apply collision based on mode (with position-level friction)
	if (bUseOBB != 0)
	{
		ApplyOBBCollision(pos, originalPos, vel, flags);
	}
	else
	{
		ApplyAABBCollision(pos, originalPos, vel, flags);
	}

	// Update particle
	particle.PredictedPosition = pos;
	particle.Velocity = vel;
	particle.Flags = flags;

	Particles[idx] = particle;
}
