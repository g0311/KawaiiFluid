// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Fluid Physics - Predict Positions Pass
//
// Phase 2 of PBF/XPBD simulation:
// 1. Force Accumulation (Gravity + External + Cohesion + Viscosity)
// 2. Velocity Update (V += F/m * dt + Viscosity corrections)
// 3. Position Prediction (P_pred = P + V * dt)
//
// OPTIMIZED: Cohesion + Viscosity are now calculated in a single neighbor loop
// using previous frame's neighbor cache. This reduces memory bandwidth by ~50%.
//
// This follows NVIDIA Flex / standard PBF approach where forces are applied
// before constraint solving to prevent jittering.

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"
#include "FluidForceAccumulation.ush"

//=============================================================================
// Shader Parameters
//=============================================================================

RWStructuredBuffer<FGPUFluidParticle> Particles;
int ParticleCount;
float DeltaTime;
float3 Gravity;
float3 ExternalForce;

// Cohesion Force parameters
float CohesionStrength;      // Surface tension strength (0 = disabled)
float SmoothingRadius;       // SPH kernel radius (cm)
float RestDensity;           // Rest density (kg/m^3) for K_ij correction
float MaxCohesionForce;      // Stability clamp

// Viscosity parameters (moved from PostSimulation Phase 5)
float ViscosityCoefficient;  // Viscosity strength (0 = disabled)
float Poly6Coeff;            // Poly6 kernel coefficient
float ViscLaplacianCoeff;    // 45 / (PI * h^6) for Laplacian viscosity

// Viscosity tuning constants (same as original FluidApplyViscosity.usf)
#define LAPLACIAN_VISCOSITY_SCALE 0.0001f
#define VELOCITY_DRAG_SCALE 5.0f

// Previous frame neighbor cache (double buffering for force calculation)
StructuredBuffer<uint> PrevNeighborList;
StructuredBuffer<uint> PrevNeighborCounts;
int bUsePrevNeighborCache;   // 0 = skip forces (first frame)
int PrevParticleCount;       // Safety: bounds check

//=============================================================================
// Main Compute Shader
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void PredictPositionsCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint idx = DispatchThreadId.x;
    if (idx >= (uint)ParticleCount)
    {
        return;
    }

    FGPUFluidParticle particle = Particles[idx];

    // Skip CPU-attached particles (they follow bone position directly)
    if (HasFlag(particle.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED))
    {
        particle.PredictedPosition = particle.Position;
        Particles[idx] = particle;
        return;
    }

    //=========================================================================
    // 1. Force Accumulation (Cohesion + Viscosity in single neighbor loop)
    //=========================================================================
    
    float3 cohesionAccel = float3(0.0f, 0.0f, 0.0f);
    float3 viscosityCorrection = float3(0.0f, 0.0f, 0.0f);
    float3 laplacianForce = float3(0.0f, 0.0f, 0.0f);
    float viscosityWeightSum = 0.0f;
    
    // Only calculate forces if we have valid neighbor cache
    if (bUsePrevNeighborCache && (CohesionStrength > 0.0f || ViscosityCoefficient > 0.0f))
    {
        FForceAccumulationResult forceResult = CalculateForceAccumulation(
            idx,
            particle.Position,
            particle.Velocity,
            particle.Mass,
            particle.Density,
            // Cohesion params
            CohesionStrength,
            MaxCohesionForce,
            RestDensity,
            // Viscosity params
            ViscosityCoefficient,
            Poly6Coeff,
            ViscLaplacianCoeff,
            // Common params
            SmoothingRadius,
            // Buffers
            PrevNeighborList,
            PrevNeighborCounts,
            ParticleCount,
            PrevParticleCount,
            Particles
        );
        
        cohesionAccel = forceResult.CohesionAccel;
        viscosityCorrection = forceResult.ViscosityCorrection;
        laplacianForce = forceResult.LaplacianForce;
        viscosityWeightSum = forceResult.WeightSum;
    }
    
    //=========================================================================
    // 2. Apply Forces to Velocity
    //=========================================================================
    
    // Total acceleration: Gravity + External + Cohesion
    float3 totalAcceleration = Gravity + ExternalForce + cohesionAccel;
    
    // Apply acceleration (Semi-implicit Euler)
    particle.Velocity += totalAcceleration * DeltaTime;
    
    //=========================================================================
    // 3. Apply Viscosity to Velocity
    //=========================================================================
    
    if (ViscosityCoefficient > 0.0f)
    {
        // XSPH velocity smoothing
        if (viscosityWeightSum > SMALL_NUMBER)
        {
            viscosityCorrection /= viscosityWeightSum;
            particle.Velocity += ViscosityCoefficient * viscosityCorrection;
        }
        
        // Laplacian viscosity (drag force)
        float mu = ViscosityCoefficient * ViscosityCoefficient * LAPLACIAN_VISCOSITY_SCALE;
        if (mu > SMALL_NUMBER)
        {
            particle.Velocity += mu * laplacianForce * DeltaTime;
        }
        
        // Velocity drag (air resistance)
        float dragCoeff = ViscosityCoefficient * ViscosityCoefficient * VELOCITY_DRAG_SCALE;
        if (dragCoeff > SMALL_NUMBER)
        {
            float damping = 1.0f - dragCoeff * DeltaTime;
            damping = max(damping, 0.0f);
            particle.Velocity *= damping;
        }
    }

    //=========================================================================
    // 4. Position Prediction
    //=========================================================================
    particle.PredictedPosition = particle.Position + particle.Velocity * DeltaTime;

    // XPBD Warm Starting: Preserve Lambda with damping
    particle.Lambda *= 0.9f;

    // Store back
    Particles[idx] = particle;
}
