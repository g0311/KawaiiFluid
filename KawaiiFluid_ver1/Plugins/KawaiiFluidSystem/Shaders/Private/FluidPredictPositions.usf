// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Fluid Physics - Predict Positions Pass
//
// Phase 2 of PBF/XPBD simulation:
// 1. Force Accumulation (Gravity + External + Cohesion + Viscosity)
// 2. Velocity Update (V += F/m * dt + Viscosity corrections)
// 3. Position Prediction (P_pred = P + V * dt)
//
// OPTIMIZED: Cohesion + Viscosity are now calculated in a single neighbor loop
// using previous frame's neighbor cache. This reduces memory bandwidth by ~50%.
//
// This follows NVIDIA Flex / standard PBF approach where forces are applied
// before constraint solving to prevent jittering.

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"
#include "FluidForceAccumulation.ush"

//=============================================================================
// Shader Parameters
//=============================================================================

RWStructuredBuffer<FGPUFluidParticle> Particles;
int ParticleCount;
float DeltaTime;
float3 Gravity;
float3 ExternalForce;

// Cohesion Force parameters
float CohesionStrength;      // Surface tension strength (0 = disabled)
float SmoothingRadius;       // SPH kernel radius (cm)
float RestDensity;           // Rest density (kg/m^3) for K_ij correction
float MaxCohesionForce;      // Stability clamp

// Viscosity parameters (moved from PostSimulation Phase 5)
float ViscosityCoefficient;  // Viscosity strength (0 = disabled)
float Poly6Coeff;            // Poly6 kernel coefficient
float ViscLaplacianCoeff;    // 45 / (PI * h^6) for Laplacian viscosity

// Viscosity tuning constants (same as original FluidApplyViscosity.usf)
#define LAPLACIAN_VISCOSITY_SCALE 0.0001f
#define VELOCITY_DRAG_SCALE 5.0f

// Previous frame neighbor cache (double buffering for force calculation)
StructuredBuffer<uint> PrevNeighborList;
StructuredBuffer<uint> PrevNeighborCounts;
int bUsePrevNeighborCache;   // 0 = skip forces (first frame)
int PrevParticleCount;       // Safety: bounds check

//=============================================================================
// Main Compute Shader
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void PredictPositionsCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint idx = DispatchThreadId.x;

    // Bounds check - this one branch is unavoidable (prevents out-of-bounds write)
    // Writing to invalid indices could corrupt memory or crash
    if (idx >= (uint)ParticleCount)
    {
        return;
    }

    FGPUFluidParticle particle = Particles[idx];

    //=========================================================================
    // Attached Mask: CPU-attached particles only update PredictedPosition
    // BRANCHLESS: All paths computed, result selected via lerp
    //=========================================================================
    float attachedMask = (float)HasFlag(particle.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED);
    float activeMask = 1.0f - attachedMask;

    //=========================================================================
    // 1. Force Accumulation (Cohesion + Viscosity in single neighbor loop)
    // OPTIMIZED: Always call, *0 masking handles disabled features
    //=========================================================================

    // bUsePrevNeighborCache: first frame has no cache, multiply by 0 to skip
    float cacheValid = (float)bUsePrevNeighborCache * activeMask;

    // Force-based cohesion is always disabled when Position-Based Cohesion is used
    // Position-Based handles cohesion in SolveDensityPressure as position constraint
    float forceCohesionStrength = 0.0f;  // Force-based cohesion disabled, using Position-Based instead

    FForceAccumulationResult forceResult = CalculateForceAccumulation(
        idx,
        particle.Position,
        particle.Velocity,
        particle.Mass,
        particle.Density,
        // Cohesion params - Force-based cohesion disabled (using Position-Based instead)
        forceCohesionStrength * cacheValid,
        MaxCohesionForce,
        RestDensity,
        // Viscosity params
        ViscosityCoefficient,
        Poly6Coeff,
        ViscLaplacianCoeff,
        // Common params
        SmoothingRadius,
        // Buffers
        PrevNeighborList,
        PrevNeighborCounts,
        ParticleCount,
        PrevParticleCount,
        Particles
    );

    // Apply cache validity mask
    float3 cohesionAccel = forceResult.CohesionAccel;  // Already masked via CohesionStrength * cacheValid
    float3 viscosityCorrection = forceResult.ViscosityCorrection * cacheValid;
    float3 laplacianForce = forceResult.LaplacianForce * cacheValid;
    float viscosityWeightSum = forceResult.WeightSum * cacheValid;

    //=========================================================================
    // 2. Apply Forces to Velocity (only for active particles via activeMask)
    //=========================================================================

    // Total acceleration: Gravity + External + Cohesion
    float3 totalAcceleration = Gravity + ExternalForce + cohesionAccel;

    // Apply acceleration (Semi-implicit Euler) - masked for active particles only
    particle.Velocity += totalAcceleration * DeltaTime * activeMask;

    //=========================================================================
    // 3. Apply Viscosity to Velocity
    // OPTIMIZED: No branches - uses *0 masking and safe division
    //=========================================================================

    // XSPH velocity smoothing (branchless, matches original logic)
    // When WeightSum < SMALL_NUMBER: no neighbors, skip correction (multiply by 0)
    float weightMask = step(SMALL_NUMBER, viscosityWeightSum);  // 1 if WeightSum >= SMALL_NUMBER, else 0
    float safeWeightSum = max(viscosityWeightSum, SMALL_NUMBER);
    viscosityCorrection = (viscosityCorrection / safeWeightSum) * weightMask;
    // When ViscosityCoefficient=0 or attached, this adds 0
    particle.Velocity += ViscosityCoefficient * viscosityCorrection * activeMask;

    // Laplacian viscosity (drag force) - masked
    float mu = ViscosityCoefficient * ViscosityCoefficient * LAPLACIAN_VISCOSITY_SCALE;
    particle.Velocity += mu * laplacianForce * DeltaTime * activeMask;

    // Velocity drag (air resistance) - use lerp for branchless damping
    float dragCoeff = ViscosityCoefficient * ViscosityCoefficient * VELOCITY_DRAG_SCALE;
    float damping = max(1.0f - dragCoeff * DeltaTime, 0.0f);
    // Active: apply damping, Attached: keep velocity unchanged (damping = 1.0)
    float effectiveDamping = lerp(damping, 1.0f, attachedMask);
    particle.Velocity *= effectiveDamping;

    //=========================================================================
    // 4. Position Prediction
    // Active: Position + Velocity * DeltaTime
    // Attached: Position (no movement)
    //=========================================================================
    float3 activePredicted = particle.Position + particle.Velocity * DeltaTime;
    float3 attachedPredicted = particle.Position;
    particle.PredictedPosition = lerp(activePredicted, attachedPredicted, attachedMask);

    // XPBD Warm Starting: Preserve Lambda with damping (only for active)
    // Attached: Lambda unchanged (multiply by 1.0)
    float lambdaDamping = lerp(0.9f, 1.0f, attachedMask);
    particle.Lambda *= lambdaDamping;

    // Store back
    Particles[idx] = particle;
}
