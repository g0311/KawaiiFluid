// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Fluid Physics - Predict Positions Pass
//
// Phase 2 of PBF/XPBD simulation:
// 1. Force Accumulation (Gravity + External + Cohesion)
// 2. Velocity Update (V += F/m * dt)
// 3. Position Prediction (P_pred = P + V * dt)
//
// Cohesion Force is applied here (before constraint solving) to prevent jittering.
// This follows NVIDIA Flex / standard PBF approach.

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"
#include "FluidCohesion.ush"

//=============================================================================
// Shader Parameters
//=============================================================================

RWStructuredBuffer<FGPUFluidParticle> Particles;
int ParticleCount;
float DeltaTime;
float3 Gravity;
float3 ExternalForce;

// Cohesion Force parameters
float CohesionStrength;      // Surface tension strength (0 = disabled)
float SmoothingRadius;       // SPH kernel radius (cm)
float RestDensity;           // Rest density (kg/m^3) for K_ij correction
float MaxCohesionForce;      // Stability clamp

// Previous frame neighbor cache (double buffering for cohesion)
StructuredBuffer<uint> PrevNeighborList;
StructuredBuffer<uint> PrevNeighborCounts;
int bUsePrevNeighborCache;   // 0 = skip cohesion (first frame)
int PrevParticleCount;       // Safety: bounds check

//=============================================================================
// Main Compute Shader
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void PredictPositionsCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint idx = DispatchThreadId.x;
    if (idx >= (uint)ParticleCount)
    {
        return;
    }

    FGPUFluidParticle particle = Particles[idx];

    // Skip CPU-attached particles (they follow bone position directly)
    if (HasFlag(particle.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED))
    {
        particle.PredictedPosition = particle.Position;
        Particles[idx] = particle;
        return;
    }

    //=========================================================================
    // 1. Force Accumulation (all forces calculated in registers)
    //=========================================================================
    
    // Cohesion Force (using previous frame's neighbor cache)
    float3 cohesionAccel = float3(0.0f, 0.0f, 0.0f);
    if (CohesionStrength > 0.0f && bUsePrevNeighborCache)
    {
        cohesionAccel = CalculateCohesionForce(
            idx,
            particle.Position,
            particle.Mass,
            particle.Density,
            CohesionStrength,
            SmoothingRadius,
            RestDensity,
            MaxCohesionForce,
            PrevNeighborList,
            PrevNeighborCounts,
            ParticleCount,
            PrevParticleCount,
            Particles
        );
    }
    
    // Total acceleration: Gravity + External + Cohesion
    float3 totalAcceleration = Gravity + ExternalForce + cohesionAccel;

    //=========================================================================
    // 2. Velocity Update (Semi-implicit Euler)
    //=========================================================================
    particle.Velocity += totalAcceleration * DeltaTime;

    //=========================================================================
    // 3. Position Prediction
    //=========================================================================
    particle.PredictedPosition = particle.Position + particle.Velocity * DeltaTime;

    // XPBD Warm Starting: Preserve Lambda with damping
    particle.Lambda *= 0.9f;

    // Store back
    Particles[idx] = particle;
}
