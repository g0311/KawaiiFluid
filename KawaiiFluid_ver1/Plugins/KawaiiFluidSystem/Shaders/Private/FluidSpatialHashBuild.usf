// Copyright KawaiiFluid Team. All Rights Reserved.
// Compute Shader for building GPU Spatial Hash Grid

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidSpatialHash.ush"

//=============================================================================
// Shader Parameters
//=============================================================================

// Input: Particle positions (shared by all passes)
StructuredBuffer<float3> ParticlePositions;
int ParticleCount;
float ParticleRadius;
float CellSize;

// Output: Hash grid data (shared by all passes)
// Simplified: CellCounts stores only count, startIndex = Hash * MAX_PARTICLES_PER_CELL
RWStructuredBuffer<uint> CellCounts;            // count per cell (simplified from uint2)
RWStructuredBuffer<uint> ParticleIndices;       // Particle indices per cell

// Used by multi-pass build only (CountParticles, PrefixSum, Scatter, Finalize)
// These are NOT used by BuildSpatialHashSimpleCS or ClearCellDataCS (Simple version)
#if USE_MULTIPASS_BUILD
RWStructuredBuffer<uint2> CellData;             // {startIndex, count} per cell
RWStructuredBuffer<uint> CellCounters;          // Atomic counter per cell
RWStructuredBuffer<uint> ParticleCellHashes;    // Hash for each particle (for sorting)
RWStructuredBuffer<uint> PrefixSumBuffer;       // Prefix sum workspace
#endif

//=============================================================================
// Multi-pass build (for large particle counts > 10K)
// Requires USE_MULTIPASS_BUILD to be defined
//=============================================================================

#if USE_MULTIPASS_BUILD

//=============================================================================
// Pass 1: Count particles per cell
//=============================================================================

[numthreads(256, 1, 1)]
void CountParticlesPerCellCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint ParticleIdx = DispatchThreadId.x;
    if (ParticleIdx >= (uint)ParticleCount)
        return;

    float3 Pos = ParticlePositions[ParticleIdx];
    int3 CellCoord = WorldToCell(Pos, CellSize);
    uint Hash = HashCell(CellCoord);

    // Store hash for this particle
    ParticleCellHashes[ParticleIdx] = Hash;

    // Atomic increment cell counter
    uint OldCount;
    InterlockedAdd(CellCounters[Hash], 1, OldCount);
}

//=============================================================================
// Pass 2: Prefix sum to compute start indices (Single-threaded for correctness)
//=============================================================================

[numthreads(1, 1, 1)]
void PrefixSumCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint sum = 0;
    for (uint i = 0; i < SPATIAL_HASH_SIZE; ++i)
    {
        uint count = CellCounters[i];
        PrefixSumBuffer[i] = sum;
        sum += count;
    }
}

//=============================================================================
// Pass 3: Scatter particles into cells
// NOTE: CellCounters is reused as local index counter (cleared before scatter)
//=============================================================================

[numthreads(256, 1, 1)]
void ScatterParticlesCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint ParticleIdx = DispatchThreadId.x;
    if (ParticleIdx >= (uint)ParticleCount)
        return;

    uint Hash = ParticleCellHashes[ParticleIdx];
    uint StartIndex = PrefixSumBuffer[Hash];

    // Atomic increment CellCounters to get position within cell
    // CellCounters was cleared between Count and Scatter passes
    uint LocalIdx;
    InterlockedAdd(CellCounters[Hash], 1, LocalIdx);

    // Write particle index to sorted position (no limit in multipass)
    ParticleIndices[StartIndex + LocalIdx] = ParticleIdx;
}

//=============================================================================
// Pass 4: Finalize cell data (set start indices)
//=============================================================================

[numthreads(256, 1, 1)]
void FinalizeCellDataCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint CellIdx = DispatchThreadId.x;
    if (CellIdx >= SPATIAL_HASH_SIZE)
        return;

    uint StartIndex = PrefixSumBuffer[CellIdx];
    // Read count from CellCounters (after Scatter pass)
    uint Count = CellCounters[CellIdx];

    CellData[CellIdx] = uint2(StartIndex, Count);
}

#endif // USE_MULTIPASS_BUILD

//=============================================================================
// Combined Pass: Simple O(N) build for small particle counts
// More efficient than multi-pass for < 10K particles
// This is the DEFAULT method used by FBuildSpatialHashSimpleCS
//=============================================================================

[numthreads(256, 1, 1)]
void BuildSpatialHashSimpleCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint ParticleIdx = DispatchThreadId.x;
    if (ParticleIdx >= (uint)ParticleCount)
        return;

    float3 Pos = ParticlePositions[ParticleIdx];
    int3 CellCoord = WorldToCell(Pos, CellSize);
    uint Hash = HashCell(CellCoord);

    // Atomic add to get slot in cell (now on simple uint, not uint2.y)
    uint Slot;
    InterlockedAdd(CellCounts[Hash], 1, Slot);

    // Store particle index if within limit
    if (Slot < MAX_PARTICLES_PER_CELL)
    {
        // Use hash * MAX_PARTICLES_PER_CELL as base offset (fixed layout)
        uint BaseOffset = Hash * MAX_PARTICLES_PER_CELL;
        ParticleIndices[BaseOffset + Slot] = ParticleIdx;
    }
}

//=============================================================================
// Clear buffers (Simple version)
// Used by BuildSpatialHashSimpleCS method
//=============================================================================

[numthreads(256, 1, 1)]
void ClearCellDataCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint CellIdx = DispatchThreadId.x;
    if (CellIdx >= SPATIAL_HASH_SIZE)
        return;

    // Initialize CellCounts to 0 (startIndex is implicit: CellIdx * MAX_PARTICLES_PER_CELL)
    CellCounts[CellIdx] = 0;
}

//=============================================================================
// Simple Version: Sort particles within each cell
// For fixed-layout hash (Hash * MAX_PARTICLES_PER_CELL)
//=============================================================================

[numthreads(256, 1, 1)]
void SortCellParticlesCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint CellIdx = DispatchThreadId.x;
    if (CellIdx >= SPATIAL_HASH_SIZE)
        return;

    uint Count = min(CellCounts[CellIdx], MAX_PARTICLES_PER_CELL);
    if (Count <= 1)
        return;

    uint BaseOffset = CellIdx * MAX_PARTICLES_PER_CELL;

    // Load indices into local array
    uint LocalIndices[MAX_PARTICLES_PER_CELL];
    for (uint i = 0; i < Count; ++i)
    {
        LocalIndices[i] = ParticleIndices[BaseOffset + i];
    }

    // Simple insertion sort
    for (uint j = 1; j < Count; ++j)
    {
        uint key = LocalIndices[j];
        uint insertPos = j;

        for (uint scan = j; scan > 0; --scan)
        {
            if (LocalIndices[scan - 1] > key)
            {
                LocalIndices[scan] = LocalIndices[scan - 1];
                insertPos = scan - 1;
            }
            else
            {
                break;
            }
        }
        LocalIndices[insertPos] = key;
    }

    // Write back sorted indices
    for (uint m = 0; m < Count; ++m)
    {
        ParticleIndices[BaseOffset + m] = LocalIndices[m];
    }
}

//=============================================================================
// Clear buffers (Multi-pass version - with CellCounters)
// Used by multi-pass build method
//=============================================================================

#if USE_MULTIPASS_BUILD
[numthreads(256, 1, 1)]
void ClearCellDataMultipassCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint CellIdx = DispatchThreadId.x;
    if (CellIdx >= SPATIAL_HASH_SIZE)
        return;

    // CellData will be filled by Finalize pass
    CellData[CellIdx] = uint2(0, 0);
    CellCounters[CellIdx] = 0;
}

//=============================================================================
// Sort particles within each bucket (deterministic order for smin)
// Uses Selection Sort in global memory - NO size limit per bucket
//=============================================================================

[numthreads(256, 1, 1)]
void SortBucketParticlesCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint CellIdx = DispatchThreadId.x;
    if (CellIdx >= SPATIAL_HASH_SIZE)
        return;

    uint2 Cell = CellData[CellIdx];
    uint StartIndex = Cell.x;
    uint Count = Cell.y;

    if (Count <= 1)
        return;

    // Selection Sort in global memory (O(nÂ²) but no size limit)
    for (uint i = 0; i < Count - 1; ++i)
    {
        uint minIdx = i;
        uint minVal = ParticleIndices[StartIndex + i];

        for (uint j = i + 1; j < Count; ++j)
        {
            uint val = ParticleIndices[StartIndex + j];
            if (val < minVal)
            {
                minIdx = j;
                minVal = val;
            }
        }

        if (minIdx != i)
        {
            ParticleIndices[StartIndex + minIdx] = ParticleIndices[StartIndex + i];
            ParticleIndices[StartIndex + i] = minVal;
        }
    }
}
#endif
