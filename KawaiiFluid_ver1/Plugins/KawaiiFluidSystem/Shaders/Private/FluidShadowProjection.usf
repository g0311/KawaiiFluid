// Copyright KawaiiFluid Team. All Rights Reserved.
//
// Fluid Shadow Projection Compute Shader
//
// Projects previous frame's fluid depth into light space for VSM shadow generation.
// All pipelines output Device-Z (0-1, reversed-Z) for unified processing:
// - RayMarching: Device-Z directly
// - ScreenSpace: Linear depth converted via FluidLinearToDeviceDepth pass
//
// Pipeline: History Depth (Device-Z) -> World Position -> Light Clip Space -> VSM

#include "/Engine/Private/Common.ush"

// Input: Previous frame's smoothed depth texture
Texture2D<float> HistoryDepthTexture;

// Output: VSM shadow map (RG32F: depth, depth²)
RWTexture2D<float2> VSMTexture;

// Atomic depth buffer for min-depth tracking (R32_UINT)
RWTexture2D<uint> DepthAtomicBuffer;

// Camera matrices (from previous frame)
float4x4 HistoryInvViewProjectionMatrix;

// Light matrices (current frame)
float4x4 LightViewProjectionMatrix;

// Texture dimensions
float2 HistoryTextureSize;
float2 VSMTextureSize;

// Near plane for Linear Depth → Device-Z conversion
float NearPlane;

// Background depth thresholds
// Device-Z (reversed-Z): Near=1.0, Far=0.0, Background=0.0
#define BACKGROUND_DEVICEZ_THRESH 0.0001f
// Linear Depth: View-space Z distance, Background=3.0e30f
#define BACKGROUND_LINEAR_THRESH 3.0e30f
// Threshold to detect Linear vs Device-Z: Device-Z is always in [0,1], Linear is always > 1
#define LINEAR_DEPTH_DETECTION_THRESH 1.5f

// Encode float depth to uint for atomic comparison (reversed Z: 0=far, 1=near)
// We want to find the CLOSEST depth (largest value in reversed-Z)
uint EncodeDepthToUint(float Depth)
{
    // Clamp to valid range and convert to uint
    // Using reversed mapping: closer objects have higher uint values
    return asuint(saturate(Depth));
}

float DecodeUintToDepth(uint EncodedDepth)
{
    return asfloat(EncodedDepth);
}

/**
 * Reconstruct world position from screen UV and Device-Z depth.
 *
 * All pipelines now output Device-Z (0-1, reversed-Z) for unified shadow processing:
 * - RayMarching: Outputs Device-Z directly
 * - ScreenSpace: Linear depth converted to Device-Z via FluidLinearToDeviceDepth pass
 *
 * @param ScreenUV Normalized screen coordinates (0-1)
 * @param DeviceZ Device depth value (0=far, 1=near in reversed-Z)
 * @return World space position
 */
float3 ReconstructWorldPosition(float2 ScreenUV, float DeviceZ)
{
    // Convert UV to NDC (-1 to 1)
    // Note: Y is flipped (UV is top-down, NDC is bottom-up)
    float2 NDC;
    NDC.x = ScreenUV.x * 2.0f - 1.0f;
    NDC.y = -(ScreenUV.y * 2.0f - 1.0f);

    // Create clip space position using Device-Z
    float4 ClipPos = float4(NDC.x, NDC.y, DeviceZ, 1.0f);

    // Transform to world space using InvViewProjectionMatrix
    float4 WorldPos4 = mul(ClipPos, HistoryInvViewProjectionMatrix);

    // Perspective divide
    float3 WorldPos = WorldPos4.xyz / WorldPos4.w;

    return WorldPos;
}

/**
 * Project world position to light clip space.
 *
 * @param WorldPos World space position
 * @param OutLightUV Output: normalized light space UV (0-1)
 * @param OutLightDepth Output: light space depth (0-1)
 * @return True if position is within light frustum
 */
bool ProjectToLightSpace(float3 WorldPos, out float2 OutLightUV, out float OutLightDepth)
{
    // Transform to light clip space
    float4 LightClipPos = mul(float4(WorldPos, 1.0f), LightViewProjectionMatrix);

    // Perspective divide
    float3 LightNDC = LightClipPos.xyz / LightClipPos.w;

    // Check if within light frustum
    if (any(abs(LightNDC.xy) > 1.0f) || LightNDC.z < 0.0f || LightNDC.z > 1.0f)
    {
        OutLightUV = float2(0, 0);
        OutLightDepth = 0;
        return false;
    }

    // Convert NDC to UV (0-1)
    OutLightUV.x = LightNDC.x * 0.5f + 0.5f;
    OutLightUV.y = -LightNDC.y * 0.5f + 0.5f; // Y flip for texture coordinates

    OutLightDepth = LightNDC.z;

    return true;
}

/**
 * Main compute shader: Projects fluid depth to VSM shadow map.
 *
 * Each thread processes one pixel from the history depth texture.
 * Valid depths are projected to light space and written to VSM.
 *
 * Supports both Device-Z (0-1) and Linear Depth (view-space Z) formats.
 * Auto-detection: Device-Z is always in [0,1], Linear Depth is always > 1
 */
[numthreads(THREADGROUP_SIZE_X, THREADGROUP_SIZE_Y, 1)]
void ProjectFluidShadowCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    // Bounds check
    if (any(DispatchThreadId.xy >= uint2(HistoryTextureSize)))
    {
        return;
    }

    int2 PixelCoord = int2(DispatchThreadId.xy);

    // Read history depth (could be Device-Z or Linear Depth)
    float RawDepth = HistoryDepthTexture.Load(int3(PixelCoord, 0));

    // Auto-detect depth format and convert to Device-Z
    float DeviceZ;

    if (RawDepth > LINEAR_DEPTH_DETECTION_THRESH)
    {
        // Linear Depth format (positive values, view-space Z distance)
        // Skip background pixels (Linear Depth background is very large, e.g., MAX_flt)
        if (RawDepth > BACKGROUND_LINEAR_THRESH)
        {
            return;
        }

        // Convert Linear Depth to Device-Z
        // FluidDepth.usf calculates: DeviceZ = ClipPos.z / ClipPos.w
        // where ClipPos.w = ViewPos.z = -LinearDepth (if -Z is forward)
        // So: DeviceZ = NearPlane / (-LinearDepth) = -NearPlane / LinearDepth
        // But if LinearDepth > 0, we need: DeviceZ = NearPlane / LinearDepth
        DeviceZ = saturate(NearPlane / RawDepth);
    }
    else if (RawDepth < -LINEAR_DEPTH_DETECTION_THRESH)
    {
        // Linear Depth format with NEGATIVE values (if +Z is forward in view space)
        // UE5 View Space: +Z forward means IntersectionPoint.z > 0
        // LinearDepth = -IntersectionPoint.z < 0 (negative)
        // Skip background: background is cleared to MAX_flt (positive), so negatives are always fluid

        // Convert negative Linear Depth to Device-Z
        // DeviceZ = NearPlane / IntersectionPoint.z = NearPlane / (-LinearDepth) = -NearPlane / LinearDepth
        // Since LinearDepth < 0: -NearPlane / LinearDepth = NearPlane / |LinearDepth|
        DeviceZ = saturate(-NearPlane / RawDepth);
    }
    else
    {
        // Device-Z format (0=far, 1=near in reversed-Z)
        // Skip background pixels (Device-Z near 0.0 means far/background)
        if (RawDepth <= BACKGROUND_DEVICEZ_THRESH)
        {
            return;
        }

        DeviceZ = RawDepth;
    }

    // Calculate screen UV
    float2 ScreenUV = (float2(PixelCoord) + 0.5f) / HistoryTextureSize;

    // Reconstruct world position using Device-Z
    float3 WorldPos = ReconstructWorldPosition(ScreenUV, DeviceZ);

    // Project to light space
    float2 LightUV;
    float LightDepth;
    if (!ProjectToLightSpace(WorldPos, LightUV, LightDepth))
    {
        return; // Outside light frustum
    }

    // Calculate VSM pixel coordinate
    int2 VSMCoord = int2(LightUV * VSMTextureSize);

    // Bounds check for VSM
    if (any(VSMCoord < 0) || any(VSMCoord >= int2(VSMTextureSize)))
    {
        return;
    }

    // Atomic max-depth update for reversed-Z
    // In reversed-Z: closer objects have larger depth values (1=near, 0=far)
    // We want the closest depth (largest value) for shadow casting
    uint EncodedDepth = EncodeDepthToUint(LightDepth);
    uint OldValue;
    InterlockedMax(DepthAtomicBuffer[VSMCoord], EncodedDepth, OldValue);

    // Note: VSM values (depth, depth²) are computed in a separate finalization pass
    // because we need the final min depth first before computing variance
}

/**
 * Finalization pass: Convert atomic depth buffer to VSM format.
 *
 * Reads the min depth from atomic buffer and writes (depth, depth²) to VSM.
 */
[numthreads(THREADGROUP_SIZE_X, THREADGROUP_SIZE_Y, 1)]
void FinalizeVSMCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    // Bounds check
    if (any(DispatchThreadId.xy >= uint2(VSMTextureSize)))
    {
        return;
    }

    int2 Coord = int2(DispatchThreadId.xy);

    // Read atomic depth
    uint EncodedDepth = DepthAtomicBuffer[Coord];

    // Check if any fluid was written (initial value is 0 for max operation)
    if (EncodedDepth == 0)
    {
        // No fluid at this pixel - write far depth (0 in reversed-Z)
        VSMTexture[Coord] = float2(1.0f, 1.0f);
        return;
    }

    // Decode depth
    float Depth = DecodeUintToDepth(EncodedDepth);

    // Write VSM: (depth, depth²)
    VSMTexture[Coord] = float2(Depth, Depth * Depth);
}

/**
 * Clear pass: Initialize atomic buffer to zero for max operation.
 */
[numthreads(THREADGROUP_SIZE_X, THREADGROUP_SIZE_Y, 1)]
void ClearAtomicBufferCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    if (any(DispatchThreadId.xy >= uint2(VSMTextureSize)))
    {
        return;
    }

    // Initialize to 0 (represents far plane in reversed-Z for max operation)
    DepthAtomicBuffer[int2(DispatchThreadId.xy)] = 0;
}
