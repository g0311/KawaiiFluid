// Copyright 2026 Team_Bruteforce. All Rights Reserved.

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidCommon.ush"

// -----------------------------------------------------------------------------
// Parameters
// -----------------------------------------------------------------------------
Texture2D<float> FluidDepthTexture;
Texture2D<float4> FluidNormalTexture;
Texture2D<float> FluidThicknessTexture;
Texture2D<float> OcclusionMaskTexture;  // 1.0 = visible, 0.0 = occluded by scene geometry
Texture2D<float> SceneDepthTexture;
Texture2D<float4> SceneColorTexture;

SamplerState InputSampler;
SamplerState PointClampSampler;  // Point sampling for depth textures to avoid edge interpolation artifacts

// UV scaling for SceneColor/SceneDepth (ViewRect / TextureSize)
// Needed when texture size differs from ViewRect (e.g., Screen Percentage)
float2 SceneUVScale;

float4x4 InverseProjectionMatrix;
float4x4 ProjectionMatrix;
float4x4 ViewMatrix;

float4 FluidColor;
float FresnelStrength;
float RefractiveIndex;
float Opacity;                       // Fluid opacity (0 = transparent, 1 = opaque)
float4 AbsorptionColorCoefficients;  // Per-channel absorption coefficients (Beer's Law)
float SpecularStrength;
float SpecularRoughness;
float AmbientIntensity;  // SkyLight contribution scale (default 0.15)
float LightingScale;     // Overall lighting scale for HDR compensation (default 0.2)

// -----------------------------------------------------------------------------
// Multi-Light Support
// Packed as float4 arrays for shader compatibility:
// - LightDirectionsAndIntensity[i] = (Direction.xyz, Intensity)
// - LightColors[i] = (Color.rgb, unused)
// -----------------------------------------------------------------------------
#define FLUID_MAX_LIGHTS 8

int NumLights;  // Number of active lights (0 = use View.DirectionalLight fallback)
float4 LightDirectionsAndIntensity[FLUID_MAX_LIGHTS];
float4 LightColors[FLUID_MAX_LIGHTS];

// Lighting Scale Parameters
float ThicknessSensitivity;          // How much thickness affects transparency (0 = uniform, 1 = thickness-dependent)
float FresnelReflectionBlend;

// Refraction
int bEnableRefraction;               // 1 = enabled, 0 = disabled
float RefractionScale;

// Caustics
int bEnableCaustics;                 // 1 = enabled, 0 = disabled
float CausticIntensity;              // Brightness multiplier for caustic patterns

// Reflection Cubemap
TextureCube ReflectionCubemap;
SamplerState ReflectionCubemapSampler;
float ReflectionIntensity;
float ReflectionMipLevel;
int bUseReflectionCubemap;

// Reflection Mode (0=None, 1=Cubemap, 2=ScreenSpaceReflection, 3=SSR+Cubemap)
int ReflectionMode;
int ScreenSpaceReflectionMaxSteps;
float ScreenSpaceReflectionStepSize;
float ScreenSpaceReflectionThickness;
float ScreenSpaceReflectionIntensity;
float ScreenSpaceReflectionEdgeFade;
int ScreenSpaceReflectionDebugMode;
float2 ViewportSize;

// -----------------------------------------------------------------------------
// Vertex Shader
// -----------------------------------------------------------------------------
struct FCompositeVSToPS
{
	float4 Position : SV_POSITION;
	float2 UV : TEXCOORD0;
};

void MainVS(
	in uint VertexID : SV_VertexID,
	out FCompositeVSToPS Output
)
{
	// Fullscreen Triangle
	float2 UV = float2((VertexID << 1) & 2, VertexID & 2);
	Output.UV = UV;
	Output.Position = float4(UV * float2(2, -2) + float2(-1, 1), 0.5f, 1.0f);
}

// -----------------------------------------------------------------------------
// Helper Functions
// -----------------------------------------------------------------------------

// Background depth threshold (no fluid at very far distances)
#define BACKGROUND_DEPTH_THRESH 100000.0f

/**
 * Reconstruct view space position from screen UV and linear depth.
 * Wrapper for shared function in FluidCommon.ush using global InverseProjectionMatrix.
 */
float3 ReconstructViewPosition(float2 ScreenUV, float LinearDepth)
{
	return ReconstructViewPositionFromDepth(ScreenUV, LinearDepth, InverseProjectionMatrix);
}

/**
 * Project view space position to screen UV.
 * Wrapper for shared function in FluidCommon.ush using global ProjectionMatrix.
 */
float2 ProjectToScreenUV(float3 ViewPos)
{
	return ProjectViewPositionToScreenUV(ViewPos, ProjectionMatrix);
}

// -----------------------------------------------------------------------------
// Volume Scattering Functions
// -----------------------------------------------------------------------------

/**
 * Henyey-Greenstein Phase Function.
 * Models the angular distribution of scattered light.
 *
 * @param CosTheta - Cosine of angle between view and light directions (dot(V, -L))
 * @param g - Anisotropy parameter: -1 = backscatter, 0 = isotropic, +1 = forward scatter
 * @return Phase function value (probability density)
 */
float HenyeyGreenstein(float CosTheta, float g)
{
	// Prevent division by zero when g approaches ±1
	float g2 = g * g;
	float denom = 1.0 + g2 - 2.0 * g * CosTheta;

	// Avoid numerical issues
	denom = max(denom, 0.0001);

	return (1.0 - g2) / (4.0 * PI * pow(denom, 1.5));
}

/**
 * Schlick Phase Function (faster approximation of Henyey-Greenstein).
 * Use when performance is critical.
 *
 * @param CosTheta - Cosine of angle between view and light directions
 * @param g - Anisotropy parameter
 * @return Phase function value
 */
float SchlickPhase(float CosTheta, float g)
{
	float k = 1.55 * g - 0.55 * g * g * g;
	float tmp = 1.0 + k * CosTheta;
	return (1.0 - k * k) / (4.0 * PI * tmp * tmp + 0.0001);
}

// -----------------------------------------------------------------------------
// PBR Functions (Cook-Torrance BRDF)
// -----------------------------------------------------------------------------

/**
 * GGX/Trowbridge-Reitz Normal Distribution Function.
 * Models the statistical distribution of microfacet normals.
 *
 * @param NoH - Dot product of Normal and Half vector
 * @param Roughness - Surface roughness (0 = mirror, 1 = diffuse)
 * @return Distribution term D
 */
float D_GGX(float NoH, float Roughness)
{
	float a = Roughness * Roughness;
	float a2 = a * a;
	float NoH2 = NoH * NoH;

	float denom = NoH2 * (a2 - 1.0) + 1.0;
	return a2 / (PI * denom * denom + 0.0001);
}

/**
 * Schlick-GGX Geometry Function (single direction).
 * Models microfacet self-shadowing.
 *
 * @param NoX - Dot product (NoV or NoL)
 * @param Roughness - Surface roughness
 * @return Geometry term for one direction
 */
float G_SchlickGGX(float NoX, float Roughness)
{
	float r = Roughness + 1.0;
	float k = (r * r) / 8.0;  // Direct lighting remapping

	return NoX / (NoX * (1.0 - k) + k + 0.0001);
}

/**
 * Smith Geometry Function (combined view and light).
 * Combines shadowing from both view and light directions.
 *
 * @param NoV - Dot product of Normal and View direction
 * @param NoL - Dot product of Normal and Light direction
 * @param Roughness - Surface roughness
 * @return Combined geometry term G
 */
float G_Smith(float NoV, float NoL, float Roughness)
{
	return G_SchlickGGX(NoV, Roughness) * G_SchlickGGX(NoL, Roughness);
}

/**
 * Fresnel-Schlick approximation.
 *
 * For direct lighting (point/directional), CosTheta should be HoV (Half·View).
 * This is physically correct for microfacet theory where each microfacet
 * reflects light along the half vector direction.
 *
 * @param CosTheta - Typically dot(HalfVector, ViewDir) for direct lighting
 * @param F0 - Reflectance at normal incidence
 * @return Fresnel reflectance
 */
float3 F_Schlick(float CosTheta, float3 F0)
{
	return F0 + (1.0 - F0) * pow(saturate(1.0 - CosTheta), 5.0);
}

/**
 * Cook-Torrance Specular BRDF.
 * Combines D, G, F terms for physically-based specular reflection.
 *
 * @param NoV - Normal dot View
 * @param NoL - Normal dot Light
 * @param NoH - Normal dot Half
 * @param HoV - Half dot View (for Fresnel)
 * @param Roughness - Surface roughness
 * @param F0 - Reflectance at normal incidence
 * @param OutFresnel - Output Fresnel term (for energy conservation)
 * @return Specular BRDF value
 */
float3 CookTorranceBRDF(float NoV, float NoL, float NoH, float HoV, float Roughness, float3 F0, out float3 OutFresnel)
{
	// Distribution
	float D = D_GGX(NoH, Roughness);

	// Geometry
	float G = G_Smith(NoV, NoL, Roughness);

	// Fresnel
	OutFresnel = F_Schlick(HoV, F0);

	// Cook-Torrance specular BRDF
	// f_spec = DGF / (4 * NoV * NoL)
	float3 numerator = D * G * OutFresnel;
	float denominator = 4.0 * NoV * NoL + 0.0001;

	return numerator / denominator;
}

// SSR debug global variables
static float g_SSRDebugLastRayDepth = 0;
static float g_SSRDebugLastSceneDepth = 0;
static int g_SSRDebugExitReason = 0;  // 0=max steps, 1=behind camera, 2=off screen
static float g_SSRDebugDepthPenetration = 0;

// -----------------------------------------------------------------------------
// Caustics (Jacobian Method)
// -----------------------------------------------------------------------------

/**
 * Calculate refracted ray hit position on floor plane using Snell's law.
 */
float2 CalculateRefractedFloorHit(float3 SurfacePos, float3 Normal, float3 ViewDir, float FloorZ, float IOR)
{
	// Snell's law: n1 * sin(theta1) = n2 * sin(theta2)
	float eta = 1.0 / IOR;

	float CosThetaI = dot(Normal, ViewDir);
	float Sin2ThetaT = eta * eta * (1.0 - CosThetaI * CosThetaI);

	// Total internal reflection check
	if (Sin2ThetaT > 1.0)
	{
		return SurfacePos.xy;
	}

	float CosThetaT = sqrt(1.0 - Sin2ThetaT);
	float3 RefractDir = eta * (-ViewDir) + (eta * CosThetaI - CosThetaT) * Normal;
	RefractDir = normalize(RefractDir);

	if (abs(RefractDir.z) < 0.001)
	{
		return SurfacePos.xy;
	}

	float t = (FloorZ - SurfacePos.z) / RefractDir.z;
	if (t < 0.0)
	{
		return SurfacePos.xy;
	}

	float3 HitPos = SurfacePos + t * RefractDir;
	return HitPos.xy;
}

/**
 * Calculate caustic intensity using Jacobian determinant.
 */
float CalculateCausticJacobian(
	float2 ScreenUV,
	float3 CenterNormal,
	float FluidDepth,
	float FloorDepth,
	float4x4 ViewMat,
	float IOR,
	float PixelOffset)
{
	float2 PixelSize = 1.0 / ViewportSize;
	float2 Offset = PixelSize * PixelOffset;

	float3x3 ViewToWorld = transpose((float3x3)ViewMat);

	float3 CenterViewPos = ReconstructViewPosition(ScreenUV, FluidDepth);
	float3 CenterWorldPos = mul(CenterViewPos, ViewToWorld);

	float3 CameraWorldPos = mul(float3(0, 0, 0), ViewToWorld);
	float3 ViewDir = normalize(CameraWorldPos - CenterWorldPos);

	float3 FloorViewPos = ReconstructViewPosition(ScreenUV, FloorDepth);
	float3 FloorWorldPos = mul(FloorViewPos, ViewToWorld);
	float FloorZ = FloorWorldPos.z;

	// 8-direction sampling
	const float Diag = 0.707;
	float2 Dirs[8] = {
		float2(1, 0), float2(Diag, Diag), float2(0, 1), float2(-Diag, Diag),
		float2(-1, 0), float2(-Diag, -Diag), float2(0, -1), float2(Diag, -Diag)
	};

	float2 SampleUVs[8];
	for (int i = 0; i < 8; i++)
	{
		SampleUVs[i] = saturate(ScreenUV + Dirs[i] * Offset);
	}

	// Bilinear sampling for smooth results
	float3 Normals[8];
	float Depths[8];
	int ValidCount = 0;

	for (int j = 0; j < 8; j++)
	{
		Normals[j] = FluidNormalTexture.SampleLevel(InputSampler, SampleUVs[j], 0).xyz;
		Depths[j] = FluidDepthTexture.SampleLevel(InputSampler, SampleUVs[j], 0).r;

		if (Depths[j] < BACKGROUND_DEPTH_THRESH && length(Normals[j]) > 0.1)
		{
			Normals[j] = normalize(Normals[j]);
			ValidCount++;
		}
	}

	float EdgeValidity = saturate((float(ValidCount) - 2.0) / 6.0);

	if (ValidCount < 3)
	{
		return 1.0;
	}

	float2 HitCenter = CalculateRefractedFloorHit(CenterWorldPos, CenterNormal, ViewDir, FloorZ, IOR);
	float2 Hits[8];
	float2 OrigPos[8];

	for (int k = 0; k < 8; k++)
	{
		if (Depths[k] < BACKGROUND_DEPTH_THRESH)
		{
			float3 WorldPos = mul(ReconstructViewPosition(SampleUVs[k], Depths[k]), ViewToWorld);
			Hits[k] = CalculateRefractedFloorHit(WorldPos, Normals[k], ViewDir, FloorZ, IOR);
			OrigPos[k] = WorldPos.xz;
		}
		else
		{
			Hits[k] = HitCenter;
			OrigPos[k] = CenterWorldPos.xz;
		}
	}

	// Cardinal Jacobian
	float2 dHit_du_cardinal = (Hits[0] - Hits[4]) / (2.0 * Offset.x);
	float2 dHit_dv_cardinal = (Hits[2] - Hits[6]) / (2.0 * Offset.y);
	float J_cardinal = abs(dHit_du_cardinal.x * dHit_dv_cardinal.y - dHit_du_cardinal.y * dHit_dv_cardinal.x);

	float2 dOrig_du_cardinal = (OrigPos[0] - OrigPos[4]) / (2.0 * Offset.x);
	float2 dOrig_dv_cardinal = (OrigPos[2] - OrigPos[6]) / (2.0 * Offset.y);
	float OrigJ_cardinal = abs(dOrig_du_cardinal.x * dOrig_dv_cardinal.y - dOrig_du_cardinal.y * dOrig_dv_cardinal.x);

	// Diagonal Jacobian
	float DiagScale = 1.414;
	float2 dHit_du_diag = (Hits[1] - Hits[5]) / (2.0 * Offset.x * DiagScale);
	float2 dHit_dv_diag = (Hits[3] - Hits[7]) / (2.0 * Offset.y * DiagScale);
	float J_diag = abs(dHit_du_diag.x * dHit_dv_diag.y - dHit_du_diag.y * dHit_dv_diag.x);

	float2 dOrig_du_diag = (OrigPos[1] - OrigPos[5]) / (2.0 * Offset.x * DiagScale);
	float2 dOrig_dv_diag = (OrigPos[3] - OrigPos[7]) / (2.0 * Offset.y * DiagScale);
	float OrigJ_diag = abs(dOrig_du_diag.x * dOrig_dv_diag.y - dOrig_du_diag.y * dOrig_dv_diag.x);

	float J = (J_cardinal + J_diag) * 0.5;
	float OrigJ = (OrigJ_cardinal + OrigJ_diag) * 0.5;

	float AreaRatio = OrigJ / max(J, 0.0001);
	AreaRatio = clamp(AreaRatio, 0.2, 5.0);

	float Caustic = smoothstep(0.3, 3.0, AreaRatio);
	float Brightness = lerp(0.7, 1.8, Caustic);

	return lerp(1.0, Brightness, EdgeValidity);
}

/**
 * Multi-scale caustic pattern using optical Jacobian.
 */
float CausticPattern(float2 ScreenUV, float3 Normal, float FluidDepth, float FloorDepth,
                     float4x4 ViewMat, float IOR)
{
	float C1 = CalculateCausticJacobian(ScreenUV, Normal, FluidDepth, FloorDepth, ViewMat, IOR, 3.0);
	float C2 = CalculateCausticJacobian(ScreenUV, Normal, FluidDepth, FloorDepth, ViewMat, IOR, 6.0);
	float C3 = CalculateCausticJacobian(ScreenUV, Normal, FluidDepth, FloorDepth, ViewMat, IOR, 12.0);

	float Combined = C1 * 0.25 + C2 * 0.35 + C3 * 0.4;

	return Combined - 1.0;
}

/**
 * Screen Space Reflection using perspective-correct ray march.
 */
float TraceSSR(float3 RayOrigin, float3 RayDir, out float2 OutHitUV, out float3 OutHitColor)
{
	OutHitUV = float2(0, 0);
	OutHitColor = float3(0, 0, 0);
	g_SSRDebugExitReason = 0;

	// Early exit if reflection points toward camera
	if (RayDir.z > 0.1)
	{
		g_SSRDebugExitReason = 1;
		return 0.0;
	}

	// Calculate ray end point
	float RayLength = abs(RayOrigin.z) * 4.0;
	float3 RayEnd = RayOrigin + RayDir * RayLength;

	// Clamp end point to not go behind camera
	if (RayEnd.z > -0.1)
	{
		float t = (-0.1 - RayOrigin.z) / (RayEnd.z - RayOrigin.z);
		RayEnd = RayOrigin + (RayEnd - RayOrigin) * max(t, 0.01);
	}

	// Project start and end to clip space
	float4 StartClip = mul(float4(RayOrigin, 1.0), ProjectionMatrix);
	float4 EndClip = mul(float4(RayEnd, 1.0), ProjectionMatrix);

	// Calculate screen UV for ray length estimation
	float2 StartUV = float2(
		StartClip.x / StartClip.w * 0.5 + 0.5,
		-StartClip.y / StartClip.w * 0.5 + 0.5
	);
	float2 EndUV = float2(
		EndClip.x / EndClip.w * 0.5 + 0.5,
		-EndClip.y / EndClip.w * 0.5 + 0.5
	);

	float2 RayUV = EndUV - StartUV;
	float RayScreenLen = length(RayUV * ViewportSize);

	if (RayScreenLen < 1.0)
	{
		return 0.0;
	}

	int StepCount = ScreenSpaceReflectionMaxSteps;
	float InvStepCount = 1.0 / float(StepCount);

	float StartDepth = -RayOrigin.z;
	float EndDepth = -RayEnd.z;

	float PrevRayDepth = StartDepth;
	float PrevSceneDepth = StartDepth;

	for (int i = 1; i <= StepCount; i++)
	{
		float t = float(i) * InvStepCount;

		// Correct perspective interpolation: lerp in clip space, then perspective divide
		float4 ClipPos = lerp(StartClip, EndClip, t);
		float2 UV = float2(
			ClipPos.x / ClipPos.w * 0.5 + 0.5,
			-ClipPos.y / ClipPos.w * 0.5 + 0.5
		);

		if (any(UV < 0.0) || any(UV > 1.0))
		{
			g_SSRDebugExitReason = 2;
			break;
		}

		// Depth: linear interpolation in view space (RayOrigin.z to RayEnd.z)
		float RayDepth = lerp(StartDepth, EndDepth, t);

		float2 SampleUV = UV * SceneUVScale;
		float SceneDeviceZ = SceneDepthTexture.SampleLevel(PointClampSampler, SampleUV, 0).r;
		float SceneDepth = ConvertFromDeviceZ(SceneDeviceZ);

		g_SSRDebugLastRayDepth = RayDepth;
		g_SSRDebugLastSceneDepth = SceneDepth;
		g_SSRDebugDepthPenetration = RayDepth - SceneDepth;

		if (SceneDepth > 50000.0)
		{
			PrevRayDepth = RayDepth;
			PrevSceneDepth = SceneDepth;
			continue;
		}

		bool bWasInFront = PrevRayDepth <= PrevSceneDepth;
		bool bNowBehind = RayDepth > SceneDepth;

		if (bWasInFront && bNowBehind)
		{
			float Penetration = RayDepth - SceneDepth;
			float MaxThickness = ScreenSpaceReflectionThickness * SceneDepth * 0.05;

			if (Penetration < MaxThickness)
			{
				// Binary search refinement
				float tLo = float(i - 1) * InvStepCount;
				float tHi = t;
				float2 HitUV = UV;

				for (int j = 0; j < 8; j++)
				{
					float tMid = (tLo + tHi) * 0.5;

					// Clip space interpolation (same as main loop)
					float4 MidClip = lerp(StartClip, EndClip, tMid);
					float2 MidUV = float2(
						MidClip.x / MidClip.w * 0.5 + 0.5,
						-MidClip.y / MidClip.w * 0.5 + 0.5
					);
					float MidRayDepth = lerp(StartDepth, EndDepth, tMid);

					float2 MidSampleUV = MidUV * SceneUVScale;
					float MidSceneDepth = ConvertFromDeviceZ(
						SceneDepthTexture.SampleLevel(PointClampSampler, MidSampleUV, 0).r
					);

					if (MidRayDepth > MidSceneDepth)
					{
						tHi = tMid;
						HitUV = MidUV;
					}
					else
					{
						tLo = tMid;
					}
				}

				OutHitUV = HitUV;
				OutHitColor = SceneColorTexture.SampleLevel(InputSampler, HitUV * SceneUVScale, 0).rgb;

				float2 ScreenEdgeDist = min(HitUV, 1.0 - HitUV);
				float EdgeFade = saturate(min(ScreenEdgeDist.x, ScreenEdgeDist.y) / max(ScreenSpaceReflectionEdgeFade, 0.01));
				float DistFade = 1.0 - smoothstep(0.5, 1.0, t);
				float AngleFade = saturate(-RayDir.z * 2.5);

				return EdgeFade * DistFade * AngleFade;
			}
		}

		PrevRayDepth = RayDepth;
		PrevSceneDepth = SceneDepth;
	}

	return 0.0;
}

// -----------------------------------------------------------------------------
// Pixel Shader
// -----------------------------------------------------------------------------

void MainPS(
	FCompositeVSToPS Input,
	out float4 OutColor : SV_Target0)
{
	float2 UV = Input.UV;

	// SceneUV for sampling SceneColor/SceneDepth (handles Screen Percentage)
	float2 SceneUV = UV * SceneUVScale;

	// 1. Sample fluid depth (assumed to be linear depth)
	// Use point sampling to avoid edge interpolation artifacts (white border at fluid-mesh boundary)
	float FluidDepth = FluidDepthTexture.Sample(PointClampSampler, UV);

	// Handle background (no fluid)
	// FluidDepth is initialized to a very large value (e.g., 3.4e38)
	if (FluidDepth > BACKGROUND_DEPTH_THRESH)
	{
		discard;
		return;
	}

	// 2. Get scene depth (DeviceZ -> Linear)
	float SceneDeviceZ = SceneDepthTexture.SampleLevel(InputSampler, SceneUV, 0).r;
	float SceneLinearDepth = ConvertFromDeviceZ(SceneDeviceZ);

	// 3. Occlusion test - use precomputed OcclusionMask from FluidDepth pass
	// OcclusionMask: 1.0 = visible (in front of scene), 0.0 = occluded (behind scene)
	float OcclusionMask = OcclusionMaskTexture.SampleLevel(PointClampSampler, UV, 0).r;
	if (OcclusionMask < 0.5)
	{
		discard;
		return;
	}

	// 4. Sample fluid properties
	// Use point sampling to avoid edge interpolation artifacts at fluid boundary
	float3 Normal = FluidNormalTexture.Sample(PointClampSampler, UV).xyz;
	float Thickness = FluidThicknessTexture.Sample(PointClampSampler, UV).r;

	// Normal validation with proper NaN/Inf check
	bool bInvalidNormal = any(isnan(Normal)) || any(isinf(Normal)) || length(Normal) < 0.1f;
	if (bInvalidNormal)
	{
		Normal = float3(0, 0, 1);
	}
	else
	{
		Normal = normalize(Normal);
	}

	// 5. Prepare lighting calculations
	float3 ViewPos = ReconstructViewPosition(UV, FluidDepth);
	float3 ViewDir = normalize(-ViewPos);  // Direction toward camera (positive Z)

	// Ensure normal faces camera for lighting (dot > 0)
	// This is needed because FluidNormal.usf may output normals facing either direction
	if (dot(Normal, ViewDir) < 0.0)
	{
		Normal = -Normal;
	}

	// Grazing angle compensation for lighting stability
	float RawNoV = saturate(dot(Normal, ViewDir));
	float GrazingFade = smoothstep(0.0, 0.15, RawNoV);
	float3 LightingNormal = normalize(lerp(ViewDir, Normal, GrazingFade));

	// For SSR: Use the corrected normal directly
	// FluidNormal.usf now uses the same coordinate convention as this shader
	// (Y-axis flipped: UV.y=0 maps to ClipY=1)
	float3 ReflectionNormal = Normal;

	// A. PBR Setup
	// ========================================================================
	// F0 (base reflectivity at normal incidence):
	// Auto-calculate from IOR: F0 = ((1-n)/(1+n))^2 * FresnelStrength
	// Water (IOR=1.33): F0 ~ 0.02, Glass (IOR=1.5): F0 ~ 0.04
	// Fluids are dielectric (non-metallic), so F0 is uniform across RGB
	// ========================================================================
	float NoV = saturate(dot(LightingNormal, ViewDir));
	float IOR_Ratio = (1.0 - RefractiveIndex) / (1.0 + RefractiveIndex);
	float FinalF0 = IOR_Ratio * IOR_Ratio * FresnelStrength;
	float3 F0 = float3(FinalF0, FinalF0, FinalF0);

	// B. PBR Lighting (Cook-Torrance BRDF) - Multi-Light Support
	// ========================================================================
	// Loops over all active lights and accumulates Cook-Torrance contributions.
	// Each light needs its own half-vector and HoV for physically correct Fresnel.
	// Falls back to View.DirectionalLight if NumLights == 0.
	// ========================================================================

	// Roughness (clamp to avoid divide by zero in GGX)
	float Roughness = max(SpecularRoughness, 0.04);

	// Accumulated lighting results
	float3 TotalSpecular = float3(0, 0, 0);
	float3 TotalDiffuse = float3(0, 0, 0);

	// Determine effective light count (fallback to View.DirectionalLight if 0)
	int EffectiveLightCount = (NumLights > 0) ? NumLights : 1;

	for (int LightIndex = 0; LightIndex < EffectiveLightCount; LightIndex++)
	{
		float3 LightDir;
		float3 LightColor;

		if (NumLights > 0)
		{
			// Unpack light from float4 arrays
			// LightDirectionsAndIntensity[i] = (Direction.xyz, Intensity)
			// LightColors[i] = (Color.rgb, unused)
			float4 DirAndIntensity = LightDirectionsAndIntensity[LightIndex];
			float4 ColorPacked = LightColors[LightIndex];

			LightDir = normalize(-DirAndIntensity.xyz);
			float Intensity = DirAndIntensity.w;
			LightColor = ColorPacked.rgb * Intensity;
		}
		else
		{
			// Fallback: use View's main directional light
			LightDir = normalize(-View.DirectionalLightDirection);
			LightColor = View.DirectionalLightColor.rgb;
		}

		// Per-light dot products (use LightingNormal for stable shading)
		float NoL = saturate(dot(LightingNormal, LightDir));
		float3 HalfDir = normalize(LightDir + ViewDir);
		float NoH = saturate(dot(LightingNormal, HalfDir));
		float HoV = saturate(dot(HalfDir, ViewDir));

		// Cook-Torrance Specular BRDF
		// Each light has its own HoV for physically correct Fresnel
		float3 SpecularFresnel;
		float3 SpecularBRDF = CookTorranceBRDF(NoV, NoL, NoH, HoV, Roughness, F0, SpecularFresnel);
		TotalSpecular += SpecularBRDF * LightColor * NoL * SpecularStrength;

		// Energy Conservation: diffuse is reduced by specular reflection
		// kD = 1 - kS (for dielectrics, metallic = 0)
		float3 kD = 1.0 - SpecularFresnel;

		// Diffuse (Lambert with energy conservation)
		TotalDiffuse += kD * NoL * LightColor;
	}

	// Use accumulated specular (apply LightingScale to match diffuse)
	float3 Specular = TotalSpecular * LightingScale;

	// Ambient (prevents completely dark surfaces)
	// Use SkyLightColor if available, otherwise fallback to DirectionalLightColor, then fixed value
	// Scale by AmbientIntensity to prevent over-brightness (default 0.15 tuned for UE5 default SkyLight)
	float3 EnvironmentColor = View.SkyLightColor.rgb;
	if (dot(EnvironmentColor, float3(1, 1, 1)) < 0.001)
	{
		EnvironmentColor = View.DirectionalLightColor.rgb;
	}
	if (dot(EnvironmentColor, float3(1, 1, 1)) < 0.001)
	{
		EnvironmentColor = float3(1.0, 1.0, 1.0);  // White fallback
	}
	float3 AmbientColor = EnvironmentColor * AmbientIntensity;

	// Total Lighting (diffuse + ambient, specular added separately)
	// Apply LightingScale to compensate for HDR scene lighting
	float3 TotalLighting = (TotalDiffuse + AmbientColor) * LightingScale;

	// Fresnel for environment reflection (IBL/Cubemap/SSR)
	// ========================================================================
	// Unlike direct lighting which uses HoV (Half·View), environment reflection
	// uses NoV (Normal·View) as an approximation. This is because:
	// - Environment light comes from ALL directions, not a single light direction
	// - Therefore, no single half-vector can be defined
	// - NoV approximation is the industry standard (UE4/5, Unity, Frostbite)
	// - Reference: "Real Shading in Unreal Engine 4" (Brian Karis, SIGGRAPH 2013)
	// ========================================================================
	float Fresnel = F0.r + (1.0 - F0.r) * pow(1.0 - NoV, 5.0);

	// C. Volume Scattering (Light-based, Henyey-Greenstein)
	// ========================================================================
	// Physical scattering: light scatters through fluid based on View-Light angle.
	// All parameters derived from existing fluid properties:
	// - ScatterColor = FluidColor (fluid's intrinsic color)
	// - Anisotropy = derived from Opacity (transparent=forward, opaque=isotropic)
	// - Strength = ThicknessSensitivity
	// ========================================================================
	float3 VolumeScatterContribution = float3(0, 0, 0);

	// Scattering parameters derived from existing properties
	// Transparent fluids (low Opacity) → forward scatter (g=0.8)
	// Opaque fluids (high Opacity) → isotropic scatter (g=0.2)
	float ScatterAnisotropy = lerp(0.8, 0.2, Opacity);
	float3 ScatterColor = FluidColor.rgb;
	float ScatterStrength = ThicknessSensitivity;

	if (ScatterStrength > 0.001)
	{
		// Loop through lights for scattering calculation
		int ScatterLightCount = (NumLights > 0) ? NumLights : 1;

		for (int ScatterLightIndex = 0; ScatterLightIndex < ScatterLightCount; ScatterLightIndex++)
		{
			float3 ScatterLightDir;
			float3 ScatterLightColor;

			if (NumLights > 0)
			{
				float4 DirAndIntensity = LightDirectionsAndIntensity[ScatterLightIndex];
				float4 ColorPacked = LightColors[ScatterLightIndex];
				ScatterLightDir = normalize(-DirAndIntensity.xyz);
				ScatterLightColor = ColorPacked.rgb * DirAndIntensity.w;
			}
			else
			{
				ScatterLightDir = normalize(-View.DirectionalLightDirection);
				ScatterLightColor = View.DirectionalLightColor.rgb;
			}

			// VoL: View dot Light (positive when looking toward light source)
			// When camera looks at light source: VoL > 0 (backlit, forward scatter visible)
			float VoL = dot(ViewDir, -ScatterLightDir);

			// Phase function: probability of scattering in this direction
			float Phase = HenyeyGreenstein(VoL, ScatterAnisotropy);

			// Extinction: light scattered along path through fluid
			float Extinction = 1.0 - exp(-Thickness * ScatterStrength * 0.1);

			// Accumulate scattering contribution
			VolumeScatterContribution += ScatterColor * ScatterLightColor * Phase * Extinction;
		}
	}

	// Apply LightingScale to volume scattering as well
	VolumeScatterContribution *= LightingScale;

	// ========================================================================
	// Color Compositing (Flex-style Simple Approach)
	// ========================================================================
	float3 FinalColor;

	// 1. Sample scene color (background) - use SceneUV for correct texture mapping
	float3 SceneColor = SceneColorTexture.Sample(InputSampler, SceneUV).rgb;

	// 2. Sample refracted background color
	float3 RefractedBackground;
	float RefractedSceneDepth = SceneLinearDepth;
	float RefractionValidity = 0.0;

	if (bEnableRefraction)
	{
		// Refraction Mask: Reduce refraction at thin/edge areas to prevent excessive distortion
		// - ThicknessMask: Weaker refraction in thin areas
		// - EdgeMask: Weaker refraction at edges (where Normal.z is small)
		float ThicknessMask = saturate(Thickness * 0.1);
		float EdgeMask = saturate(abs(Normal.z) * 2.0);
		float RefractionMask = ThicknessMask * EdgeMask;

		// Calculate refraction offset (with thickness/edge mask)
		float2 RefractOffset = Normal.xy * RefractiveIndex * RefractionScale * RefractionMask;
		float2 RefractedUV = UV + RefractOffset;
		RefractedUV = saturate(RefractedUV);

		// Apply SceneUVScale to refracted UV for scene texture sampling
		float2 RefractedSceneUV = RefractedUV * SceneUVScale;

		// Check depth at refracted UV position
		RefractedSceneDepth = ConvertFromDeviceZ(SceneDepthTexture.SampleLevel(InputSampler, RefractedSceneUV, 0).r);

		// Soft refraction validity check:
		// 1. Refracted position must be behind fluid (not sampling objects in front of fluid)
		// 2. Refracted position should not suddenly show much closer objects than original UV
		// 3. Fade out refraction near screen edges (avoid sampling clamped edge pixels)
		float DepthMargin = 20.0;
		float BehindFluidFactor = saturate((RefractedSceneDepth - FluidDepth + DepthMargin) / DepthMargin);
		float NotPullingForwardFactor = saturate((RefractedSceneDepth - SceneLinearDepth + DepthMargin) / DepthMargin);

		// Screen edge fade: reduce refraction when refracted UV approaches screen boundary
		float2 EdgeDist = min(RefractedUV, 1.0 - RefractedUV);
		float ScreenEdgeFade = saturate(min(EdgeDist.x, EdgeDist.y) / 0.05);

		RefractionValidity = BehindFluidFactor * NotPullingForwardFactor * ScreenEdgeFade;

		// Soft blend between original UV and refracted UV, then apply SceneUVScale
		float2 FinalRefractUV = lerp(UV, RefractedUV, RefractionValidity);
		float2 FinalRefractSceneUV = FinalRefractUV * SceneUVScale;

		RefractedBackground = SceneColorTexture.Sample(InputSampler, FinalRefractSceneUV).rgb;
	}
	else
	{
		// No refraction - use original scene color
		RefractedBackground = SceneColor;
	}

	// 2.5. Caustics (Jacobian method - ray convergence = bright, divergence = dark)
	float CausticBrightness = 1.0;
	if (bEnableCaustics)
	{
		float Pattern = CausticPattern(
			UV,
			Normal,
			FluidDepth,
			RefractedSceneDepth,
			ViewMatrix,
			RefractiveIndex
		);

		// Convert pattern to brightness multiplier (CausticIntensity controls strength)
		CausticBrightness = 1.0 + Pattern * CausticIntensity;

		// Fade based on fluid properties
		float DepthFade = saturate(1.0 - FluidDepth * 0.0003);
		float ThicknessFade = exp(-Thickness * 0.015);
		float TransparencyFade = saturate(1.0 - Opacity * 0.7);
		float CausticFade = DepthFade * ThicknessFade * TransparencyFade * RefractionValidity;

		CausticBrightness = lerp(1.0, CausticBrightness, CausticFade);
	}

	// Apply caustics to refracted background
	RefractedBackground *= CausticBrightness;

	// 3. Beer's Law: Calculate per-channel transmittance based on thickness
	// T(λ) = exp(-σ(λ) * thickness)
	// Each color channel has different absorption coefficient
	// Water: absorbs more R -> appears blue
	// Slime: absorbs more B -> appears green/yellow
	// Convert Opacity (0~1) to absorption coefficient (1.0 ~ 5.0)
	float AbsorptionCoefficient = 1.0 + Opacity * 4.0;
	float3 AbsorptionRGB = AbsorptionColorCoefficients.rgb * AbsorptionCoefficient;
	float3 Transmittance = exp(-AbsorptionRGB * Thickness * 0.1f);  // 0.1 = constant scale factor

	// Calculate transmitted background color
	float3 TransmittedBackground = RefractedBackground * Transmittance;

	// 4. Blend background with fluid color
	// Thicker fluid shows more of its intrinsic color
	float OverallAbsorption = 1.0 - dot(Transmittance, float3(0.333, 0.333, 0.333));

	// Apply lighting to FluidColor (PBR Diffuse + Ambient)
	float3 LitFluidColor = FluidColor.rgb * TotalLighting;
	float3 BaseColor = lerp(TransmittedBackground, LitFluidColor, saturate(OverallAbsorption));

	// 5. Fresnel Reflection (Mode-based)
	// ========================================================================
	// ReflectionMode:
	//   0 = None (no reflection)
	//   1 = Cubemap (environment map reflection)
	//   2 = ScreenSpaceReflection (SSR only, no fallback on miss)
	//   3 = SSR + Cubemap (SSR with Cubemap fallback on miss)
	// ========================================================================
	float3 ViewSpaceReflect = reflect(-ViewDir, ReflectionNormal);
	float3 ReflectedColor = float3(0, 0, 0);
	float SSRHitStrength = 0.0;
	float SSRHitRatio = 0.0;  // For Mode 3: stores SSR hit amount for blend interpolation
	float3 CubemapColorForBlend = float3(0, 0, 0);  // For Mode 3: Cubemap color before mixing
	float3 SSRColorForBlend = float3(0, 0, 0);      // For Mode 3: SSR color before mixing

	// Mode 2: Screen Space Reflection (SSR)
	if (ReflectionMode == 2)
	{
		float2 SSRHitUV;
		float3 SSRHitColor;
		SSRHitStrength = TraceSSR(ViewPos, ViewSpaceReflect, SSRHitUV, SSRHitColor);

		// DEBUG: SSR debug visualization (runtime switchable via ScreenSpaceReflectionDebugMode)
		// 0 = disabled, 1 = hit/miss, 2 = reflection direction, 3 = hit sample color
		// 4 = reflection Z direction (green=into scene, red=toward camera)
		// 5 = ray depth vs scene depth comparison
		// 6 = exit reason (red=behind camera, green=off screen, blue=max steps)
		// 7 = Normal visualization, 8 = ViewDir visualization, 9 = ViewPos.z visualization
		if (ScreenSpaceReflectionDebugMode == 1)
		{
			// SSR hit/miss: red = hit (intensity varies), blue = miss
			if (SSRHitStrength > 0.0)
			{
				OutColor = float4(SSRHitStrength, 0, 0, 1);  // Red intensity = hit strength
			}
			else
			{
				OutColor = float4(0, 0, 1, 1);  // Blue: Miss
			}
			return;
		}
		else if (ScreenSpaceReflectionDebugMode == 2)
		{
			// Reflection vector direction as color (RGB = XYZ, 0.5 = 0)
			OutColor = float4(ViewSpaceReflect * 0.5 + 0.5, 1.0);
			return;
		}
		else if (ScreenSpaceReflectionDebugMode == 3)
		{
			// Direct display of hit color (magenta if miss)
			if (SSRHitStrength > 0.0)
			{
				OutColor = float4(SSRHitColor, 1.0);
			}
			else
			{
				OutColor = float4(1, 0, 1, 1);  // Magenta: Miss
			}
			return;
		}
		else if (ScreenSpaceReflectionDebugMode == 4)
		{
			// Reflection direction Z component visualization
			// Green = into scene (Z < 0, SSR possible)
			// Red = toward camera (Z > 0, SSR not possible)
			float ReflectZ = ViewSpaceReflect.z;
			if (ReflectZ < 0.0)
			{
				// Into scene - SSR possible (green, intensity shows depth)
				OutColor = float4(0, saturate(-ReflectZ), 0, 1);
			}
			else
			{
				// Toward camera - SSR not possible (red)
				OutColor = float4(saturate(ReflectZ), 0, 0, 1);
			}
			return;
		}
		else if (ScreenSpaceReflectionDebugMode == 5)
		{
			// Depth penetration visualization
			// Yellow = hit, Green = penetrated, Blue = not yet penetrated
			if (SSRHitStrength > 0.0)
			{
				OutColor = float4(1, 1, 0, 1);  // Yellow: Hit
			}
			else
			{
				float g = saturate(g_SSRDebugDepthPenetration / 50.0);  // Penetrated (green)
				float b = (g_SSRDebugDepthPenetration < 0.0) ? saturate(-g_SSRDebugDepthPenetration / 50.0) : 0.0;  // Not yet (blue)
				OutColor = float4(0, g, b, 1);
			}
			return;
		}
		else if (ScreenSpaceReflectionDebugMode == 6)
		{
			// Exit reason visualization
			if (SSRHitStrength > 0.0)
			{
				OutColor = float4(1, 1, 0, 1);  // Yellow: Hit
			}
			else if (g_SSRDebugExitReason == 1)
			{
				OutColor = float4(1, 0, 0, 1);  // Red: went behind camera
			}
			else if (g_SSRDebugExitReason == 2)
			{
				OutColor = float4(0, 1, 0, 1);  // Green: went off screen
			}
			else
			{
				OutColor = float4(0, 0, 1, 1);  // Blue: max steps reached
			}
			return;
		}
		else if (ScreenSpaceReflectionDebugMode == 7)
		{
			// Normal visualization (RGB = XYZ, 0.5 = 0)
			OutColor = float4(Normal * 0.5 + 0.5, 1.0);
			return;
		}
		else if (ScreenSpaceReflectionDebugMode == 8)
		{
			// ViewDir visualization (RGB = XYZ, 0.5 = 0)
			OutColor = float4(ViewDir * 0.5 + 0.5, 1.0);
			return;
		}
		else if (ScreenSpaceReflectionDebugMode == 9)
		{
			// ViewPos.z visualization (blue = in front of camera, red = behind camera)
			if (ViewPos.z < 0.0)
			{
				OutColor = float4(0, 0, saturate(-ViewPos.z / 1000.0), 1);  // Blue: in front
			}
			else
			{
				OutColor = float4(saturate(ViewPos.z / 1000.0), 0, 0, 1);  // Red: behind (incorrect)
			}
			return;
		}
		else if (ScreenSpaceReflectionDebugMode == 10)
		{
			// Fresnel value visualization (white = high fresnel, black = low)
			OutColor = float4(Fresnel, Fresnel, Fresnel, 1.0);
			return;
		}
		else if (ScreenSpaceReflectionDebugMode == 11)
		{
			// Parameter debug: R = FresnelStrength/10, G = FresnelReflectionBlend, B = Fresnel
			OutColor = float4(FresnelStrength / 10.0, FresnelReflectionBlend, Fresnel, 1.0);
			return;
		}
		else if (ScreenSpaceReflectionDebugMode == 12)
		{
			// Final reflection blend factor: Fresnel * FresnelReflectionBlend
			float BlendFactor = Fresnel * FresnelReflectionBlend;
			OutColor = float4(BlendFactor, BlendFactor, BlendFactor, 1.0);
			return;
		}
		else if (ScreenSpaceReflectionDebugMode == 13)
		{
			// SSR hit analysis (depth-only)
			// Yellow = HIT
			// Blue = ray in front of scene (not penetrated yet)
			// Red = penetrated but overshot (too far past geometry)
			// Green = sky/background (ray ended in empty space)
			if (SSRHitStrength > 0.0)
			{
				OutColor = float4(1, 1, 0, 1);  // Yellow: HIT!
			}
			else
			{
				bool bIsSky = g_SSRDebugLastSceneDepth > 50000.0;
				float Penetration = g_SSRDebugDepthPenetration;
				float MaxPenetration = ScreenSpaceReflectionThickness * g_SSRDebugLastSceneDepth * 0.1;

				if (bIsSky)
				{
					OutColor = float4(0, 0.5, 0, 1);  // Dark Green: sky
				}
				else if (Penetration <= 0.0)
				{
					OutColor = float4(0, 0, 1, 1);  // Blue: not penetrated
				}
				else if (Penetration > MaxPenetration)
				{
					OutColor = float4(1, 0, 0, 1);  // Red: overshot
				}
				else
				{
					OutColor = float4(1, 0, 1, 1);  // Magenta: bug
				}
			}
			return;
		}
		else if (ScreenSpaceReflectionDebugMode == 14)
		{
			// SSR hit UV visualization
			// R = hit UV.x, G = hit UV.y, B = hit strength
			// This shows WHERE the SSR is sampling from
			if (SSRHitStrength > 0.0)
			{
				OutColor = float4(SSRHitUV.x, SSRHitUV.y, SSRHitStrength, 1.0);
			}
			else
			{
				// No hit - show dark blue
				OutColor = float4(0, 0, 0.2, 1);
			}
			return;
		}

		// SSR result: use hit color if hit, otherwise no reflection (no fallback)
		// Note: ScreenSpaceReflectionIntensity is applied to blend factor, not color brightness
		// This allows SSR to have independent intensity control from FresnelReflectionBlend
		if (SSRHitStrength > 0.0)
		{
			ReflectedColor = SSRHitColor * SSRHitStrength;
		}
		// else: ReflectedColor stays at 0 (no Cubemap fallback)
	}
	// Mode 3: SSR + Cubemap (SSR hit → scene color, SSR miss → Cubemap fallback)
	else if (ReflectionMode == 3)
	{
		float2 SSRHitUV;
		float3 SSRHitColor;
		float SSRHit = TraceSSR(ViewPos, ViewSpaceReflect, SSRHitUV, SSRHitColor);

		// Get Cubemap color for fallback
		float3 CubemapColor;
		float3x3 ViewToWorld = transpose((float3x3)ViewMatrix);
		float3 WorldReflect = mul(ViewSpaceReflect, ViewToWorld);

		if (bUseReflectionCubemap > 0)
		{
			float MipLevel = ReflectionMipLevel + SpecularRoughness * 6.0;
			CubemapColor = ReflectionCubemap.SampleLevel(ReflectionCubemapSampler, WorldReflect, MipLevel).rgb;
			CubemapColor *= ReflectionIntensity;
		}
		else
		{
			float3 FallbackEnvColor = View.SkyLightColor.rgb;
			if (dot(FallbackEnvColor, float3(1, 1, 1)) < 0.001)
			{
				FallbackEnvColor = View.DirectionalLightColor.rgb;
			}
			if (dot(FallbackEnvColor, float3(1, 1, 1)) < 0.001)
			{
				FallbackEnvColor = float3(1.0, 1.0, 1.0);
			}
			CubemapColor = FallbackEnvColor * 0.3;
		}

		// Store colors for separate blending (each with its own intensity)
		CubemapColorForBlend = CubemapColor;
		SSRColorForBlend = SSRHitColor;
		SSRHitRatio = SSRHit;

		// ReflectedColor not used for Mode 3 (handled separately in blend section)
		SSRHitStrength = 1.0;  // Always have reflection (either SSR or Cubemap)
	}
	// Mode 1: Cubemap Reflection
	else if (ReflectionMode == 1)
	{
		float3 CubemapColor;
		if (bUseReflectionCubemap > 0)
		{
			// View Space -> World Space transform (inverse of View Matrix)
			// ViewMatrix is World->View, so transpose gives View->World (orthogonal matrix)
			float3x3 ViewToWorld = transpose((float3x3)ViewMatrix);
			float3 WorldReflect = mul(ViewSpaceReflect, ViewToWorld);

			// Cubemap sampling (Mip level controls blur)
			float MipLevel = ReflectionMipLevel + SpecularRoughness * 6.0;  // Linked to roughness
			CubemapColor = ReflectionCubemap.SampleLevel(ReflectionCubemapSampler, WorldReflect, MipLevel).rgb;
			CubemapColor *= ReflectionIntensity;
		}
		else
		{
			// Fallback: use a dimmed environment light color for reflection
			float3 FallbackEnvColor = View.SkyLightColor.rgb;
			if (dot(FallbackEnvColor, float3(1, 1, 1)) < 0.001)
			{
				FallbackEnvColor = View.DirectionalLightColor.rgb;
			}
			if (dot(FallbackEnvColor, float3(1, 1, 1)) < 0.001)
			{
				FallbackEnvColor = float3(1.0, 1.0, 1.0);  // White fallback
			}
			CubemapColor = FallbackEnvColor * 0.3;
		}

		ReflectedColor = CubemapColor;
	}
	// Mode 0: No Reflection
	// ReflectedColor stays at 0

	// 6. Blend reflection with transmission
	// Fresnel determines how much reflection vs transmission (physically-based)
	// IMPORTANT: Only blend if we actually have reflection data
	// - Mode 0 (None): No blending
	// - Mode 1 (Cubemap): FresnelReflectionBlend controls blend
	// - Mode 2 (SSR): ScreenSpaceReflectionIntensity controls blend
	// - Mode 3 (SSR+Cubemap): Each uses its own intensity, then results are combined
	float ReflectionBlendFactor = Fresnel * FresnelReflectionBlend;
	if (ReflectionMode == 0)
	{
		ReflectionBlendFactor = 0.0;  // No reflection mode
	}
	else if (ReflectionMode == 2)
	{
		// SSR-only mode: use ScreenSpaceReflectionIntensity for independent control
		ReflectionBlendFactor = Fresnel * ScreenSpaceReflectionIntensity * SSRHitStrength;
	}
	// Mode 1 (Cubemap): use FresnelReflectionBlend (default)

	// Mode 3 special handling: blend each reflection type with its own intensity, then combine
	if (ReflectionMode == 3)
	{
		// Cubemap blended with its intensity (FresnelReflectionBlend)
		float3 CubemapResult = lerp(BaseColor, CubemapColorForBlend, Fresnel * FresnelReflectionBlend);
		// SSR blended with its intensity (ScreenSpaceReflectionIntensity)
		float3 SSRResult = lerp(BaseColor, SSRColorForBlend, Fresnel * ScreenSpaceReflectionIntensity);
		// Combine based on SSR hit ratio
		BaseColor = lerp(CubemapResult, SSRResult, SSRHitRatio);
	}
	else
	{
		BaseColor = lerp(BaseColor, ReflectedColor, ReflectionBlendFactor);
	}

	// 7. Add Specular + SSS
	FinalColor = BaseColor + Specular + VolumeScatterContribution;

	// 8. Apply PreExposure to match UE5 HDR pipeline
	// SceneColor already has PreExposure applied, so fluid must match
	// This ensures consistent brightness with other scene objects
	FinalColor *= View.PreExposure;

	// 9. Alpha calculation
	// Opacity: base opacity (minimum alpha)
	// ThicknessSensitivity: how steeply thickness adds opacity on top
	//   0 = thickness has no effect (use base Opacity only)
	//   1 = thickness strongly adds opacity (thick areas become opaque regardless of base Opacity)
	float BaseAlpha = Opacity;
	float ThicknessAlpha = saturate(1.0 - exp(-Thickness * ThicknessSensitivity * 5.0f));
	// Take the maximum: base opacity OR thickness-based opacity
	float Alpha = max(BaseAlpha, ThicknessAlpha);
	// Only boost alpha at grazing angles (high Fresnel), not everywhere
	// Use a softer contribution from Fresnel to avoid making thin fluid opaque
	float FresnelAlphaBoost = Fresnel * FresnelReflectionBlend * 0.3;  // Reduced from 1.0 to 0.3
	Alpha = max(Alpha, FresnelAlphaBoost);

	// C++ BlendState uses (SrcAlpha, InvSrcAlpha)
	// Output RGB without premultiplied alpha
	OutColor = float4(FinalColor, Alpha);
}
