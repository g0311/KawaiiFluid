// Copyright 2026 Team_Bruteforce. All Rights Reserved.

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidCommon.ush"

// -----------------------------------------------------------------------------
// Parameters
// -----------------------------------------------------------------------------
Texture2D<float> FluidDepthTexture;
Texture2D<float4> FluidNormalTexture;
Texture2D<float> FluidThicknessTexture;
Texture2D<float> OcclusionMaskTexture;  // 1.0 = visible, 0.0 = occluded by scene geometry
Texture2D<float> SceneDepthTexture;
Texture2D<float4> SceneColorTexture;

SamplerState InputSampler;
SamplerState PointClampSampler;  // Point sampling for depth textures to avoid edge interpolation artifacts

// UV scaling for SceneColor/SceneDepth (ViewRect / TextureSize)
// Needed when texture size differs from ViewRect (e.g., Screen Percentage)
float2 SceneUVScale;

float4x4 InverseProjectionMatrix;
float4x4 ProjectionMatrix;
float4x4 ViewMatrix;

float4 FluidColor;
float F0Override;
float FresnelStrength;
float RefractiveIndex;
float Opacity;                       // Fluid opacity (0 = transparent, 1 = opaque)
float4 AbsorptionColorCoefficients;  // Per-channel absorption coefficients (Beer's Law)
float SpecularStrength;
float SpecularRoughness;

// -----------------------------------------------------------------------------
// Multi-Light Support
// Packed as float4 arrays for shader compatibility:
// - LightDirectionsAndIntensity[i] = (Direction.xyz, Intensity)
// - LightColors[i] = (Color.rgb, unused)
// -----------------------------------------------------------------------------
#define FLUID_MAX_LIGHTS 8

int NumLights;  // Number of active lights (0 = use View.DirectionalLight fallback)
float4 LightDirectionsAndIntensity[FLUID_MAX_LIGHTS];
float4 LightColors[FLUID_MAX_LIGHTS];

// Lighting Scale Parameters
float ThicknessSensitivity;          // How much thickness affects transparency (0 = uniform, 1 = thickness-dependent)
float RefractionScale;
float FresnelReflectionBlend;

// Reflection Cubemap
TextureCube ReflectionCubemap;
SamplerState ReflectionCubemapSampler;
float ReflectionIntensity;
float ReflectionMipLevel;
int bUseReflectionCubemap;

// Screen Space Reflections (SSR)
int bEnableScreenSpaceReflection;
int ScreenSpaceReflectionMaxSteps;
float ScreenSpaceReflectionStepSize;
float ScreenSpaceReflectionThickness;
float ScreenSpaceReflectionIntensity;
float ScreenSpaceReflectionEdgeFade;
int ScreenSpaceReflectionDebugMode;
float2 ViewportSize;

// -----------------------------------------------------------------------------
// Vertex Shader
// -----------------------------------------------------------------------------
struct FCompositeVSToPS
{
	float4 Position : SV_POSITION;
	float2 UV : TEXCOORD0;
};

void MainVS(
	in uint VertexID : SV_VertexID,
	out FCompositeVSToPS Output
)
{
	// Fullscreen Triangle
	float2 UV = float2((VertexID << 1) & 2, VertexID & 2);
	Output.UV = UV;
	Output.Position = float4(UV * float2(2, -2) + float2(-1, 1), 0.5f, 1.0f);
}

// -----------------------------------------------------------------------------
// Helper Functions
// -----------------------------------------------------------------------------

// Background depth threshold (no fluid at very far distances)
#define BACKGROUND_DEPTH_THRESH 100000.0f

/**
 * Reconstruct view space position from screen UV and linear depth.
 * Wrapper for shared function in FluidCommon.ush using global InverseProjectionMatrix.
 */
float3 ReconstructViewPosition(float2 ScreenUV, float LinearDepth)
{
	return ReconstructViewPositionFromDepth(ScreenUV, LinearDepth, InverseProjectionMatrix);
}

/**
 * Project view space position to screen UV.
 * Wrapper for shared function in FluidCommon.ush using global ProjectionMatrix.
 */
float2 ProjectToScreenUV(float3 ViewPos)
{
	return ProjectViewPositionToScreenUV(ViewPos, ProjectionMatrix);
}

// -----------------------------------------------------------------------------
// Volume Scattering Functions
// -----------------------------------------------------------------------------

/**
 * Henyey-Greenstein Phase Function.
 * Models the angular distribution of scattered light.
 *
 * @param CosTheta - Cosine of angle between view and light directions (dot(V, -L))
 * @param g - Anisotropy parameter: -1 = backscatter, 0 = isotropic, +1 = forward scatter
 * @return Phase function value (probability density)
 */
float HenyeyGreenstein(float CosTheta, float g)
{
	// Prevent division by zero when g approaches ±1
	float g2 = g * g;
	float denom = 1.0 + g2 - 2.0 * g * CosTheta;

	// Avoid numerical issues
	denom = max(denom, 0.0001);

	return (1.0 - g2) / (4.0 * PI * pow(denom, 1.5));
}

/**
 * Schlick Phase Function (faster approximation of Henyey-Greenstein).
 * Use when performance is critical.
 *
 * @param CosTheta - Cosine of angle between view and light directions
 * @param g - Anisotropy parameter
 * @return Phase function value
 */
float SchlickPhase(float CosTheta, float g)
{
	float k = 1.55 * g - 0.55 * g * g * g;
	float tmp = 1.0 + k * CosTheta;
	return (1.0 - k * k) / (4.0 * PI * tmp * tmp + 0.0001);
}

// -----------------------------------------------------------------------------
// PBR Functions (Cook-Torrance BRDF)
// -----------------------------------------------------------------------------

/**
 * GGX/Trowbridge-Reitz Normal Distribution Function.
 * Models the statistical distribution of microfacet normals.
 *
 * @param NoH - Dot product of Normal and Half vector
 * @param Roughness - Surface roughness (0 = mirror, 1 = diffuse)
 * @return Distribution term D
 */
float D_GGX(float NoH, float Roughness)
{
	float a = Roughness * Roughness;
	float a2 = a * a;
	float NoH2 = NoH * NoH;

	float denom = NoH2 * (a2 - 1.0) + 1.0;
	return a2 / (PI * denom * denom + 0.0001);
}

/**
 * Schlick-GGX Geometry Function (single direction).
 * Models microfacet self-shadowing.
 *
 * @param NoX - Dot product (NoV or NoL)
 * @param Roughness - Surface roughness
 * @return Geometry term for one direction
 */
float G_SchlickGGX(float NoX, float Roughness)
{
	float r = Roughness + 1.0;
	float k = (r * r) / 8.0;  // Direct lighting remapping

	return NoX / (NoX * (1.0 - k) + k + 0.0001);
}

/**
 * Smith Geometry Function (combined view and light).
 * Combines shadowing from both view and light directions.
 *
 * @param NoV - Dot product of Normal and View direction
 * @param NoL - Dot product of Normal and Light direction
 * @param Roughness - Surface roughness
 * @return Combined geometry term G
 */
float G_Smith(float NoV, float NoL, float Roughness)
{
	return G_SchlickGGX(NoV, Roughness) * G_SchlickGGX(NoL, Roughness);
}

/**
 * Fresnel-Schlick approximation.
 *
 * For direct lighting (point/directional), CosTheta should be HoV (Half·View).
 * This is physically correct for microfacet theory where each microfacet
 * reflects light along the half vector direction.
 *
 * @param CosTheta - Typically dot(HalfVector, ViewDir) for direct lighting
 * @param F0 - Reflectance at normal incidence
 * @return Fresnel reflectance
 */
float3 F_Schlick(float CosTheta, float3 F0)
{
	return F0 + (1.0 - F0) * pow(saturate(1.0 - CosTheta), 5.0);
}

/**
 * Cook-Torrance Specular BRDF.
 * Combines D, G, F terms for physically-based specular reflection.
 *
 * @param NoV - Normal dot View
 * @param NoL - Normal dot Light
 * @param NoH - Normal dot Half
 * @param HoV - Half dot View (for Fresnel)
 * @param Roughness - Surface roughness
 * @param F0 - Reflectance at normal incidence
 * @param OutFresnel - Output Fresnel term (for energy conservation)
 * @return Specular BRDF value
 */
float3 CookTorranceBRDF(float NoV, float NoL, float NoH, float HoV, float Roughness, float3 F0, out float3 OutFresnel)
{
	// Distribution
	float D = D_GGX(NoH, Roughness);

	// Geometry
	float G = G_Smith(NoV, NoL, Roughness);

	// Fresnel
	OutFresnel = F_Schlick(HoV, F0);

	// Cook-Torrance specular BRDF
	// f_spec = DGF / (4 * NoV * NoL)
	float3 numerator = D * G * OutFresnel;
	float denominator = 4.0 * NoV * NoL + 0.0001;

	return numerator / denominator;
}

// SSR debug global variables
static float3 g_SSRDebugLastPos = float3(0, 0, 0);
static float g_SSRDebugLastRayDepth = 0;
static float g_SSRDebugLastSceneDepth = 0;
static int g_SSRDebugExitReason = 0;  // 0=max steps, 1=behind camera, 2=off screen
static float g_SSRDebugXYDistance = 0;  // XY distance between ray and scene
static float g_SSRDebugDepthPenetration = 0;  // How far ray penetrated past scene

// -----------------------------------------------------------------------------
// Caustics (Jacobian Method)
// -----------------------------------------------------------------------------

/**
 * Calculate refracted ray hit position on floor plane using Snell's law.
 */
float2 CalculateRefractedFloorHit(float3 SurfacePos, float3 Normal, float3 ViewDir, float FloorY, float IOR)
{
	// Snell's law: n1 * sin(theta1) = n2 * sin(theta2)
	float eta = 1.0 / IOR;

	float CosThetaI = dot(Normal, ViewDir);
	float Sin2ThetaT = eta * eta * (1.0 - CosThetaI * CosThetaI);

	// Total internal reflection check
	if (Sin2ThetaT > 1.0)
	{
		return SurfacePos.xz;
	}

	float CosThetaT = sqrt(1.0 - Sin2ThetaT);
	float3 RefractDir = eta * (-ViewDir) + (eta * CosThetaI - CosThetaT) * Normal;
	RefractDir = normalize(RefractDir);

	if (abs(RefractDir.y) < 0.001)
	{
		return SurfacePos.xz;
	}

	float t = (FloorY - SurfacePos.y) / RefractDir.y;
	if (t < 0.0)
	{
		return SurfacePos.xz;
	}

	float3 HitPos = SurfacePos + t * RefractDir;
	return HitPos.xz;
}

/**
 * Calculate caustic intensity using Jacobian determinant.
 */
float CalculateCausticJacobian(
	float2 ScreenUV,
	float3 CenterNormal,
	float FluidDepth,
	float FloorDepth,
	float4x4 ViewMat,
	float IOR,
	float PixelOffset)
{
	float2 PixelSize = 1.0 / ViewportSize;
	float2 Offset = PixelSize * PixelOffset;

	float3x3 ViewToWorld = transpose((float3x3)ViewMat);

	float3 CenterViewPos = ReconstructViewPosition(ScreenUV, FluidDepth);
	float3 CenterWorldPos = mul(CenterViewPos, ViewToWorld);

	float3 CameraWorldPos = mul(float3(0, 0, 0), ViewToWorld);
	float3 ViewDir = normalize(CameraWorldPos - CenterWorldPos);

	float3 FloorViewPos = ReconstructViewPosition(ScreenUV, FloorDepth);
	float3 FloorWorldPos = mul(FloorViewPos, ViewToWorld);
	float FloorY = FloorWorldPos.y;

	// 8-direction sampling
	const float Diag = 0.707;
	float2 Dirs[8] = {
		float2(1, 0), float2(Diag, Diag), float2(0, 1), float2(-Diag, Diag),
		float2(-1, 0), float2(-Diag, -Diag), float2(0, -1), float2(Diag, -Diag)
	};

	float2 SampleUVs[8];
	for (int i = 0; i < 8; i++)
	{
		SampleUVs[i] = saturate(ScreenUV + Dirs[i] * Offset);
	}

	// Bilinear sampling for smooth results
	float3 Normals[8];
	float Depths[8];
	int ValidCount = 0;

	for (int j = 0; j < 8; j++)
	{
		Normals[j] = FluidNormalTexture.SampleLevel(InputSampler, SampleUVs[j], 0).xyz;
		Depths[j] = FluidDepthTexture.SampleLevel(InputSampler, SampleUVs[j], 0).r;

		if (Depths[j] < BACKGROUND_DEPTH_THRESH && length(Normals[j]) > 0.1)
		{
			Normals[j] = normalize(Normals[j]);
			ValidCount++;
		}
	}

	float EdgeValidity = saturate((float(ValidCount) - 2.0) / 6.0);

	if (ValidCount < 3)
	{
		return 1.0;
	}

	float2 HitCenter = CalculateRefractedFloorHit(CenterWorldPos, CenterNormal, ViewDir, FloorY, IOR);
	float2 Hits[8];
	float2 OrigPos[8];

	for (int k = 0; k < 8; k++)
	{
		if (Depths[k] < BACKGROUND_DEPTH_THRESH)
		{
			float3 WorldPos = mul(ReconstructViewPosition(SampleUVs[k], Depths[k]), ViewToWorld);
			Hits[k] = CalculateRefractedFloorHit(WorldPos, Normals[k], ViewDir, FloorY, IOR);
			OrigPos[k] = WorldPos.xz;
		}
		else
		{
			Hits[k] = HitCenter;
			OrigPos[k] = CenterWorldPos.xz;
		}
	}

	// Cardinal Jacobian
	float2 dHit_du_cardinal = (Hits[0] - Hits[4]) / (2.0 * Offset.x);
	float2 dHit_dv_cardinal = (Hits[2] - Hits[6]) / (2.0 * Offset.y);
	float J_cardinal = abs(dHit_du_cardinal.x * dHit_dv_cardinal.y - dHit_du_cardinal.y * dHit_dv_cardinal.x);

	float2 dOrig_du_cardinal = (OrigPos[0] - OrigPos[4]) / (2.0 * Offset.x);
	float2 dOrig_dv_cardinal = (OrigPos[2] - OrigPos[6]) / (2.0 * Offset.y);
	float OrigJ_cardinal = abs(dOrig_du_cardinal.x * dOrig_dv_cardinal.y - dOrig_du_cardinal.y * dOrig_dv_cardinal.x);

	// Diagonal Jacobian
	float DiagScale = 1.414;
	float2 dHit_du_diag = (Hits[1] - Hits[5]) / (2.0 * Offset.x * DiagScale);
	float2 dHit_dv_diag = (Hits[3] - Hits[7]) / (2.0 * Offset.y * DiagScale);
	float J_diag = abs(dHit_du_diag.x * dHit_dv_diag.y - dHit_du_diag.y * dHit_dv_diag.x);

	float2 dOrig_du_diag = (OrigPos[1] - OrigPos[5]) / (2.0 * Offset.x * DiagScale);
	float2 dOrig_dv_diag = (OrigPos[3] - OrigPos[7]) / (2.0 * Offset.y * DiagScale);
	float OrigJ_diag = abs(dOrig_du_diag.x * dOrig_dv_diag.y - dOrig_du_diag.y * dOrig_dv_diag.x);

	float J = (J_cardinal + J_diag) * 0.5;
	float OrigJ = (OrigJ_cardinal + OrigJ_diag) * 0.5;

	float AreaRatio = OrigJ / max(J, 0.0001);
	AreaRatio = clamp(AreaRatio, 0.2, 5.0);

	float Caustic = smoothstep(0.3, 3.0, AreaRatio);
	float Brightness = lerp(0.7, 1.8, Caustic);

	return lerp(1.0, Brightness, EdgeValidity);
}

/**
 * Multi-scale caustic pattern using optical Jacobian.
 */
float CausticPattern(float2 ScreenUV, float3 Normal, float FluidDepth, float FloorDepth,
                     float4x4 ViewMat, float IOR)
{
	float C1 = CalculateCausticJacobian(ScreenUV, Normal, FluidDepth, FloorDepth, ViewMat, IOR, 3.0);
	float C2 = CalculateCausticJacobian(ScreenUV, Normal, FluidDepth, FloorDepth, ViewMat, IOR, 6.0);
	float C3 = CalculateCausticJacobian(ScreenUV, Normal, FluidDepth, FloorDepth, ViewMat, IOR, 12.0);

	float Combined = C1 * 0.25 + C2 * 0.35 + C3 * 0.4;

	return Combined - 1.0;
}

/**
 * Screen Space Reflection Ray March.
 *
 * Logic:
 * 1. Start at fluid surface position (RayOrigin) in view space
 * 2. March along reflection direction (RayDir)
 * 3. At each step, project position to screen UV
 * 4. Sample scene depth at that UV
 * 5. If ray depth > scene depth (ray passed behind geometry), it's a HIT
 * 6. Sample and return scene color at hit position
 *
 * @param RayOrigin - Ray start point in view space (fluid surface)
 * @param RayDir - Reflection direction in view space (normalized)
 * @param OutHitUV - Screen UV of hit location
 * @param OutHitColor - Scene color at hit location
 * @return Hit strength (0.0 ~ 1.0, with fade applied)
 */
float TraceSSR(float3 RayOrigin, float3 RayDir, out float2 OutHitUV, out float3 OutHitColor)
{
	OutHitUV = float2(0, 0);
	OutHitColor = float3(0, 0, 0);
	g_SSRDebugExitReason = 0;

	// Early exit if reflection points toward camera (can't reflect what's behind camera)
	if (RayDir.z > 0.05)
	{
		g_SSRDebugExitReason = 1;
		return 0.0;
	}

	// Step size calculation
	float StepSize = ScreenSpaceReflectionStepSize * abs(RayOrigin.z) * 0.002;
	StepSize = clamp(StepSize, 1.0, 50.0);

	// Ray march
	float3 CurrentPos = RayOrigin;
	float3 PrevPos = RayOrigin;
	float OriginDepth = -RayOrigin.z;

	for (int i = 1; i <= ScreenSpaceReflectionMaxSteps; i++)
	{
		PrevPos = CurrentPos;
		CurrentPos += RayDir * StepSize;

		// Exit if behind camera
		if (CurrentPos.z > 0.0)
		{
			g_SSRDebugExitReason = 1;
			break;
		}

		// Project to screen UV
		float4 ClipPos = mul(float4(CurrentPos, 1.0), ProjectionMatrix);
		if (abs(ClipPos.w) < 0.001)
		{
			continue;
		}

		float2 CurrentUV = float2(
			ClipPos.x / ClipPos.w * 0.5 + 0.5,
			-ClipPos.y / ClipPos.w * 0.5 + 0.5
		);

		// Exit if off screen
		if (CurrentUV.x < 0.0 || CurrentUV.x > 1.0 || CurrentUV.y < 0.0 || CurrentUV.y > 1.0)
		{
			g_SSRDebugExitReason = 2;
			break;
		}

		// Sample scene depth at projected UV (apply SceneUVScale for correct sampling)
		float2 CurrentSceneUV = CurrentUV * SceneUVScale;
		float SceneDeviceZ = SceneDepthTexture.SampleLevel(InputSampler, CurrentSceneUV, 0).r;
		float SceneDepth = ConvertFromDeviceZ(SceneDeviceZ);
		float RayDepth = -CurrentPos.z;

		// Reconstruct scene 3D position for debug and hit test
		float3 SceneViewPos = ReconstructViewPosition(CurrentUV, SceneDepth);
		float XYDist = length(CurrentPos.xy - SceneViewPos.xy);

		// Store debug info
		g_SSRDebugLastPos = CurrentPos;
		g_SSRDebugLastRayDepth = RayDepth;
		g_SSRDebugLastSceneDepth = SceneDepth;
		g_SSRDebugDepthPenetration = RayDepth - SceneDepth;
		g_SSRDebugXYDistance = XYDist;

		// Skip sky (very far depth)
		if (SceneDepth > 50000.0)
		{
			// Accelerate through empty space
			StepSize = min(StepSize * 1.5, 100.0);
			continue;
		}

		// Slow down near geometry
		float DepthDiff = SceneDepth - RayDepth;
		if (DepthDiff > 0 && DepthDiff < RayDepth * 0.5)
		{
			StepSize = max(StepSize * 0.5, 1.0);
		}

		// ========================================================================
		// HIT TEST: Ray passed behind scene geometry?
		// ========================================================================
		// SSR works in SCREEN SPACE: if ray projects to same UV and passes
		// behind scene depth, that's a hit. No 3D XY comparison needed.
		// ========================================================================
		if (RayDepth > SceneDepth)
		{
			// Check thickness (don't hit if we overshot too far)
			float Penetration = RayDepth - SceneDepth;
			float MaxPenetration = ScreenSpaceReflectionThickness * SceneDepth * 0.1;

			if (Penetration < MaxPenetration)
			{
				// Binary search refinement for accurate hit position
				float3 Lo = PrevPos;
				float3 Hi = CurrentPos;
				float2 HitUV = CurrentUV;

				for (int j = 0; j < 5; j++)
				{
					float3 Mid = (Lo + Hi) * 0.5;
					float4 MidClip = mul(float4(Mid, 1.0), ProjectionMatrix);
					float2 MidUV = float2(
						MidClip.x / MidClip.w * 0.5 + 0.5,
						-MidClip.y / MidClip.w * 0.5 + 0.5
					);

					if (MidUV.x >= 0 && MidUV.x <= 1 && MidUV.y >= 0 && MidUV.y <= 1)
					{
						float2 MidSceneUV = MidUV * SceneUVScale;
						float MidSceneZ = ConvertFromDeviceZ(
							SceneDepthTexture.SampleLevel(InputSampler, MidSceneUV, 0).r
						);
						float MidRayZ = -Mid.z;

						if (MidRayZ > MidSceneZ)
						{
							Hi = Mid;
							HitUV = MidUV;
						}
						else
						{
							Lo = Mid;
						}
					}
				}

				// Output hit (apply SceneUVScale for correct sampling)
				OutHitUV = HitUV;
				float2 HitSceneUV = HitUV * SceneUVScale;
				OutHitColor = SceneColorTexture.SampleLevel(InputSampler, HitSceneUV, 0).rgb;

				// Fade factors
				float2 EdgeDist = min(HitUV, 1.0 - HitUV);
				float EdgeFade = saturate(min(EdgeDist.x, EdgeDist.y) / max(ScreenSpaceReflectionEdgeFade, 0.01));
				float DistFade = saturate(1.0 - float(i) / float(ScreenSpaceReflectionMaxSteps));

				return EdgeFade * DistFade;
			}
		}
	}

	return 0.0;
}

// -----------------------------------------------------------------------------
// Pixel Shader
// -----------------------------------------------------------------------------

void MainPS(
	FCompositeVSToPS Input,
	out float4 OutColor : SV_Target0)
{
	float2 UV = Input.UV;

	// SceneUV for sampling SceneColor/SceneDepth (handles Screen Percentage)
	float2 SceneUV = UV * SceneUVScale;

	// 1. Sample fluid depth (assumed to be linear depth)
	// Use point sampling to avoid edge interpolation artifacts (white border at fluid-mesh boundary)
	float FluidDepth = FluidDepthTexture.Sample(PointClampSampler, UV);

	// Handle background (no fluid)
	// FluidDepth is initialized to a very large value (e.g., 3.4e38)
	if (FluidDepth > BACKGROUND_DEPTH_THRESH)
	{
		discard;
		return;
	}

	// 2. Get scene depth (DeviceZ -> Linear)
	float SceneDeviceZ = SceneDepthTexture.SampleLevel(InputSampler, SceneUV, 0).r;
	float SceneLinearDepth = ConvertFromDeviceZ(SceneDeviceZ);

	// 3. Occlusion test - use precomputed OcclusionMask from FluidDepth pass
	// OcclusionMask: 1.0 = visible (in front of scene), 0.0 = occluded (behind scene)
	float OcclusionMask = OcclusionMaskTexture.SampleLevel(PointClampSampler, UV, 0).r;
	if (OcclusionMask < 0.5)
	{
		discard;
		return;
	}

	// 4. Sample fluid properties
	// Use point sampling to avoid edge interpolation artifacts at fluid boundary
	float3 Normal = FluidNormalTexture.Sample(PointClampSampler, UV).xyz;
	float Thickness = FluidThicknessTexture.Sample(PointClampSampler, UV).r;

	// Normal validation with proper NaN/Inf check
	bool bInvalidNormal = any(isnan(Normal)) || any(isinf(Normal)) || length(Normal) < 0.1f;
	if (bInvalidNormal)
	{
		Normal = float3(0, 0, 1);
	}
	else
	{
		Normal = normalize(Normal);
	}

	// 5. Prepare lighting calculations
	float3 ViewPos = ReconstructViewPosition(UV, FluidDepth);
	float3 ViewDir = normalize(-ViewPos);  // Direction toward camera (positive Z)

	// Ensure normal faces camera for lighting (dot > 0)
	// This is needed because FluidNormal.usf may output normals facing either direction
	if (dot(Normal, ViewDir) < 0.0)
	{
		Normal = -Normal;
	}

	// Grazing angle compensation for lighting stability
	float RawNoV = saturate(dot(Normal, ViewDir));
	float GrazingFade = smoothstep(0.0, 0.15, RawNoV);
	float3 LightingNormal = normalize(lerp(ViewDir, Normal, GrazingFade));

	// For SSR: Use the corrected normal directly
	// FluidNormal.usf now uses the same coordinate convention as this shader
	// (Y-axis flipped: UV.y=0 maps to ClipY=1)
	float3 ReflectionNormal = Normal;

	// A. PBR Setup
	// ========================================================================
	// F0 (base reflectivity at normal incidence):
	// - F0Override > 0: Use artist-defined value directly
	// - F0Override = 0: Auto-calculate from IOR: F0 = ((1-n)/(1+n))^2 * FresnelStrength
	// Water (IOR=1.33): F0 ~ 0.02, Glass (IOR=1.5): F0 ~ 0.04
	// Fluids are dielectric (non-metallic), so F0 is uniform across RGB
	// ========================================================================
	float NoV = saturate(dot(LightingNormal, ViewDir));
	float FinalF0;
	if (F0Override > 0.0)
	{
		FinalF0 = F0Override;
	}
	else
	{
		float IOR_Ratio = (1.0 - RefractiveIndex) / (1.0 + RefractiveIndex);
		FinalF0 = IOR_Ratio * IOR_Ratio * FresnelStrength;
	}
	float3 F0 = float3(FinalF0, FinalF0, FinalF0);

	// B. PBR Lighting (Cook-Torrance BRDF) - Multi-Light Support
	// ========================================================================
	// Loops over all active lights and accumulates Cook-Torrance contributions.
	// Each light needs its own half-vector and HoV for physically correct Fresnel.
	// Falls back to View.DirectionalLight if NumLights == 0.
	// ========================================================================

	// Roughness (clamp to avoid divide by zero in GGX)
	float Roughness = max(SpecularRoughness, 0.04);

	// Accumulated lighting results
	float3 TotalSpecular = float3(0, 0, 0);
	float3 TotalDiffuse = float3(0, 0, 0);

	// Determine effective light count (fallback to View.DirectionalLight if 0)
	int EffectiveLightCount = (NumLights > 0) ? NumLights : 1;

	for (int LightIndex = 0; LightIndex < EffectiveLightCount; LightIndex++)
	{
		float3 LightDir;
		float3 LightColor;

		if (NumLights > 0)
		{
			// Unpack light from float4 arrays
			// LightDirectionsAndIntensity[i] = (Direction.xyz, Intensity)
			// LightColors[i] = (Color.rgb, unused)
			float4 DirAndIntensity = LightDirectionsAndIntensity[LightIndex];
			float4 ColorPacked = LightColors[LightIndex];

			LightDir = normalize(-DirAndIntensity.xyz);
			float Intensity = DirAndIntensity.w;
			LightColor = ColorPacked.rgb * Intensity;
		}
		else
		{
			// Fallback: use View's main directional light
			LightDir = normalize(-View.DirectionalLightDirection);
			LightColor = View.DirectionalLightColor.rgb;
		}

		// Per-light dot products (use LightingNormal for stable shading)
		float NoL = saturate(dot(LightingNormal, LightDir));
		float3 HalfDir = normalize(LightDir + ViewDir);
		float NoH = saturate(dot(LightingNormal, HalfDir));
		float HoV = saturate(dot(HalfDir, ViewDir));

		// Cook-Torrance Specular BRDF
		// Each light has its own HoV for physically correct Fresnel
		float3 SpecularFresnel;
		float3 SpecularBRDF = CookTorranceBRDF(NoV, NoL, NoH, HoV, Roughness, F0, SpecularFresnel);
		TotalSpecular += SpecularBRDF * LightColor * NoL * SpecularStrength;

		// Energy Conservation: diffuse is reduced by specular reflection
		// kD = 1 - kS (for dielectrics, metallic = 0)
		float3 kD = 1.0 - SpecularFresnel;

		// Diffuse (Lambert with energy conservation)
		TotalDiffuse += kD * NoL * LightColor;
	}

	// Use accumulated specular
	float3 Specular = TotalSpecular;

	// Ambient (prevents completely dark surfaces)
	// Use SkyLightColor if available, otherwise fallback to DirectionalLightColor, then fixed value
	float3 EnvironmentColor = View.SkyLightColor.rgb;
	if (dot(EnvironmentColor, float3(1, 1, 1)) < 0.001)
	{
		EnvironmentColor = View.DirectionalLightColor.rgb;
	}
	if (dot(EnvironmentColor, float3(1, 1, 1)) < 0.001)
	{
		EnvironmentColor = float3(1.0, 1.0, 1.0);  // White fallback
	}
	float3 AmbientColor = EnvironmentColor;

	// Total Lighting (diffuse + ambient, specular added separately)
	float3 TotalLighting = TotalDiffuse + AmbientColor;

	// Fresnel for environment reflection (IBL/Cubemap/SSR)
	// ========================================================================
	// Unlike direct lighting which uses HoV (Half·View), environment reflection
	// uses NoV (Normal·View) as an approximation. This is because:
	// - Environment light comes from ALL directions, not a single light direction
	// - Therefore, no single half-vector can be defined
	// - NoV approximation is the industry standard (UE4/5, Unity, Frostbite)
	// - Reference: "Real Shading in Unreal Engine 4" (Brian Karis, SIGGRAPH 2013)
	// ========================================================================
	float Fresnel = F0.r + (1.0 - F0.r) * pow(1.0 - NoV, 5.0);

	// C. Volume Scattering (Light-based, Henyey-Greenstein)
	// ========================================================================
	// Physical scattering: light scatters through fluid based on View-Light angle.
	// All parameters derived from existing fluid properties:
	// - ScatterColor = FluidColor (fluid's intrinsic color)
	// - Anisotropy = derived from Opacity (transparent=forward, opaque=isotropic)
	// - Strength = ThicknessSensitivity
	// ========================================================================
	float3 VolumeScatterContribution = float3(0, 0, 0);

	// Scattering parameters derived from existing properties
	// Transparent fluids (low Opacity) → forward scatter (g=0.8)
	// Opaque fluids (high Opacity) → isotropic scatter (g=0.2)
	float ScatterAnisotropy = lerp(0.8, 0.2, Opacity);
	float3 ScatterColor = FluidColor.rgb;
	float ScatterStrength = ThicknessSensitivity;

	if (ScatterStrength > 0.001)
	{
		// Loop through lights for scattering calculation
		int ScatterLightCount = (NumLights > 0) ? NumLights : 1;

		for (int ScatterLightIndex = 0; ScatterLightIndex < ScatterLightCount; ScatterLightIndex++)
		{
			float3 ScatterLightDir;
			float3 ScatterLightColor;

			if (NumLights > 0)
			{
				float4 DirAndIntensity = LightDirectionsAndIntensity[ScatterLightIndex];
				float4 ColorPacked = LightColors[ScatterLightIndex];
				ScatterLightDir = normalize(-DirAndIntensity.xyz);
				ScatterLightColor = ColorPacked.rgb * DirAndIntensity.w;
			}
			else
			{
				ScatterLightDir = normalize(-View.DirectionalLightDirection);
				ScatterLightColor = View.DirectionalLightColor.rgb;
			}

			// VoL: View dot Light (positive when looking toward light source)
			// When camera looks at light source: VoL > 0 (backlit, forward scatter visible)
			float VoL = dot(ViewDir, -ScatterLightDir);

			// Phase function: probability of scattering in this direction
			float Phase = HenyeyGreenstein(VoL, ScatterAnisotropy);

			// Extinction: light scattered along path through fluid
			float Extinction = 1.0 - exp(-Thickness * ScatterStrength * 0.1);

			// Accumulate scattering contribution
			VolumeScatterContribution += ScatterColor * ScatterLightColor * Phase * Extinction;
		}
	}

	// ========================================================================
	// Color Compositing (Flex-style Simple Approach)
	// ========================================================================
	float3 FinalColor;

	// 1. Sample scene color (background) - use SceneUV for correct texture mapping
	float3 SceneColor = SceneColorTexture.Sample(InputSampler, SceneUV).rgb;

	// 2. Sample refracted background color (with Refraction Mask)
	// ========================================================================
	// Refraction Mask: Reduce refraction at thin/edge areas to prevent excessive distortion
	// - ThicknessMask: Weaker refraction in thin areas
	// - EdgeMask: Weaker refraction at edges (where Normal.z is small)
	// ========================================================================
	float ThicknessMask = saturate(Thickness * 0.1);  // Thickness-based (small when thin)
	float EdgeMask = saturate(abs(Normal.z) * 2.0);   // Edge-based (small at edges)
	float RefractionMask = ThicknessMask * EdgeMask;

	// Calculate refraction offset (with thickness/edge mask)
	float2 RefractOffset = Normal.xy * RefractiveIndex * RefractionScale * RefractionMask;
	float2 RefractedUV = UV + RefractOffset;
	RefractedUV = saturate(RefractedUV);

	// Apply SceneUVScale to refracted UV for scene texture sampling
	float2 RefractedSceneUV = RefractedUV * SceneUVScale;

	// Check depth at refracted UV position
	float RefractedSceneDepth = ConvertFromDeviceZ(SceneDepthTexture.SampleLevel(InputSampler, RefractedSceneUV, 0).r);

	// Soft refraction validity check:
	// 1. Refracted position must be behind fluid (not sampling objects in front of fluid)
	// 2. Refracted position should not suddenly show much closer objects than original UV
	// 3. Fade out refraction near screen edges (avoid sampling clamped edge pixels)
	// Using soft transitions to avoid hard edge artifacts
	float DepthMargin = 20.0;
	float BehindFluidFactor = saturate((RefractedSceneDepth - FluidDepth + DepthMargin) / DepthMargin);
	float NotPullingForwardFactor = saturate((RefractedSceneDepth - SceneLinearDepth + DepthMargin) / DepthMargin);

	// Screen edge fade: reduce refraction when refracted UV approaches screen boundary
	float2 EdgeDist = min(RefractedUV, 1.0 - RefractedUV);
	float ScreenEdgeFade = saturate(min(EdgeDist.x, EdgeDist.y) / 0.05);  // Fade over 5% of screen edge

	float RefractionValidity = BehindFluidFactor * NotPullingForwardFactor * ScreenEdgeFade;

	// Soft blend between original UV and refracted UV, then apply SceneUVScale
	float2 FinalRefractUV = lerp(UV, RefractedUV, RefractionValidity);
	float2 FinalRefractSceneUV = FinalRefractUV * SceneUVScale;

	float3 RefractedBackground = SceneColorTexture.Sample(InputSampler, FinalRefractSceneUV).rgb;

	// 2.5. Caustics (Jacobian method - ray convergence = bright, divergence = dark)
	float CausticBrightness = 1.0;
	{
		float Pattern = CausticPattern(
			UV,
			Normal,
			FluidDepth,
			RefractedSceneDepth,
			ViewMatrix,
			RefractiveIndex
		);

		// Convert pattern to brightness multiplier
		CausticBrightness = 1.0 + Pattern * 1.5;

		// Fade based on fluid properties
		float DepthFade = saturate(1.0 - FluidDepth * 0.0003);
		float ThicknessFade = exp(-Thickness * 0.015);
		float TransparencyFade = saturate(1.0 - Opacity * 0.7);
		float CausticFade = DepthFade * ThicknessFade * TransparencyFade * RefractionValidity;

		CausticBrightness = lerp(1.0, CausticBrightness, CausticFade);
	}

	// Apply caustics to refracted background
	RefractedBackground *= CausticBrightness;

	// 3. Beer's Law: Calculate per-channel transmittance based on thickness
	// T(λ) = exp(-σ(λ) * thickness)
	// Each color channel has different absorption coefficient
	// Water: absorbs more R -> appears blue
	// Slime: absorbs more B -> appears green/yellow
	// Convert Opacity (0~1) to absorption coefficient (1.0 ~ 5.0)
	float AbsorptionCoefficient = 1.0 + Opacity * 4.0;
	float3 AbsorptionRGB = AbsorptionColorCoefficients.rgb * AbsorptionCoefficient;
	float3 Transmittance = exp(-AbsorptionRGB * Thickness * 0.1f);  // 0.1 = constant scale factor

	// Calculate transmitted background color
	float3 TransmittedBackground = RefractedBackground * Transmittance;

	// 4. Blend background with fluid color
	// Thicker fluid shows more of its intrinsic color
	float OverallAbsorption = 1.0 - dot(Transmittance, float3(0.333, 0.333, 0.333));

	// Apply lighting to FluidColor (PBR Diffuse + Ambient)
	float3 LitFluidColor = FluidColor.rgb * TotalLighting;
	float3 BaseColor = lerp(TransmittedBackground, LitFluidColor, saturate(OverallAbsorption));

	// 5. Fresnel Reflection (SSR + Cubemap Fallback)
	// ========================================================================
	// Reflection priority: SSR Hit -> Cubemap -> Environment Color
	// If SSR misses, fallback to Cubemap; if no Cubemap, use constant color
	// ========================================================================
	float3 ViewSpaceReflect = reflect(-ViewDir, ReflectionNormal);
	float3 ReflectedColor = float3(0, 0, 0);
	float SSRHitStrength = 0.0;

	// Attempt SSR (if enabled)
	if (bEnableScreenSpaceReflection > 0)
	{
		float2 SSRHitUV;
		float3 SSRHitColor;
		SSRHitStrength = TraceSSR(ViewPos, ViewSpaceReflect, SSRHitUV, SSRHitColor);

		// DEBUG: SSR debug visualization (runtime switchable via ScreenSpaceReflectionDebugMode)
		// 0 = disabled, 1 = hit/miss, 2 = reflection direction, 3 = hit sample color
		// 4 = reflection Z direction (green=into scene, red=toward camera)
		// 5 = ray depth vs scene depth comparison
		// 6 = exit reason (red=behind camera, green=off screen, blue=max steps)
		// 7 = Normal visualization, 8 = ViewDir visualization, 9 = ViewPos.z visualization
		if (ScreenSpaceReflectionDebugMode == 1)
		{
			// SSR hit/miss: red = hit (intensity varies), blue = miss
			if (SSRHitStrength > 0.0)
			{
				OutColor = float4(SSRHitStrength, 0, 0, 1);  // Red intensity = hit strength
			}
			else
			{
				OutColor = float4(0, 0, 1, 1);  // Blue: Miss
			}
			return;
		}
		else if (ScreenSpaceReflectionDebugMode == 2)
		{
			// Reflection vector direction as color (RGB = XYZ, 0.5 = 0)
			OutColor = float4(ViewSpaceReflect * 0.5 + 0.5, 1.0);
			return;
		}
		else if (ScreenSpaceReflectionDebugMode == 3)
		{
			// Direct display of hit color (magenta if miss)
			if (SSRHitStrength > 0.0)
			{
				OutColor = float4(SSRHitColor, 1.0);
			}
			else
			{
				OutColor = float4(1, 0, 1, 1);  // Magenta: Miss
			}
			return;
		}
		else if (ScreenSpaceReflectionDebugMode == 4)
		{
			// Reflection direction Z component visualization
			// Green = into scene (Z < 0, SSR possible)
			// Red = toward camera (Z > 0, SSR not possible)
			float ReflectZ = ViewSpaceReflect.z;
			if (ReflectZ < 0.0)
			{
				// Into scene - SSR possible (green, intensity shows depth)
				OutColor = float4(0, saturate(-ReflectZ), 0, 1);
			}
			else
			{
				// Toward camera - SSR not possible (red)
				OutColor = float4(saturate(ReflectZ), 0, 0, 1);
			}
			return;
		}
		else if (ScreenSpaceReflectionDebugMode == 5)
		{
			// 3D hit test visualization (new corrected logic)
			// R = XY distance (how far ray XY is from scene XY)
			// G = Depth penetration (positive = penetrated)
			// B = hit (yellow if hit)
			if (SSRHitStrength > 0.0)
			{
				// Hit case - yellow
				OutColor = float4(1, 1, 0, 1);
			}
			else
			{
				float r = saturate(g_SSRDebugXYDistance / 100.0);  // XY distance
				float g = saturate(g_SSRDebugDepthPenetration / 50.0);  // Penetration (positive = past)
				float b = (g_SSRDebugDepthPenetration < 0.0) ? saturate(-g_SSRDebugDepthPenetration / 50.0) : 0.0;  // Not yet penetrated
				OutColor = float4(r, g, b, 1);
			}
			return;
		}
		else if (ScreenSpaceReflectionDebugMode == 6)
		{
			// Exit reason visualization
			if (SSRHitStrength > 0.0)
			{
				OutColor = float4(1, 1, 0, 1);  // Yellow: Hit
			}
			else if (g_SSRDebugExitReason == 1)
			{
				OutColor = float4(1, 0, 0, 1);  // Red: went behind camera
			}
			else if (g_SSRDebugExitReason == 2)
			{
				OutColor = float4(0, 1, 0, 1);  // Green: went off screen
			}
			else
			{
				OutColor = float4(0, 0, 1, 1);  // Blue: max steps reached
			}
			return;
		}
		else if (ScreenSpaceReflectionDebugMode == 7)
		{
			// Normal visualization (RGB = XYZ, 0.5 = 0)
			OutColor = float4(Normal * 0.5 + 0.5, 1.0);
			return;
		}
		else if (ScreenSpaceReflectionDebugMode == 8)
		{
			// ViewDir visualization (RGB = XYZ, 0.5 = 0)
			OutColor = float4(ViewDir * 0.5 + 0.5, 1.0);
			return;
		}
		else if (ScreenSpaceReflectionDebugMode == 9)
		{
			// ViewPos.z visualization (blue = in front of camera, red = behind camera)
			if (ViewPos.z < 0.0)
			{
				OutColor = float4(0, 0, saturate(-ViewPos.z / 1000.0), 1);  // Blue: in front
			}
			else
			{
				OutColor = float4(saturate(ViewPos.z / 1000.0), 0, 0, 1);  // Red: behind (incorrect)
			}
			return;
		}
		else if (ScreenSpaceReflectionDebugMode == 10)
		{
			// Fresnel value visualization (white = high fresnel, black = low)
			OutColor = float4(Fresnel, Fresnel, Fresnel, 1.0);
			return;
		}
		else if (ScreenSpaceReflectionDebugMode == 11)
		{
			// Parameter debug: R = FresnelStrength/10, G = FresnelReflectionBlend, B = Fresnel
			OutColor = float4(FresnelStrength / 10.0, FresnelReflectionBlend, Fresnel, 1.0);
			return;
		}
		else if (ScreenSpaceReflectionDebugMode == 12)
		{
			// Final reflection blend factor: Fresnel * FresnelReflectionBlend
			float BlendFactor = Fresnel * FresnelReflectionBlend;
			OutColor = float4(BlendFactor, BlendFactor, BlendFactor, 1.0);
			return;
		}
		else if (ScreenSpaceReflectionDebugMode == 13)
		{
			// SSR hit analysis (depth-only)
			// Yellow = HIT
			// Blue = ray in front of scene (not penetrated yet)
			// Red = penetrated but overshot (too far past geometry)
			// Green = sky/background (ray ended in empty space)
			if (SSRHitStrength > 0.0)
			{
				OutColor = float4(1, 1, 0, 1);  // Yellow: HIT!
			}
			else
			{
				bool bIsSky = g_SSRDebugLastSceneDepth > 50000.0;
				float Penetration = g_SSRDebugDepthPenetration;
				float MaxPenetration = ScreenSpaceReflectionThickness * g_SSRDebugLastSceneDepth * 0.1;

				if (bIsSky)
				{
					OutColor = float4(0, 0.5, 0, 1);  // Dark Green: sky
				}
				else if (Penetration <= 0.0)
				{
					OutColor = float4(0, 0, 1, 1);  // Blue: not penetrated
				}
				else if (Penetration > MaxPenetration)
				{
					OutColor = float4(1, 0, 0, 1);  // Red: overshot
				}
				else
				{
					OutColor = float4(1, 0, 1, 1);  // Magenta: bug
				}
			}
			return;
		}
		else if (ScreenSpaceReflectionDebugMode == 14)
		{
			// SSR hit UV visualization
			// R = hit UV.x, G = hit UV.y, B = hit strength
			// This shows WHERE the SSR is sampling from
			if (SSRHitStrength > 0.0)
			{
				OutColor = float4(SSRHitUV.x, SSRHitUV.y, SSRHitStrength, 1.0);
			}
			else
			{
				// No hit - show dark blue
				OutColor = float4(0, 0, 0.2, 1);
			}
			return;
		}

		if (SSRHitStrength > 0.0)
		{
			// ScreenSpaceReflectionIntensity = artist strength control
			// SSRHitStrength used only for blend factor below (not multiplied twice)
			ReflectedColor = SSRHitColor * ScreenSpaceReflectionIntensity;
		}
	}

	// Cubemap Fallback (SSR miss or partial hit)
	// SSRHitStrength determines blend: 0 = full cubemap, 1 = full SSR
	if (SSRHitStrength < 0.99)
	{
		float3 CubemapColor;
		if (bUseReflectionCubemap > 0)
		{
			// View Space -> World Space transform (inverse of View Matrix)
			// ViewMatrix is World->View, so transpose gives View->World (orthogonal matrix)
			float3x3 ViewToWorld = transpose((float3x3)ViewMatrix);
			float3 WorldReflect = mul(ViewSpaceReflect, ViewToWorld);

			// Cubemap sampling (Mip level controls blur)
			float MipLevel = ReflectionMipLevel + SpecularRoughness * 6.0;  // Linked to roughness
			CubemapColor = ReflectionCubemap.SampleLevel(ReflectionCubemapSampler, WorldReflect, MipLevel).rgb;
			CubemapColor *= ReflectionIntensity;
		}
		else
		{
			// Fallback: use a dimmed environment light color for reflection
			// Scale down to avoid overly bright reflections when no cubemap
			float3 FallbackEnvColor = View.SkyLightColor.rgb;
			if (dot(FallbackEnvColor, float3(1, 1, 1)) < 0.001)
			{
				FallbackEnvColor = View.DirectionalLightColor.rgb;
			}
			if (dot(FallbackEnvColor, float3(1, 1, 1)) < 0.001)
			{
				FallbackEnvColor = float3(1.0, 1.0, 1.0);  // White fallback
			}
			CubemapColor = FallbackEnvColor * 0.3;
		}

		// Blend SSR with Cubemap based on hit strength
		ReflectedColor = lerp(CubemapColor, ReflectedColor, SSRHitStrength);
	}

	// 6. Blend reflection with transmission
	// Fresnel determines how much reflection vs transmission (physically-based)
	// FresnelReflectionBlend is artist control multiplier
	BaseColor = lerp(BaseColor, ReflectedColor, Fresnel * FresnelReflectionBlend);

	// 7. Add Specular + SSS
	FinalColor = BaseColor + Specular + VolumeScatterContribution;

	// 8. Alpha calculation
	// Opacity: base opacity (minimum alpha)
	// ThicknessSensitivity: how steeply thickness adds opacity on top
	//   0 = thickness has no effect (use base Opacity only)
	//   1 = thickness strongly adds opacity (thick areas become opaque regardless of base Opacity)
	float BaseAlpha = Opacity;
	float ThicknessAlpha = saturate(1.0 - exp(-Thickness * ThicknessSensitivity * 5.0f));
	// Take the maximum: base opacity OR thickness-based opacity
	float Alpha = max(BaseAlpha, ThicknessAlpha);
	// Only boost alpha at grazing angles (high Fresnel), not everywhere
	// Use a softer contribution from Fresnel to avoid making thin fluid opaque
	float FresnelAlphaBoost = Fresnel * FresnelReflectionBlend * 0.3;  // Reduced from 1.0 to 0.3
	Alpha = max(Alpha, FresnelAlphaBoost);

	// C++ BlendState uses (SrcAlpha, InvSrcAlpha)
	// Output RGB without premultiplied alpha
	OutColor = float4(FinalColor, Alpha);
}
