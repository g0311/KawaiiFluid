#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"

// -----------------------------------------------------------------------------
// Parameters
// -----------------------------------------------------------------------------
Texture2D<float> FluidDepthTexture;
Texture2D<float4> FluidNormalTexture;
Texture2D<float> FluidThicknessTexture;
Texture2D<float> SceneDepthTexture; 

SamplerState InputSampler;

float4x4 InverseProjectionMatrix;
float4x4 ProjectionMatrix;
float4x4 ViewMatrix;

float4 FluidColor;
float FresnelStrength;
float RefractiveIndex;
float AbsorptionCoefficient;
float SpecularStrength;
float SpecularRoughness;

// -----------------------------------------------------------------------------
// Vertex Shader
// -----------------------------------------------------------------------------
struct FCompositeVSToPS
{
    float4 Position : SV_POSITION;
    float2 UV : TEXCOORD0; 
};

void MainVS(
    in uint VertexID : SV_VertexID,
    out FCompositeVSToPS Output
)
{
    // Fullscreen Triangle
    float2 UV = float2((VertexID << 1) & 2, VertexID & 2);
    Output.UV = UV;
    Output.Position = float4(UV * float2(2, -2) + float2(-1, 1), 0.5f, 1.0f);
}

// -----------------------------------------------------------------------------
// Helper Functions
// -----------------------------------------------------------------------------

// 배경 깊이 기준값 (너무 먼 곳은 유체 없음)
#define BACKGROUND_DEPTH_THRESH 100000.0f 

/**
 * Screen UV와 Linear Depth를 이용해 View Space Position 복원
 */
float3 ReconstructViewPosition(float2 ScreenUV, float LinearDepth)
{
    // Clip Space 좌표 (Z는 0.5 등 임의값)
    float4 ClipPosition = float4(ScreenUV * 2.0 - 1.0, 0.5, 1.0);

    // View Space로 역투영
    float4 ViewPosition = mul(ClipPosition, InverseProjectionMatrix);
    ViewPosition /= ViewPosition.w;

    // 카메라에서 픽셀 방향 벡터
    float3 ViewRay = ViewPosition.xyz / ViewPosition.z;

    // LinearDepth는 보통 양수(거리)이므로 음수(-Z)로 변환
    return ViewRay * (-LinearDepth);
}

// -----------------------------------------------------------------------------
// Pixel Shader
// -----------------------------------------------------------------------------

void MainPS(
    FCompositeVSToPS Input,
    out float4 OutColor : SV_Target0)
{
    float2 UV = Input.UV;

    // 1. Fluid Depth 샘플링 (Linear Depth라고 가정)
    float FluidDepth = FluidDepthTexture.Sample(InputSampler, UV);

    // 유체가 없는 곳(배경) 처리
    // FluidDepth를 초기화할 때 아주 큰 값(예: 3.4e38)으로 했는지 확인 필요
    if (FluidDepth > BACKGROUND_DEPTH_THRESH)
    {
        discard; // 혹은 return float4(0,0,0,0);
        return;
    }

    // 2. Scene Depth 가져오기 (DeviceZ -> Linear)
    float SceneDeviceZ = SceneDepthTexture.SampleLevel(InputSampler, UV, 0).r;
    float SceneLinearDepth = ConvertFromDeviceZ(SceneDeviceZ); // 언리얼 단위(cm)

    // 3. Occlusion Test (가려짐 처리)
    // FluidDepth와 SceneLinearDepth의 오차가 있을 수 있으므로 여유값(Bias)을 둠
    if (FluidDepth > SceneLinearDepth + 2.0f)
    {
        discard;
        return;
    }

    // 4. Fluid 속성 샘플링
    float3 Normal = FluidNormalTexture.Sample(InputSampler, UV).xyz;
    float Thickness = FluidThicknessTexture.Sample(InputSampler, UV).r;
    
    // Normal이 (0,0,0)인 경우 방어 코드 (혹시 모를 에러 방지)
    if (length(Normal) < 0.1f)
    {
        Normal = float3(0, 0, 1);
    }

    // 5. 조명 계산 준비
    float3 ViewPos = ReconstructViewPosition(UV, FluidDepth);
    float3 ViewDir = normalize(-ViewPos); // 카메라를 향하는 벡터

    // A. Fresnel (반사율 - Schlick's approximation)
    float NoV = saturate(dot(Normal, ViewDir));
    float F0 = FresnelStrength;
    float Fresnel = F0 + (1.0 - F0) * pow(1.0 - NoV, 5.0);

    // B. Specular (하이라이트) - 가상 조명
    float3 LightDir = normalize(float3(0.5, 0.5, 1.0));
    float3 HalfDir = normalize(LightDir + ViewDir);
    float NoH = saturate(dot(Normal, HalfDir));

    // Roughness를 Shininess로 변환 (작은 roughness = 큰 shininess = 날카로운 하이라이트)
    float Shininess = (1.0 - SpecularRoughness) * 128.0;
    float Specular = pow(NoH, Shininess) * SpecularStrength;

    // C. Beer's Law (올바른 물리 기반 투과율 계산)
    // 색상별 흡수 계수: 유체 색상과 반대되는 색을 더 흡수
    // 예: 파란 유체(0.2, 0.5, 0.8)는 빨간색(0.8)을 많이 흡수
    float3 ColorAbsorption = (1.0 - FluidColor.rgb) * AbsorptionCoefficient;

    // Transmittance: 두께가 클수록 빛이 덜 투과
    // exp를 사용하여 지수적 감쇠 (Beer-Lambert Law)
    float3 Transmittance = exp(-ColorAbsorption * Thickness * 0.1); // 0.1은 스케일 조정

    // D. 환경색 가정 (Scene Color가 없으므로 간단한 환경광 사용)
    // 실제로는 Scene Color Texture를 샘플링해야 하지만, 없으므로 밝은 회색 가정
    float3 EnvironmentColor = float3(0.8, 0.9, 1.0); // 하늘빛
    float3 BackgroundColor = float3(0.5, 0.5, 0.5);  // 배경 (중간 회색)

    // E. 투과된 빛 (배경 + 유체 색상 흡수)
    // 배경색이 유체를 통과하면서 유체 색상을 띔
    float3 TransmittedLight = BackgroundColor * Transmittance;

    // 흡수된 빛이 유체 색상으로 보임
    float3 AbsorbedLight = FluidColor.rgb * (1.0 - Transmittance) * 2.0; // 2.0은 색상 강도

    // F. 반사된 빛 (Fresnel에 의한 환경 반사)
    float3 ReflectedLight = EnvironmentColor * Fresnel;

    // 6. 최종 컬러 합성 (물리 기반)
    // Fresnel에 따라 반사와 투과를 혼합
    float3 BaseColor = lerp(TransmittedLight + AbsorbedLight, ReflectedLight, Fresnel);
    float3 FinalColor = BaseColor + Specular; // Specular는 추가

    // 7. Alpha 계산
    // 두께가 있으면 불투명, 반사가 강하면 불투명
    float Alpha = saturate(1.0 - exp(-Thickness * 0.005));
    Alpha = max(Alpha, Fresnel * 0.8); 

    // C++ BlendState: (SrcAlpha, InvSrcAlpha) 사용 중이므로
    // RGB에 Alpha를 미리 곱하지 않고 내보냄
    OutColor = float4(FinalColor, Alpha);
}