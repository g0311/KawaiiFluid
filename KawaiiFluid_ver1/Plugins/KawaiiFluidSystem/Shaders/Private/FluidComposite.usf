#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"

// -----------------------------------------------------------------------------
// Parameters
// -----------------------------------------------------------------------------
Texture2D<float> FluidDepthTexture;
Texture2D<float4> FluidNormalTexture;
Texture2D<float> FluidThicknessTexture;
Texture2D<float> SceneDepthTexture;
Texture2D<float4> SceneColorTexture;

SamplerState InputSampler;

float4x4 InverseProjectionMatrix;
float4x4 ProjectionMatrix;
float4x4 ViewMatrix;

float4 FluidColor;
float FresnelStrength;
float RefractiveIndex;
float AbsorptionCoefficient;
float4 AbsorptionColorCoefficients;  // Per-channel absorption coefficients (Beer's Law)
float SpecularStrength;
float SpecularRoughness;
float4 EnvironmentLightColor;

// Lighting Scale Parameters
float AmbientScale;
float TransmittanceScale;
float AlphaThicknessScale;
float RefractionScale;
float FresnelReflectionBlend;

// Subsurface Scattering (SSS)
float SSSIntensity;
float4 SSSColor;

// Reflection Cubemap
TextureCube ReflectionCubemap;
SamplerState ReflectionCubemapSampler;
float ReflectionIntensity;
float ReflectionMipLevel;
int bUseReflectionCubemap;

// Screen Space Reflections (SSR)
int bEnableSSR;
int SSRMaxSteps;
float SSRStepSize;
float SSRThickness;
float SSRIntensity;
float SSREdgeFade;
float2 ViewportSize;

// -----------------------------------------------------------------------------
// Vertex Shader
// -----------------------------------------------------------------------------
struct FCompositeVSToPS
{
	float4 Position : SV_POSITION;
	float2 UV : TEXCOORD0;
};

void MainVS(
	in uint VertexID : SV_VertexID,
	out FCompositeVSToPS Output
)
{
	// Fullscreen Triangle
	float2 UV = float2((VertexID << 1) & 2, VertexID & 2);
	Output.UV = UV;
	Output.Position = float4(UV * float2(2, -2) + float2(-1, 1), 0.5f, 1.0f);
}

// -----------------------------------------------------------------------------
// Helper Functions
// -----------------------------------------------------------------------------

// Background depth threshold (no fluid at very far distances)
#define BACKGROUND_DEPTH_THRESH 100000.0f

/**
 * Reconstruct view space position from screen UV and linear depth.
 * UE5 View Space: camera at origin, looking down -Z axis, objects in front have Z < 0
 */
float3 ReconstructViewPosition(float2 ScreenUV, float LinearDepth)
{
	// UV to Clip Space conversion (apply Y-axis flip)
	float2 ClipXY = float2(ScreenUV.x * 2.0 - 1.0, 1.0 - ScreenUV.y * 2.0);
	float4 ClipPosition = float4(ClipXY, 0.5, 1.0);

	// Unproject to view space
	float4 ViewPosition = mul(ClipPosition, InverseProjectionMatrix);
	ViewPosition /= ViewPosition.w;

	// Ray direction from camera to pixel (normalized so Z=1)
	float3 ViewRay = ViewPosition.xyz / abs(ViewPosition.z);

	// Use abs() since LinearDepth might be negative
	// Result Z is always negative (in front of camera)
	float Depth = abs(LinearDepth);
	return float3(ViewRay.x, ViewRay.y, -1.0) * Depth;
}

/**
 * Project view space position to screen UV.
 * Note: UE UV convention has Y increasing downward (top=0, bottom=1)
 */
float2 ProjectToScreenUV(float3 ViewPos)
{
	float4 ClipPos = mul(float4(ViewPos, 1.0), ProjectionMatrix);
	ClipPos.xy /= ClipPos.w;
	// Flip clip space Y for UE UV convention
	return float2(ClipPos.x * 0.5 + 0.5, -ClipPos.y * 0.5 + 0.5);
}

// SSR debug global variables
static float3 g_SSRDebugLastPos = float3(0, 0, 0);
static float g_SSRDebugLastRayDepth = 0;
static float g_SSRDebugLastSceneDepth = 0;
static int g_SSRDebugExitReason = 0;  // 0=max steps, 1=behind camera, 2=off screen

/**
 * Screen Space Reflection Ray March.
 * Performs 3D ray marching in view space to calculate reflections.
 *
 * @param RayOrigin - Ray start point in view space (fluid surface)
 * @param RayDir - Reflection direction in view space (normalized)
 * @param OutHitUV - Screen UV of hit location
 * @param OutHitColor - Scene color at hit location
 * @return Hit strength (0.0 ~ 1.0, with fade applied)
 */
float TraceSSR(float3 RayOrigin, float3 RayDir, out float2 OutHitUV, out float3 OutHitColor)
{
	OutHitUV = float2(0, 0);
	OutHitColor = float3(0, 0, 0);
	g_SSRDebugExitReason = 0;  // default: max steps reached

	// Early exit if reflection points toward camera (SSR not possible)
	if (RayDir.z > 0.05)
	{
		g_SSRDebugExitReason = 1;
		return 0.0;
	}

	// Calculate step size in view space units
	// Smaller step size for more precise ray march
	float ViewStepSize = SSRStepSize * abs(RayOrigin.z) * 0.001;
	ViewStepSize = clamp(ViewStepSize, 0.5, 20.0);  // Clamp to 0.5~20 units

	// Ray march in 3D view space
	float3 CurrentPos = RayOrigin;
	float3 StepDir = RayDir * ViewStepSize;

	for (int i = 1; i <= SSRMaxSteps; i++)
	{
		// Advance one step in view space
		CurrentPos += StepDir;

		// Stop if ray goes behind camera (view space Z is negative for objects in front)
		if (CurrentPos.z > 0.0)
		{
			g_SSRDebugExitReason = 1;
			g_SSRDebugLastPos = CurrentPos;
			return 0.0;
		}

		// Project view space position to screen UV
		float4 ClipPos = mul(float4(CurrentPos, 1.0), ProjectionMatrix);

		// Skip if W is zero (near plane)
		if (abs(ClipPos.w) < 0.001)
		{
			continue;
		}

		// Flip clip space Y for UE UV convention (top=0, bottom=1)
		float2 NDC = ClipPos.xy / ClipPos.w;
		float2 CurrentUV = float2(NDC.x * 0.5 + 0.5, -NDC.y * 0.5 + 0.5);

		// Stop if ray goes off screen
		if (CurrentUV.x < 0.0 || CurrentUV.x > 1.0 ||
		    CurrentUV.y < 0.0 || CurrentUV.y > 1.0)
		{
			g_SSRDebugExitReason = 2;
			g_SSRDebugLastPos = CurrentPos;
			return 0.0;
		}

		// Ray linear depth (convert view space Z to positive)
		float RayDepth = -CurrentPos.z;

		// Sample scene depth
		float SceneDeviceZ = SceneDepthTexture.SampleLevel(InputSampler, CurrentUV, 0).r;
		float SceneLinearDepth = ConvertFromDeviceZ(SceneDeviceZ);

		// Store debug info
		g_SSRDebugLastPos = CurrentPos;
		g_SSRDebugLastRayDepth = RayDepth;
		g_SSRDebugLastSceneDepth = SceneLinearDepth;

		// Hit test: check if ray passed behind scene geometry
		// Ray depth > Scene depth means ray is behind geometry
		float DepthDiff = RayDepth - SceneLinearDepth;

		// Check if ray passed through geometry
		bool bBehind = DepthDiff > 0.0;
		bool bWithinThickness = DepthDiff < SSRThickness * SceneLinearDepth * 0.1;

		if (bBehind && bWithinThickness)
		{
			// Hit!
			OutHitUV = CurrentUV;
			OutHitColor = SceneColorTexture.SampleLevel(InputSampler, CurrentUV, 0).rgb;

			// Calculate screen edge fade
			float2 EdgeDist = min(CurrentUV, 1.0 - CurrentUV);
			float EdgeFade = saturate(min(EdgeDist.x, EdgeDist.y) / max(SSREdgeFade, 0.01));

			// Distance fade (weaker at longer distances)
			float DistanceFade = saturate(1.0 - float(i) / float(SSRMaxSteps));

			// Grazing angle fade (weaker when reflection is parallel to screen)
			float GrazingFade = saturate(abs(RayDir.z) * 2.0);

			return EdgeFade * DistanceFade * GrazingFade;
		}
	}

	return 0.0;
}

// -----------------------------------------------------------------------------
// Pixel Shader
// -----------------------------------------------------------------------------

void MainPS(
	FCompositeVSToPS Input,
	out float4 OutColor : SV_Target0)
{
	float2 UV = Input.UV;

	// 1. Sample fluid depth (assumed to be linear depth)
	float FluidDepth = FluidDepthTexture.Sample(InputSampler, UV);

	// Handle background (no fluid)
	// FluidDepth is initialized to a very large value (e.g., 3.4e38)
	if (FluidDepth > BACKGROUND_DEPTH_THRESH)
	{
		discard;
		return;
	}

	// 2. Get scene depth (DeviceZ -> Linear)
	float SceneDeviceZ = SceneDepthTexture.SampleLevel(InputSampler, UV, 0).r;
	float SceneLinearDepth = ConvertFromDeviceZ(SceneDeviceZ);

	// 3. Occlusion test
	// Add bias to account for precision differences between FluidDepth and SceneLinearDepth
	if (FluidDepth > SceneLinearDepth + 2.0f)
	{
		discard;
		return;
	}

	// 4. Sample fluid properties
	float3 Normal = FluidNormalTexture.Sample(InputSampler, UV).xyz;
	float Thickness = FluidThicknessTexture.Sample(InputSampler, UV).r;

	// Normal validation with proper NaN/Inf check
	// Note: length(NaN) returns NaN, and NaN < 0.1f is always false
	// So we must explicitly check for NaN/Inf before length comparison
	bool bInvalidNormal = any(isnan(Normal)) || any(isinf(Normal)) || length(Normal) < 0.1f;
	if (bInvalidNormal)
	{
		// Default to view-facing normal
		Normal = float3(0, 0, 1);
	}
	else
	{
		// FluidNormal.usf stores Normal with Z < 0 (toward camera)
		// But our ViewDir has Z > 0 (toward camera)
		// Negate Normal to match coordinate system
		Normal = -Normal;
	}

	// 5. Prepare lighting calculations
	float3 ViewPos = ReconstructViewPosition(UV, FluidDepth);
	float3 ViewDir = normalize(-ViewPos);  // Direction toward camera

	// A. Fresnel (Schlick's approximation with IOR-based F0)
	// ========================================================================
	// IOR to F0: F0 = ((1 - n) / (1 + n))^2
	// Water (IOR=1.33): F0 ~ 0.02, Glass (IOR=1.5): F0 ~ 0.04
	// FresnelStrength is additional multiplier (1.0 = physically accurate)
	// ========================================================================
	float NoV = saturate(dot(Normal, ViewDir));
	float IOR_F0 = pow((1.0 - RefractiveIndex) / (1.0 + RefractiveIndex), 2.0);
	float F0 = IOR_F0 * FresnelStrength;
	float Fresnel = F0 + (1.0 - F0) * pow(1.0 - NoV, 5.0);

	// B. Diffuse + Specular (Phong Shading) - using scene's actual directional light
	float3 LightDir = normalize(-View.DirectionalLightDirection);
	float3 LightColor = View.DirectionalLightColor.rgb;

	// Diffuse (Lambert)
	float NoL = saturate(dot(Normal, LightDir));
	float3 DiffuseLighting = NoL * LightColor;

	// Ambient (prevents completely dark surfaces)
	float3 AmbientColor = EnvironmentLightColor.rgb * AmbientScale;

	// Total Lighting
	float3 TotalLighting = DiffuseLighting + AmbientColor;

	// Specular (Blinn-Phong)
	float3 HalfDir = normalize(LightDir + ViewDir);
	float NoH = saturate(dot(Normal, HalfDir));

	// Convert roughness to shininess (low roughness = high shininess = sharp highlights)
	float Shininess = (1.0 - SpecularRoughness) * 128.0;
	float3 Specular = pow(NoH, Shininess) * SpecularStrength * LightColor;

	// C. Subsurface Scattering (SSS) - Jelly Effect
	// ========================================================================
	// Rim-based SSS: Light transmits through at edges (where NoV is small)
	// - RimFactor: Larger at edges (1.0 - NoV)
	// - Thickness coupling: Stronger transmission in thin areas
	// ========================================================================
	float RimFactor = 1.0 - NoV;
	float ThicknessSSSMask = exp(-Thickness * 0.05);  // Stronger SSS in thin areas
	float SSSFactor = smoothstep(0.3, 1.0, RimFactor) * SSSIntensity * ThicknessSSSMask * 0.5;
	float3 SSSContribution = SSSColor.rgb * SSSFactor * LightColor;

	// ========================================================================
	// Color Compositing (Flex-style Simple Approach)
	// ========================================================================
	float3 FinalColor;

	// 1. Sample scene color (background)
	float3 SceneColor = SceneColorTexture.Sample(InputSampler, UV).rgb;

	// 2. Sample refracted background color (with Refraction Mask)
	// ========================================================================
	// Refraction Mask: Reduce refraction at thin/edge areas to prevent excessive distortion
	// - ThicknessMask: Weaker refraction in thin areas
	// - EdgeMask: Weaker refraction at edges (where Normal.z is small)
	// ========================================================================
	float ThicknessMask = saturate(Thickness * 0.1);  // Thickness-based (small when thin)
	float EdgeMask = saturate(abs(Normal.z) * 2.0);   // Edge-based (small at edges)
	float RefractionMask = ThicknessMask * EdgeMask;

	// Calculate refraction offset (with thickness/edge mask)
	float2 RefractOffset = Normal.xy * RefractiveIndex * RefractionScale * RefractionMask;
	float2 RefractedUV = UV + RefractOffset;
	RefractedUV = saturate(RefractedUV);

	// Check depth at refracted UV position
	float RefractedSceneDepth = ConvertFromDeviceZ(SceneDepthTexture.SampleLevel(InputSampler, RefractedUV, 0).r);

	// Soft refraction validity check:
	// 1. Refracted position must be behind fluid (not sampling objects in front of fluid)
	// 2. Refracted position should not suddenly show much closer objects than original UV
	// 3. Fade out refraction near screen edges (avoid sampling clamped edge pixels)
	// Using soft transitions to avoid hard edge artifacts
	float DepthMargin = 20.0;
	float BehindFluidFactor = saturate((RefractedSceneDepth - FluidDepth + DepthMargin) / DepthMargin);
	float NotPullingForwardFactor = saturate((RefractedSceneDepth - SceneLinearDepth + DepthMargin) / DepthMargin);

	// Screen edge fade: reduce refraction when refracted UV approaches screen boundary
	float2 EdgeDist = min(RefractedUV, 1.0 - RefractedUV);
	float ScreenEdgeFade = saturate(min(EdgeDist.x, EdgeDist.y) / 0.05);  // Fade over 5% of screen edge

	float RefractionValidity = BehindFluidFactor * NotPullingForwardFactor * ScreenEdgeFade;

	// Soft blend between original UV and refracted UV
	float2 FinalRefractUV = lerp(UV, RefractedUV, RefractionValidity);

	float3 RefractedBackground = SceneColorTexture.Sample(InputSampler, FinalRefractUV).rgb;

	// 3. Beer's Law: Calculate per-channel transmittance based on thickness
	// T(λ) = exp(-σ(λ) * thickness)
	// Each color channel has different absorption coefficient
	// Water: absorbs more R -> appears blue
	// Slime: absorbs more B -> appears green/yellow
	float3 AbsorptionRGB = AbsorptionColorCoefficients.rgb * AbsorptionCoefficient;
	float3 Transmittance = exp(-AbsorptionRGB * Thickness * TransmittanceScale);

	// Calculate transmitted background color
	float3 TransmittedBackground = RefractedBackground * Transmittance;

	// 4. Blend background with fluid color
	// Thicker fluid shows more of its intrinsic color
	float OverallAbsorption = 1.0 - dot(Transmittance, float3(0.333, 0.333, 0.333));

	// Apply lighting to FluidColor (Phong Shading's Diffuse + Ambient)
	float3 LitFluidColor = FluidColor.rgb * TotalLighting;
	float3 BaseColor = lerp(TransmittedBackground, LitFluidColor, saturate(OverallAbsorption));

	// 5. Fresnel Reflection (SSR + Cubemap Fallback)
	// ========================================================================
	// Reflection priority: SSR Hit -> Cubemap -> Environment Color
	// If SSR misses, fallback to Cubemap; if no Cubemap, use constant color
	// ========================================================================
	float3 ViewSpaceReflect = reflect(-ViewDir, Normal);
	float3 ReflectedColor = float3(0, 0, 0);
	float SSRHitStrength = 0.0;

	// Attempt SSR (if enabled)
	if (bEnableSSR > 0)
	{
		float2 SSRHitUV;
		float3 SSRHitColor;
		SSRHitStrength = TraceSSR(ViewPos, ViewSpaceReflect, SSRHitUV, SSRHitColor);

		// DEBUG: SSR debug visualization
		// 0 = disabled, 1 = hit/miss, 2 = reflection direction, 3 = hit sample color
		// 4 = reflection Z direction (green=into scene, red=toward camera)
		// 5 = ray depth vs scene depth comparison
		// 6 = exit reason (red=behind camera, green=off screen, blue=max steps)
		// 7 = Normal visualization, 8 = ViewDir visualization, 9 = ViewPos.z visualization
		#define SSR_DEBUG_MODE 0

		#if SSR_DEBUG_MODE == 1
		// SSR hit/miss: red = hit (intensity varies), blue = miss
		if (SSRHitStrength > 0.0)
		{
			OutColor = float4(SSRHitStrength, 0, 0, 1);  // Red intensity = hit strength
		}
		else
		{
			OutColor = float4(0, 0, 1, 1);  // Blue: Miss
		}
		return;
		#elif SSR_DEBUG_MODE == 2
		// Reflection vector direction as color (RGB = XYZ, 0.5 = 0)
		OutColor = float4(ViewSpaceReflect * 0.5 + 0.5, 1.0);
		return;
		#elif SSR_DEBUG_MODE == 3
		// Direct display of hit color (magenta if miss)
		if (SSRHitStrength > 0.0)
		{
			OutColor = float4(SSRHitColor, 1.0);
		}
		else
		{
			OutColor = float4(1, 0, 1, 1);  // Magenta: Miss
		}
		return;
		#elif SSR_DEBUG_MODE == 4
		// Reflection direction Z component visualization
		// Green = into scene (Z < 0, SSR possible)
		// Red = toward camera (Z > 0, SSR not possible)
		float ReflectZ = ViewSpaceReflect.z;
		if (ReflectZ < 0.0)
		{
			// Into scene - SSR possible (green, intensity shows depth)
			OutColor = float4(0, saturate(-ReflectZ), 0, 1);
		}
		else
		{
			// Toward camera - SSR not possible (red)
			OutColor = float4(saturate(ReflectZ), 0, 0, 1);
		}
		return;
		#elif SSR_DEBUG_MODE == 5
		// Ray depth vs Scene depth comparison
		// R = ray is in front of scene (not hit yet)
		// G = ray is behind scene (passed through)
		// B = scene depth / 1000 (how far the scene is)
		if (SSRHitStrength > 0.0)
		{
			// Hit case - yellow
			OutColor = float4(1, 1, 0, 1);
		}
		else
		{
			float depthDiff = g_SSRDebugLastRayDepth - g_SSRDebugLastSceneDepth;
			float r = (depthDiff < 0.0) ? saturate(-depthDiff / 100.0) : 0.0;  // Ray in front
			float g = (depthDiff > 0.0) ? saturate(depthDiff / 100.0) : 0.0;   // Ray behind
			float b = saturate(g_SSRDebugLastSceneDepth / 5000.0);  // Scene depth
			OutColor = float4(r, g, b, 1);
		}
		return;
		#elif SSR_DEBUG_MODE == 6
		// Exit reason visualization
		if (SSRHitStrength > 0.0)
		{
			OutColor = float4(1, 1, 0, 1);  // Yellow: Hit
		}
		else if (g_SSRDebugExitReason == 1)
		{
			OutColor = float4(1, 0, 0, 1);  // Red: went behind camera
		}
		else if (g_SSRDebugExitReason == 2)
		{
			OutColor = float4(0, 1, 0, 1);  // Green: went off screen
		}
		else
		{
			OutColor = float4(0, 0, 1, 1);  // Blue: max steps reached
		}
		return;
		#elif SSR_DEBUG_MODE == 7
		// Normal visualization (RGB = XYZ, 0.5 = 0)
		OutColor = float4(Normal * 0.5 + 0.5, 1.0);
		return;
		#elif SSR_DEBUG_MODE == 8
		// ViewDir visualization (RGB = XYZ, 0.5 = 0)
		OutColor = float4(ViewDir * 0.5 + 0.5, 1.0);
		return;
		#elif SSR_DEBUG_MODE == 9
		// ViewPos.z visualization (blue = in front of camera, red = behind camera)
		if (ViewPos.z < 0.0)
		{
			OutColor = float4(0, 0, saturate(-ViewPos.z / 1000.0), 1);  // Blue: in front
		}
		else
		{
			OutColor = float4(saturate(ViewPos.z / 1000.0), 0, 0, 1);  // Red: behind (incorrect)
		}
		return;
		#endif

		if (SSRHitStrength > 0.0)
		{
			ReflectedColor = SSRHitColor * SSRIntensity * SSRHitStrength;
		}
	}

	// Cubemap Fallback (SSR miss or partial hit)
	float CubemapBlend = 1.0 - SSRHitStrength * SSRIntensity;
	if (CubemapBlend > 0.01)
	{
		float3 CubemapColor;
		if (bUseReflectionCubemap > 0)
		{
			// View Space -> World Space transform (inverse of View Matrix)
			// ViewMatrix is World->View, so transpose gives View->World (orthogonal matrix)
			float3x3 ViewToWorld = transpose((float3x3)ViewMatrix);
			float3 WorldReflect = mul(ViewSpaceReflect, ViewToWorld);

			// Cubemap sampling (Mip level controls blur)
			float MipLevel = ReflectionMipLevel + SpecularRoughness * 6.0;  // Linked to roughness
			CubemapColor = ReflectionCubemap.SampleLevel(ReflectionCubemapSampler, WorldReflect, MipLevel).rgb;
			CubemapColor *= ReflectionIntensity;
		}
		else
		{
			// Fallback: constant environment light color
			CubemapColor = EnvironmentLightColor.rgb;
		}

		// Blend SSR with Cubemap
		ReflectedColor = lerp(CubemapColor, ReflectedColor, SSRHitStrength * SSRIntensity);
	}

	// Apply Fresnel
	ReflectedColor *= Fresnel;

	// 6. Blend reflection with transmission
	BaseColor = lerp(BaseColor, ReflectedColor, Fresnel * FresnelReflectionBlend);

	// 7. Add Specular + SSS
	FinalColor = BaseColor + Specular + SSSContribution;

	// 8. Alpha calculation
	// Opaque when thick, opaque when reflection is strong
	float Alpha = saturate(1.0 - exp(-Thickness * AlphaThicknessScale));
	Alpha = max(Alpha, Fresnel * FresnelReflectionBlend);

	// C++ BlendState uses (SrcAlpha, InvSrcAlpha)
	// Output RGB without premultiplied alpha
	OutColor = float4(FinalColor, Alpha);
}
