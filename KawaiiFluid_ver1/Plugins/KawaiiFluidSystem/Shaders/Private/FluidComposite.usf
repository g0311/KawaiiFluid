#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidCommon.ush"

// -----------------------------------------------------------------------------
// Parameters
// -----------------------------------------------------------------------------
Texture2D<float> FluidDepthTexture;
Texture2D<float4> FluidNormalTexture;
Texture2D<float> FluidThicknessTexture;
Texture2D<float> SceneDepthTexture;
Texture2D<float4> SceneColorTexture;

SamplerState InputSampler;

float4x4 InverseProjectionMatrix;
float4x4 ProjectionMatrix;
float4x4 ViewMatrix;

float4 FluidColor;
float F0Override;
float FresnelStrength;
float RefractiveIndex;
float AbsorptionCoefficient;
float4 AbsorptionColorCoefficients;  // Per-channel absorption coefficients (Beer's Law)
float SpecularStrength;
float SpecularRoughness;
float4 EnvironmentLightColor;

// Lighting Scale Parameters
float AmbientScale;
float TransmittanceScale;
float AlphaThicknessScale;
float RefractionScale;
float FresnelReflectionBlend;

// Subsurface Scattering (SSS)
float SSSIntensity;
float4 SSSColor;

// Reflection Cubemap
TextureCube ReflectionCubemap;
SamplerState ReflectionCubemapSampler;
float ReflectionIntensity;
float ReflectionMipLevel;
int bUseReflectionCubemap;

// Screen Space Reflections (SSR)
int bEnableSSR;
int SSRMaxSteps;
float SSRStepSize;
float SSRThickness;
float SSRIntensity;
float SSREdgeFade;
int SSRDebugMode;
float2 ViewportSize;

// -----------------------------------------------------------------------------
// Vertex Shader
// -----------------------------------------------------------------------------
struct FCompositeVSToPS
{
	float4 Position : SV_POSITION;
	float2 UV : TEXCOORD0;
};

void MainVS(
	in uint VertexID : SV_VertexID,
	out FCompositeVSToPS Output
)
{
	// Fullscreen Triangle
	float2 UV = float2((VertexID << 1) & 2, VertexID & 2);
	Output.UV = UV;
	Output.Position = float4(UV * float2(2, -2) + float2(-1, 1), 0.5f, 1.0f);
}

// -----------------------------------------------------------------------------
// Helper Functions
// -----------------------------------------------------------------------------

// Background depth threshold (no fluid at very far distances)
#define BACKGROUND_DEPTH_THRESH 100000.0f

/**
 * Reconstruct view space position from screen UV and linear depth.
 * Wrapper for shared function in FluidCommon.ush using global InverseProjectionMatrix.
 */
float3 ReconstructViewPosition(float2 ScreenUV, float LinearDepth)
{
	return ReconstructViewPositionFromDepth(ScreenUV, LinearDepth, InverseProjectionMatrix);
}

/**
 * Project view space position to screen UV.
 * Wrapper for shared function in FluidCommon.ush using global ProjectionMatrix.
 */
float2 ProjectToScreenUV(float3 ViewPos)
{
	return ProjectViewPositionToScreenUV(ViewPos, ProjectionMatrix);
}

// -----------------------------------------------------------------------------
// PBR Functions (Cook-Torrance BRDF)
// -----------------------------------------------------------------------------

/**
 * GGX/Trowbridge-Reitz Normal Distribution Function.
 * Models the statistical distribution of microfacet normals.
 *
 * @param NoH - Dot product of Normal and Half vector
 * @param Roughness - Surface roughness (0 = mirror, 1 = diffuse)
 * @return Distribution term D
 */
float D_GGX(float NoH, float Roughness)
{
	float a = Roughness * Roughness;
	float a2 = a * a;
	float NoH2 = NoH * NoH;

	float denom = NoH2 * (a2 - 1.0) + 1.0;
	return a2 / (PI * denom * denom + 0.0001);
}

/**
 * Schlick-GGX Geometry Function (single direction).
 * Models microfacet self-shadowing.
 *
 * @param NoX - Dot product (NoV or NoL)
 * @param Roughness - Surface roughness
 * @return Geometry term for one direction
 */
float G_SchlickGGX(float NoX, float Roughness)
{
	float r = Roughness + 1.0;
	float k = (r * r) / 8.0;  // Direct lighting remapping

	return NoX / (NoX * (1.0 - k) + k + 0.0001);
}

/**
 * Smith Geometry Function (combined view and light).
 * Combines shadowing from both view and light directions.
 *
 * @param NoV - Dot product of Normal and View direction
 * @param NoL - Dot product of Normal and Light direction
 * @param Roughness - Surface roughness
 * @return Combined geometry term G
 */
float G_Smith(float NoV, float NoL, float Roughness)
{
	return G_SchlickGGX(NoV, Roughness) * G_SchlickGGX(NoL, Roughness);
}

/**
 * Fresnel-Schlick approximation.
 *
 * @param CosTheta - Dot product of Half vector and View direction
 * @param F0 - Reflectance at normal incidence
 * @return Fresnel reflectance
 */
float3 F_Schlick(float CosTheta, float3 F0)
{
	return F0 + (1.0 - F0) * pow(saturate(1.0 - CosTheta), 5.0);
}

/**
 * Cook-Torrance Specular BRDF.
 * Combines D, G, F terms for physically-based specular reflection.
 *
 * @param NoV - Normal dot View
 * @param NoL - Normal dot Light
 * @param NoH - Normal dot Half
 * @param HoV - Half dot View (for Fresnel)
 * @param Roughness - Surface roughness
 * @param F0 - Reflectance at normal incidence
 * @param OutFresnel - Output Fresnel term (for energy conservation)
 * @return Specular BRDF value
 */
float3 CookTorranceBRDF(float NoV, float NoL, float NoH, float HoV, float Roughness, float3 F0, out float3 OutFresnel)
{
	// Distribution
	float D = D_GGX(NoH, Roughness);

	// Geometry
	float G = G_Smith(NoV, NoL, Roughness);

	// Fresnel
	OutFresnel = F_Schlick(HoV, F0);

	// Cook-Torrance specular BRDF
	// f_spec = DGF / (4 * NoV * NoL)
	float3 numerator = D * G * OutFresnel;
	float denominator = 4.0 * NoV * NoL + 0.0001;

	return numerator / denominator;
}

// SSR debug global variables
static float3 g_SSRDebugLastPos = float3(0, 0, 0);
static float g_SSRDebugLastRayDepth = 0;
static float g_SSRDebugLastSceneDepth = 0;
static int g_SSRDebugExitReason = 0;  // 0=max steps, 1=behind camera, 2=off screen
static float g_SSRDebugXYDistance = 0;  // XY distance between ray and scene
static float g_SSRDebugDepthPenetration = 0;  // How far ray penetrated past scene

/**
 * Screen Space Reflection Ray March.
 *
 * Logic:
 * 1. Start at fluid surface position (RayOrigin) in view space
 * 2. March along reflection direction (RayDir)
 * 3. At each step, project position to screen UV
 * 4. Sample scene depth at that UV
 * 5. If ray depth > scene depth (ray passed behind geometry), it's a HIT
 * 6. Sample and return scene color at hit position
 *
 * @param RayOrigin - Ray start point in view space (fluid surface)
 * @param RayDir - Reflection direction in view space (normalized)
 * @param OutHitUV - Screen UV of hit location
 * @param OutHitColor - Scene color at hit location
 * @return Hit strength (0.0 ~ 1.0, with fade applied)
 */
float TraceSSR(float3 RayOrigin, float3 RayDir, out float2 OutHitUV, out float3 OutHitColor)
{
	OutHitUV = float2(0, 0);
	OutHitColor = float3(0, 0, 0);
	g_SSRDebugExitReason = 0;

	// Early exit if reflection points toward camera (can't reflect what's behind camera)
	if (RayDir.z > 0.05)
	{
		g_SSRDebugExitReason = 1;
		return 0.0;
	}

	// Step size calculation
	float StepSize = SSRStepSize * abs(RayOrigin.z) * 0.002;
	StepSize = clamp(StepSize, 1.0, 50.0);

	// Ray march
	float3 CurrentPos = RayOrigin;
	float3 PrevPos = RayOrigin;
	float OriginDepth = -RayOrigin.z;

	for (int i = 1; i <= SSRMaxSteps; i++)
	{
		PrevPos = CurrentPos;
		CurrentPos += RayDir * StepSize;

		// Exit if behind camera
		if (CurrentPos.z > 0.0)
		{
			g_SSRDebugExitReason = 1;
			break;
		}

		// Project to screen UV
		float4 ClipPos = mul(float4(CurrentPos, 1.0), ProjectionMatrix);
		if (abs(ClipPos.w) < 0.001)
		{
			continue;
		}

		float2 CurrentUV = float2(
			ClipPos.x / ClipPos.w * 0.5 + 0.5,
			-ClipPos.y / ClipPos.w * 0.5 + 0.5
		);

		// Exit if off screen
		if (CurrentUV.x < 0.0 || CurrentUV.x > 1.0 || CurrentUV.y < 0.0 || CurrentUV.y > 1.0)
		{
			g_SSRDebugExitReason = 2;
			break;
		}

		// Sample scene depth at projected UV
		float SceneDeviceZ = SceneDepthTexture.SampleLevel(InputSampler, CurrentUV, 0).r;
		float SceneDepth = ConvertFromDeviceZ(SceneDeviceZ);
		float RayDepth = -CurrentPos.z;

		// Reconstruct scene 3D position for debug and hit test
		float3 SceneViewPos = ReconstructViewPosition(CurrentUV, SceneDepth);
		float XYDist = length(CurrentPos.xy - SceneViewPos.xy);

		// Store debug info
		g_SSRDebugLastPos = CurrentPos;
		g_SSRDebugLastRayDepth = RayDepth;
		g_SSRDebugLastSceneDepth = SceneDepth;
		g_SSRDebugDepthPenetration = RayDepth - SceneDepth;
		g_SSRDebugXYDistance = XYDist;

		// Skip sky (very far depth)
		if (SceneDepth > 50000.0)
		{
			// Accelerate through empty space
			StepSize = min(StepSize * 1.5, 100.0);
			continue;
		}

		// Slow down near geometry
		float DepthDiff = SceneDepth - RayDepth;
		if (DepthDiff > 0 && DepthDiff < RayDepth * 0.5)
		{
			StepSize = max(StepSize * 0.5, 1.0);
		}

		// ========================================================================
		// HIT TEST: Ray passed behind scene geometry?
		// ========================================================================
		// SSR works in SCREEN SPACE: if ray projects to same UV and passes
		// behind scene depth, that's a hit. No 3D XY comparison needed.
		// ========================================================================
		if (RayDepth > SceneDepth)
		{
			// Check thickness (don't hit if we overshot too far)
			float Penetration = RayDepth - SceneDepth;
			float MaxPenetration = SSRThickness * SceneDepth * 0.1;

			if (Penetration < MaxPenetration)
			{
				// Binary search refinement for accurate hit position
				float3 Lo = PrevPos;
				float3 Hi = CurrentPos;
				float2 HitUV = CurrentUV;

				for (int j = 0; j < 5; j++)
				{
					float3 Mid = (Lo + Hi) * 0.5;
					float4 MidClip = mul(float4(Mid, 1.0), ProjectionMatrix);
					float2 MidUV = float2(
						MidClip.x / MidClip.w * 0.5 + 0.5,
						-MidClip.y / MidClip.w * 0.5 + 0.5
					);

					if (MidUV.x >= 0 && MidUV.x <= 1 && MidUV.y >= 0 && MidUV.y <= 1)
					{
						float MidSceneZ = ConvertFromDeviceZ(
							SceneDepthTexture.SampleLevel(InputSampler, MidUV, 0).r
						);
						float MidRayZ = -Mid.z;

						if (MidRayZ > MidSceneZ)
						{
							Hi = Mid;
							HitUV = MidUV;
						}
						else
						{
							Lo = Mid;
						}
					}
				}

				// Output hit
				OutHitUV = HitUV;
				OutHitColor = SceneColorTexture.SampleLevel(InputSampler, HitUV, 0).rgb;

				// Fade factors
				float2 EdgeDist = min(HitUV, 1.0 - HitUV);
				float EdgeFade = saturate(min(EdgeDist.x, EdgeDist.y) / max(SSREdgeFade, 0.01));
				float DistFade = saturate(1.0 - float(i) / float(SSRMaxSteps));

				return EdgeFade * DistFade;
			}
		}
	}

	return 0.0;
}

// -----------------------------------------------------------------------------
// Pixel Shader
// -----------------------------------------------------------------------------

void MainPS(
	FCompositeVSToPS Input,
	out float4 OutColor : SV_Target0)
{
	float2 UV = Input.UV;

	// 1. Sample fluid depth (assumed to be linear depth)
	float FluidDepth = FluidDepthTexture.Sample(InputSampler, UV);

	// Handle background (no fluid)
	// FluidDepth is initialized to a very large value (e.g., 3.4e38)
	if (FluidDepth > BACKGROUND_DEPTH_THRESH)
	{
		discard;
		return;
	}

	// 2. Get scene depth (DeviceZ -> Linear)
	float SceneDeviceZ = SceneDepthTexture.SampleLevel(InputSampler, UV, 0).r;
	float SceneLinearDepth = ConvertFromDeviceZ(SceneDeviceZ);

	// 3. Occlusion test - discard fluid pixels behind scene geometry
	if (FluidDepth > SceneLinearDepth)
	{
		discard;
		return;
	}

	// 4. Sample fluid properties
	float3 Normal = FluidNormalTexture.Sample(InputSampler, UV).xyz;
	float Thickness = FluidThicknessTexture.Sample(InputSampler, UV).r;

	// Normal validation with proper NaN/Inf check
	bool bInvalidNormal = any(isnan(Normal)) || any(isinf(Normal)) || length(Normal) < 0.1f;
	if (bInvalidNormal)
	{
		Normal = float3(0, 0, 1);
	}
	else
	{
		Normal = normalize(Normal);
	}

	// 5. Prepare lighting calculations
	float3 ViewPos = ReconstructViewPosition(UV, FluidDepth);
	float3 ViewDir = normalize(-ViewPos);  // Direction toward camera (positive Z)

	// Ensure normal faces camera for lighting (dot > 0)
	// This is needed because FluidNormal.usf may output normals facing either direction
	if (dot(Normal, ViewDir) < 0.0)
	{
		Normal = -Normal;
	}

	// Grazing angle compensation for lighting stability
	float RawNoV = saturate(dot(Normal, ViewDir));
	float GrazingFade = smoothstep(0.0, 0.15, RawNoV);
	float3 LightingNormal = normalize(lerp(ViewDir, Normal, GrazingFade));

	// For SSR: Use the corrected normal directly
	// FluidNormal.usf now uses the same coordinate convention as this shader
	// (Y-axis flipped: UV.y=0 maps to ClipY=1)
	float3 ReflectionNormal = Normal;

	// A. PBR Setup
	// ========================================================================
	// F0 (base reflectivity at normal incidence):
	// - F0Override > 0: Use artist-defined value directly
	// - F0Override = 0: Auto-calculate from IOR: F0 = ((1-n)/(1+n))^2 * FresnelStrength
	// Water (IOR=1.33): F0 ~ 0.02, Glass (IOR=1.5): F0 ~ 0.04
	// Fluids are dielectric (non-metallic), so F0 is uniform across RGB
	// ========================================================================
	float NoV = saturate(dot(LightingNormal, ViewDir));
	float FinalF0;
	if (F0Override > 0.0)
	{
		FinalF0 = F0Override;
	}
	else
	{
		float IOR_Ratio = (1.0 - RefractiveIndex) / (1.0 + RefractiveIndex);
		FinalF0 = IOR_Ratio * IOR_Ratio * FresnelStrength;
	}
	float3 F0 = float3(FinalF0, FinalF0, FinalF0);

	// B. PBR Lighting (Cook-Torrance BRDF) - using scene's actual directional light
	float3 LightDir = normalize(-View.DirectionalLightDirection);
	float3 LightColor = View.DirectionalLightColor.rgb;

	// Common dot products (use LightingNormal for stable shading)
	float NoL = saturate(dot(LightingNormal, LightDir));
	float3 HalfDir = normalize(LightDir + ViewDir);
	float NoH = saturate(dot(LightingNormal, HalfDir));
	float HoV = saturate(dot(HalfDir, ViewDir));

	// Roughness (clamp to avoid divide by zero in GGX)
	float Roughness = max(SpecularRoughness, 0.04);

	// Cook-Torrance Specular BRDF
	float3 SpecularFresnel;
	float3 SpecularBRDF = CookTorranceBRDF(NoV, NoL, NoH, HoV, Roughness, F0, SpecularFresnel);
	float3 Specular = SpecularBRDF * LightColor * NoL * SpecularStrength;

	// Energy Conservation: diffuse is reduced by specular reflection
	// kD = 1 - kS (for dielectrics, metallic = 0)
	float3 kD = 1.0 - SpecularFresnel;

	// Diffuse (Lambert with energy conservation)
	float3 DiffuseLighting = kD * NoL * LightColor;

	// Ambient (prevents completely dark surfaces)
	float3 AmbientColor = EnvironmentLightColor.rgb * AmbientScale;

	// Total Lighting (diffuse + ambient, specular added separately)
	float3 TotalLighting = DiffuseLighting + AmbientColor;

	// Fresnel for reflection (use NoV-based Fresnel for environment reflections)
	// Standard Schlick Fresnel with F0 already scaled by FresnelStrength
	float Fresnel = F0.r + (1.0 - F0.r) * pow(1.0 - NoV, 5.0);

	// C. Subsurface Scattering (SSS) - Jelly Effect
	// ========================================================================
	// Rim-based SSS: Light transmits through at edges (where NoV is small)
	// - RimFactor: Larger at edges (1.0 - NoV)
	// - Thickness coupling: Stronger transmission in thin areas
	// ========================================================================
	float RimFactor = 1.0 - NoV;
	float ThicknessSSSMask = exp(-Thickness * 0.05);  // Stronger SSS in thin areas
	float SSSFactor = smoothstep(0.3, 1.0, RimFactor) * SSSIntensity * ThicknessSSSMask * 0.5;
	float3 SSSContribution = SSSColor.rgb * SSSFactor * LightColor;

	// ========================================================================
	// Color Compositing (Flex-style Simple Approach)
	// ========================================================================
	float3 FinalColor;

	// 1. Sample scene color (background)
	float3 SceneColor = SceneColorTexture.Sample(InputSampler, UV).rgb;

	// 2. Sample refracted background color (with Refraction Mask)
	// ========================================================================
	// Refraction Mask: Reduce refraction at thin/edge areas to prevent excessive distortion
	// - ThicknessMask: Weaker refraction in thin areas
	// - EdgeMask: Weaker refraction at edges (where Normal.z is small)
	// ========================================================================
	float ThicknessMask = saturate(Thickness * 0.1);  // Thickness-based (small when thin)
	float EdgeMask = saturate(abs(Normal.z) * 2.0);   // Edge-based (small at edges)
	float RefractionMask = ThicknessMask * EdgeMask;

	// Calculate refraction offset (with thickness/edge mask)
	float2 RefractOffset = Normal.xy * RefractiveIndex * RefractionScale * RefractionMask;
	float2 RefractedUV = UV + RefractOffset;
	RefractedUV = saturate(RefractedUV);

	// Check depth at refracted UV position
	float RefractedSceneDepth = ConvertFromDeviceZ(SceneDepthTexture.SampleLevel(InputSampler, RefractedUV, 0).r);

	// Soft refraction validity check:
	// 1. Refracted position must be behind fluid (not sampling objects in front of fluid)
	// 2. Refracted position should not suddenly show much closer objects than original UV
	// 3. Fade out refraction near screen edges (avoid sampling clamped edge pixels)
	// Using soft transitions to avoid hard edge artifacts
	float DepthMargin = 20.0;
	float BehindFluidFactor = saturate((RefractedSceneDepth - FluidDepth + DepthMargin) / DepthMargin);
	float NotPullingForwardFactor = saturate((RefractedSceneDepth - SceneLinearDepth + DepthMargin) / DepthMargin);

	// Screen edge fade: reduce refraction when refracted UV approaches screen boundary
	float2 EdgeDist = min(RefractedUV, 1.0 - RefractedUV);
	float ScreenEdgeFade = saturate(min(EdgeDist.x, EdgeDist.y) / 0.05);  // Fade over 5% of screen edge

	float RefractionValidity = BehindFluidFactor * NotPullingForwardFactor * ScreenEdgeFade;

	// Soft blend between original UV and refracted UV
	float2 FinalRefractUV = lerp(UV, RefractedUV, RefractionValidity);

	float3 RefractedBackground = SceneColorTexture.Sample(InputSampler, FinalRefractUV).rgb;

	// 3. Beer's Law: Calculate per-channel transmittance based on thickness
	// T(λ) = exp(-σ(λ) * thickness)
	// Each color channel has different absorption coefficient
	// Water: absorbs more R -> appears blue
	// Slime: absorbs more B -> appears green/yellow
	float3 AbsorptionRGB = AbsorptionColorCoefficients.rgb * AbsorptionCoefficient;
	float3 Transmittance = exp(-AbsorptionRGB * Thickness * TransmittanceScale);

	// Calculate transmitted background color
	float3 TransmittedBackground = RefractedBackground * Transmittance;

	// 4. Blend background with fluid color
	// Thicker fluid shows more of its intrinsic color
	float OverallAbsorption = 1.0 - dot(Transmittance, float3(0.333, 0.333, 0.333));

	// Apply lighting to FluidColor (PBR Diffuse + Ambient)
	float3 LitFluidColor = FluidColor.rgb * TotalLighting;
	float3 BaseColor = lerp(TransmittedBackground, LitFluidColor, saturate(OverallAbsorption));

	// 5. Fresnel Reflection (SSR + Cubemap Fallback)
	// ========================================================================
	// Reflection priority: SSR Hit -> Cubemap -> Environment Color
	// If SSR misses, fallback to Cubemap; if no Cubemap, use constant color
	// ========================================================================
	float3 ViewSpaceReflect = reflect(-ViewDir, ReflectionNormal);
	float3 ReflectedColor = float3(0, 0, 0);
	float SSRHitStrength = 0.0;

	// Attempt SSR (if enabled)
	if (bEnableSSR > 0)
	{
		float2 SSRHitUV;
		float3 SSRHitColor;
		SSRHitStrength = TraceSSR(ViewPos, ViewSpaceReflect, SSRHitUV, SSRHitColor);

		// DEBUG: SSR debug visualization (runtime switchable via SSRDebugMode)
		// 0 = disabled, 1 = hit/miss, 2 = reflection direction, 3 = hit sample color
		// 4 = reflection Z direction (green=into scene, red=toward camera)
		// 5 = ray depth vs scene depth comparison
		// 6 = exit reason (red=behind camera, green=off screen, blue=max steps)
		// 7 = Normal visualization, 8 = ViewDir visualization, 9 = ViewPos.z visualization
		if (SSRDebugMode == 1)
		{
			// SSR hit/miss: red = hit (intensity varies), blue = miss
			if (SSRHitStrength > 0.0)
			{
				OutColor = float4(SSRHitStrength, 0, 0, 1);  // Red intensity = hit strength
			}
			else
			{
				OutColor = float4(0, 0, 1, 1);  // Blue: Miss
			}
			return;
		}
		else if (SSRDebugMode == 2)
		{
			// Reflection vector direction as color (RGB = XYZ, 0.5 = 0)
			OutColor = float4(ViewSpaceReflect * 0.5 + 0.5, 1.0);
			return;
		}
		else if (SSRDebugMode == 3)
		{
			// Direct display of hit color (magenta if miss)
			if (SSRHitStrength > 0.0)
			{
				OutColor = float4(SSRHitColor, 1.0);
			}
			else
			{
				OutColor = float4(1, 0, 1, 1);  // Magenta: Miss
			}
			return;
		}
		else if (SSRDebugMode == 4)
		{
			// Reflection direction Z component visualization
			// Green = into scene (Z < 0, SSR possible)
			// Red = toward camera (Z > 0, SSR not possible)
			float ReflectZ = ViewSpaceReflect.z;
			if (ReflectZ < 0.0)
			{
				// Into scene - SSR possible (green, intensity shows depth)
				OutColor = float4(0, saturate(-ReflectZ), 0, 1);
			}
			else
			{
				// Toward camera - SSR not possible (red)
				OutColor = float4(saturate(ReflectZ), 0, 0, 1);
			}
			return;
		}
		else if (SSRDebugMode == 5)
		{
			// 3D hit test visualization (new corrected logic)
			// R = XY distance (how far ray XY is from scene XY)
			// G = Depth penetration (positive = penetrated)
			// B = hit (yellow if hit)
			if (SSRHitStrength > 0.0)
			{
				// Hit case - yellow
				OutColor = float4(1, 1, 0, 1);
			}
			else
			{
				float r = saturate(g_SSRDebugXYDistance / 100.0);  // XY distance
				float g = saturate(g_SSRDebugDepthPenetration / 50.0);  // Penetration (positive = past)
				float b = (g_SSRDebugDepthPenetration < 0.0) ? saturate(-g_SSRDebugDepthPenetration / 50.0) : 0.0;  // Not yet penetrated
				OutColor = float4(r, g, b, 1);
			}
			return;
		}
		else if (SSRDebugMode == 6)
		{
			// Exit reason visualization
			if (SSRHitStrength > 0.0)
			{
				OutColor = float4(1, 1, 0, 1);  // Yellow: Hit
			}
			else if (g_SSRDebugExitReason == 1)
			{
				OutColor = float4(1, 0, 0, 1);  // Red: went behind camera
			}
			else if (g_SSRDebugExitReason == 2)
			{
				OutColor = float4(0, 1, 0, 1);  // Green: went off screen
			}
			else
			{
				OutColor = float4(0, 0, 1, 1);  // Blue: max steps reached
			}
			return;
		}
		else if (SSRDebugMode == 7)
		{
			// Normal visualization (RGB = XYZ, 0.5 = 0)
			OutColor = float4(Normal * 0.5 + 0.5, 1.0);
			return;
		}
		else if (SSRDebugMode == 8)
		{
			// ViewDir visualization (RGB = XYZ, 0.5 = 0)
			OutColor = float4(ViewDir * 0.5 + 0.5, 1.0);
			return;
		}
		else if (SSRDebugMode == 9)
		{
			// ViewPos.z visualization (blue = in front of camera, red = behind camera)
			if (ViewPos.z < 0.0)
			{
				OutColor = float4(0, 0, saturate(-ViewPos.z / 1000.0), 1);  // Blue: in front
			}
			else
			{
				OutColor = float4(saturate(ViewPos.z / 1000.0), 0, 0, 1);  // Red: behind (incorrect)
			}
			return;
		}
		else if (SSRDebugMode == 10)
		{
			// Fresnel value visualization (white = high fresnel, black = low)
			OutColor = float4(Fresnel, Fresnel, Fresnel, 1.0);
			return;
		}
		else if (SSRDebugMode == 11)
		{
			// Parameter debug: R = FresnelStrength/10, G = FresnelReflectionBlend, B = Fresnel
			OutColor = float4(FresnelStrength / 10.0, FresnelReflectionBlend, Fresnel, 1.0);
			return;
		}
		else if (SSRDebugMode == 12)
		{
			// Final reflection blend factor: Fresnel * FresnelReflectionBlend
			float BlendFactor = Fresnel * FresnelReflectionBlend;
			OutColor = float4(BlendFactor, BlendFactor, BlendFactor, 1.0);
			return;
		}
		else if (SSRDebugMode == 13)
		{
			// SSR hit analysis (depth-only)
			// Yellow = HIT
			// Blue = ray in front of scene (not penetrated yet)
			// Red = penetrated but overshot (too far past geometry)
			// Green = sky/background (ray ended in empty space)
			if (SSRHitStrength > 0.0)
			{
				OutColor = float4(1, 1, 0, 1);  // Yellow: HIT!
			}
			else
			{
				bool bIsSky = g_SSRDebugLastSceneDepth > 50000.0;
				float Penetration = g_SSRDebugDepthPenetration;
				float MaxPenetration = SSRThickness * g_SSRDebugLastSceneDepth * 0.1;

				if (bIsSky)
				{
					OutColor = float4(0, 0.5, 0, 1);  // Dark Green: sky
				}
				else if (Penetration <= 0.0)
				{
					OutColor = float4(0, 0, 1, 1);  // Blue: not penetrated
				}
				else if (Penetration > MaxPenetration)
				{
					OutColor = float4(1, 0, 0, 1);  // Red: overshot
				}
				else
				{
					OutColor = float4(1, 0, 1, 1);  // Magenta: bug
				}
			}
			return;
		}
		else if (SSRDebugMode == 14)
		{
			// SSR hit UV visualization
			// R = hit UV.x, G = hit UV.y, B = hit strength
			// This shows WHERE the SSR is sampling from
			if (SSRHitStrength > 0.0)
			{
				OutColor = float4(SSRHitUV.x, SSRHitUV.y, SSRHitStrength, 1.0);
			}
			else
			{
				// No hit - show dark blue
				OutColor = float4(0, 0, 0.2, 1);
			}
			return;
		}

		if (SSRHitStrength > 0.0)
		{
			// SSRIntensity = artist strength control
			// SSRHitStrength used only for blend factor below (not multiplied twice)
			ReflectedColor = SSRHitColor * SSRIntensity;
		}
	}

	// Cubemap Fallback (SSR miss or partial hit)
	// SSRHitStrength determines blend: 0 = full cubemap, 1 = full SSR
	if (SSRHitStrength < 0.99)
	{
		float3 CubemapColor;
		if (bUseReflectionCubemap > 0)
		{
			// View Space -> World Space transform (inverse of View Matrix)
			// ViewMatrix is World->View, so transpose gives View->World (orthogonal matrix)
			float3x3 ViewToWorld = transpose((float3x3)ViewMatrix);
			float3 WorldReflect = mul(ViewSpaceReflect, ViewToWorld);

			// Cubemap sampling (Mip level controls blur)
			float MipLevel = ReflectionMipLevel + SpecularRoughness * 6.0;  // Linked to roughness
			CubemapColor = ReflectionCubemap.SampleLevel(ReflectionCubemapSampler, WorldReflect, MipLevel).rgb;
			CubemapColor *= ReflectionIntensity;
		}
		else
		{
			// Fallback: use a dimmed environment light color for reflection
			// Scale down to avoid overly bright reflections when no cubemap
			CubemapColor = EnvironmentLightColor.rgb * 0.3;
		}

		// Blend SSR with Cubemap based on hit strength
		ReflectedColor = lerp(CubemapColor, ReflectedColor, SSRHitStrength);
	}

	// 6. Blend reflection with transmission
	// Fresnel determines how much reflection vs transmission (physically-based)
	// FresnelReflectionBlend is artist control multiplier
	BaseColor = lerp(BaseColor, ReflectedColor, Fresnel * FresnelReflectionBlend);

	// 7. Add Specular + SSS
	FinalColor = BaseColor + Specular + SSSContribution;

	// 8. Alpha calculation
	// Opaque when thick, slightly more opaque when reflection is strong (at grazing angles)
	float Alpha = saturate(1.0 - exp(-Thickness * AlphaThicknessScale));
	// Only boost alpha at grazing angles (high Fresnel), not everywhere
	// Use a softer contribution from Fresnel to avoid making thin fluid opaque
	float FresnelAlphaBoost = Fresnel * FresnelReflectionBlend * 0.3;  // Reduced from 1.0 to 0.3
	Alpha = max(Alpha, FresnelAlphaBoost);

	// C++ BlendState uses (SrcAlpha, InvSrcAlpha)
	// Output RGB without premultiplied alpha
	OutColor = float4(FinalColor, Alpha);
}
