// Copyright 2026 Team_Bruteforce. All Rights Reserved.

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidCommon.ush"

// -----------------------------------------------------------------------------
// Parameters
// -----------------------------------------------------------------------------
Texture2D<float> FluidDepthTexture;
Texture2D<float4> FluidNormalTexture;
Texture2D<float> FluidThicknessTexture;
Texture2D<float> OcclusionMaskTexture;  // 1.0 = visible, 0.0 = occluded by scene geometry
Texture2D<float> SceneDepthTexture;
Texture2D<float4> SceneColorTexture;

SamplerState InputSampler;
SamplerState PointClampSampler;  // Point sampling for depth textures to avoid edge interpolation artifacts

// UV scaling for SceneColor/SceneDepth (ViewRect / TextureSize)
// Needed when texture size differs from ViewRect (e.g., Screen Percentage)
float2 SceneUVScale;

float4x4 InverseProjectionMatrix;
float4x4 ProjectionMatrix;
float4x4 ViewMatrix;

float4 FluidColor;
float FresnelStrength;
float RefractiveIndex;
float Opacity;                       // Fluid opacity (0 = transparent, 1 = opaque)
float4 AbsorptionColorCoefficients;  // Per-channel absorption coefficients (Beer's Law)
float SpecularStrength;
float SpecularRoughness;
float AmbientIntensity;  // SkyLight contribution scale (default 0.15)
float LightingScale;     // Overall lighting scale for HDR compensation (default 0.2)

// -----------------------------------------------------------------------------
// Multi-Light Support
// Packed as float4 arrays for shader compatibility:
// - LightDirectionsAndIntensity[i] = (Direction.xyz, Intensity)
// - LightColors[i] = (Color.rgb, unused)
// -----------------------------------------------------------------------------
#define FLUID_MAX_LIGHTS 8

int NumLights;  // Number of active lights (0 = use View.DirectionalLight fallback)
float4 LightDirectionsAndIntensity[FLUID_MAX_LIGHTS];
float4 LightColors[FLUID_MAX_LIGHTS];

// Lighting Scale Parameters
float ThicknessSensitivity;          // How much thickness affects transparency (0 = uniform, 1 = thickness-dependent)
int bEnableThicknessClamping;        // 1 = clamp thickness to min/max, 0 = no clamping
float ThicknessMin;                  // Minimum thickness value (when clamping enabled)
float ThicknessMax;                  // Maximum thickness value (when clamping enabled)
float FresnelReflectionBlend;

// Refraction
int bEnableRefraction;               // 1 = enabled, 0 = disabled
float RefractionScale;

// Caustics
int bEnableCaustics;                 // 1 = enabled, 0 = disabled
float CausticIntensity;              // Brightness multiplier for caustic patterns

// Reflection Cubemap
TextureCube ReflectionCubemap;
SamplerState ReflectionCubemapSampler;
float ReflectionIntensity;
float ReflectionMipLevel;
int bUseReflectionCubemap;

// Reflection Mode (0=None, 1=Cubemap, 2=ScreenSpaceReflection, 3=SSR+Cubemap)
int ReflectionMode;
int ScreenSpaceReflectionMaxSteps;
float ScreenSpaceReflectionStepSize;
float ScreenSpaceReflectionThickness;
float ScreenSpaceReflectionIntensity;
float ScreenSpaceReflectionEdgeFade;
int ScreenSpaceReflectionDebugMode;
float2 ViewportSize;

// -----------------------------------------------------------------------------
// Vertex Shader
// -----------------------------------------------------------------------------
struct FCompositeVSToPS
{
	float4 Position : SV_POSITION;
	float2 UV : TEXCOORD0;
};

void MainVS(
	in uint VertexID : SV_VertexID,
	out FCompositeVSToPS Output
)
{
	// Fullscreen Triangle
	float2 UV = float2((VertexID << 1) & 2, VertexID & 2);
	Output.UV = UV;
	Output.Position = float4(UV * float2(2, -2) + float2(-1, 1), 0.5f, 1.0f);
}

// -----------------------------------------------------------------------------
// Helper Functions
// -----------------------------------------------------------------------------

// Background depth threshold (no fluid at very far distances)
#define BACKGROUND_DEPTH_THRESH 100000.0f

/**
 * Reconstruct view space position from screen UV and linear depth.
 * Wrapper for shared function in FluidCommon.ush using global InverseProjectionMatrix.
 */
float3 ReconstructViewPosition(float2 ScreenUV, float LinearDepth)
{
	return ReconstructViewPositionFromDepth(ScreenUV, LinearDepth, InverseProjectionMatrix);
}

/**
 * Project view space position to screen UV.
 * Wrapper for shared function in FluidCommon.ush using global ProjectionMatrix.
 */
float2 ProjectToScreenUV(float3 ViewPos)
{
	return ProjectViewPositionToScreenUV(ViewPos, ProjectionMatrix);
}

// -----------------------------------------------------------------------------
// Volume Scattering Functions
// -----------------------------------------------------------------------------

/**
 * Henyey-Greenstein Phase Function.
 * Models the angular distribution of scattered light.
 *
 * @param CosTheta Cosine of angle between view and light directions (dot(V, -L))
 * @param g Anisotropy parameter: -1 = backscatter, 0 = isotropic, +1 = forward scatter
 * @return Phase function value (probability density)
 */
float HenyeyGreenstein(float CosTheta, float g)
{
	// Prevent division by zero when g approaches ±1
	float g2 = g * g;
	float denom = 1.0 + g2 - 2.0 * g * CosTheta;

	// Avoid numerical issues
	denom = max(denom, 0.0001);

	return (1.0 - g2) / (4.0 * PI * pow(denom, 1.5));
}

/**
 * Schlick Phase Function (faster approximation of Henyey-Greenstein).
 * Use when performance is critical.
 *
 * @param CosTheta Cosine of angle between view and light directions
 * @param g Anisotropy parameter
 * @return Phase function value
 */
float SchlickPhase(float CosTheta, float g)
{
	float k = 1.55 * g - 0.55 * g * g * g;
	float tmp = 1.0 + k * CosTheta;
	return (1.0 - k * k) / (4.0 * PI * tmp * tmp + 0.0001);
}

// -----------------------------------------------------------------------------
// PBR Functions (Cook-Torrance BRDF)
// -----------------------------------------------------------------------------

/**
 * GGX/Trowbridge-Reitz Normal Distribution Function.
 * Models the statistical distribution of microfacet normals.
 *
 * @param NoH Dot product of Normal and Half vector
 * @param Roughness Surface roughness (0 = mirror, 1 = diffuse)
 * @return Distribution term D
 */
float D_GGX(float NoH, float Roughness)
{
	float a = Roughness * Roughness;
	float a2 = a * a;
	float NoH2 = NoH * NoH;

	float denom = NoH2 * (a2 - 1.0) + 1.0;
	return a2 / (PI * denom * denom + 0.0001);
}

/**
 * Schlick-GGX Geometry Function (single direction).
 * Models microfacet self-shadowing.
 *
 * @param NoX Dot product (NoV or NoL)
 * @param Roughness Surface roughness
 * @return Geometry term for one direction
 */
float G_SchlickGGX(float NoX, float Roughness)
{
	float r = Roughness + 1.0;
	float k = (r * r) / 8.0;  // Direct lighting remapping

	return NoX / (NoX * (1.0 - k) + k + 0.0001);
}

/**
 * Smith Geometry Function (combined view and light).
 * Combines shadowing from both view and light directions.
 *
 * @param NoV Dot product of Normal and View direction
 * @param NoL Dot product of Normal and Light direction
 * @param Roughness Surface roughness
 * @return Combined geometry term G
 */
float G_Smith(float NoV, float NoL, float Roughness)
{
	return G_SchlickGGX(NoV, Roughness) * G_SchlickGGX(NoL, Roughness);
}

/**
 * Fresnel-Schlick approximation.
 *
 * For direct lighting (point/directional), CosTheta should be HoV (Half·View).
 * This is physically correct for microfacet theory where each microfacet
 * reflects light along the half vector direction.
 *
 * @param CosTheta Typically dot(HalfVector, ViewDir) for direct lighting
 * @param F0 Reflectance at normal incidence
 * @return Fresnel reflectance
 */
float3 F_Schlick(float CosTheta, float3 F0)
{
	return F0 + (1.0 - F0) * pow(saturate(1.0 - CosTheta), 5.0);
}

/**
 * Cook-Torrance Specular BRDF.
 * Combines D, G, F terms for physically-based specular reflection.
 *
 * @param NoV Normal dot View
 * @param NoL Normal dot Light
 * @param NoH Normal dot Half
 * @param HoV Half dot View (for Fresnel)
 * @param Roughness Surface roughness
 * @param F0 Reflectance at normal incidence
 * @param OutFresnel Output Fresnel term (for energy conservation)
 * @return Specular BRDF value
 */
float3 CookTorranceBRDF(float NoV, float NoL, float NoH, float HoV, float Roughness, float3 F0, out float3 OutFresnel)
{
	// Distribution
	float D = D_GGX(NoH, Roughness);

	// Geometry
	float G = G_Smith(NoV, NoL, Roughness);

	// Fresnel
	OutFresnel = F_Schlick(HoV, F0);

	// Cook-Torrance specular BRDF
	// f_spec = DGF / (4 * NoV * NoL)
	float3 numerator = D * G * OutFresnel;
	float denominator = 4.0 * NoV * NoL + 0.0001;

	return numerator / denominator;
}

// SSR debug global variables
static float g_SSRDebugLastRayDepth = 0;
static float g_SSRDebugLastSceneDepth = 0;
static int g_SSRDebugExitReason = 0;  // 0=max steps, 1=behind camera, 2=off screen
static float g_SSRDebugDepthPenetration = 0;

// -----------------------------------------------------------------------------
// Caustics (Jacobian Method)
// -----------------------------------------------------------------------------

/**
 * Calculate refracted ray hit position on floor plane using Snell's law.
 */
float2 CalculateRefractedFloorHit(float3 SurfacePos, float3 Normal, float3 ViewDir, float FloorZ, float IOR)
{
	// Snell's law: n1 * sin(theta1) = n2 * sin(theta2)
	float eta = 1.0 / IOR;

	float CosThetaI = dot(Normal, ViewDir);
	float Sin2ThetaT = eta * eta * (1.0 - CosThetaI * CosThetaI);

	// Total internal reflection check
	if (Sin2ThetaT > 1.0)
	{
		return SurfacePos.xy;
	}

	float CosThetaT = sqrt(1.0 - Sin2ThetaT);
	float3 RefractDir = eta * (-ViewDir) + (eta * CosThetaI - CosThetaT) * Normal;
	RefractDir = normalize(RefractDir);

	if (abs(RefractDir.z) < 0.001)
	{
		return SurfacePos.xy;
	}

	float t = (FloorZ - SurfacePos.z) / RefractDir.z;
	if (t < 0.0)
	{
		return SurfacePos.xy;
	}

	float3 HitPos = SurfacePos + t * RefractDir;
	return HitPos.xy;
}

/**
 * Calculate caustic intensity using Jacobian determinant.
 */
float CalculateCausticJacobian(
	float2 ScreenUV,
	float3 CenterNormal,
	float FluidDepth,
	float FloorDepth,
	float4x4 ViewMat,
	float IOR,
	float PixelOffset)
{
	float2 PixelSize = 1.0 / ViewportSize;
	float2 Offset = PixelSize * PixelOffset;

	float3x3 ViewToWorld = transpose((float3x3)ViewMat);

	float3 CenterViewPos = ReconstructViewPosition(ScreenUV, FluidDepth);
	float3 CenterWorldPos = mul(CenterViewPos, ViewToWorld);

	float3 CameraWorldPos = mul(float3(0, 0, 0), ViewToWorld);
	float3 ViewDir = normalize(CameraWorldPos - CenterWorldPos);

	float3 FloorViewPos = ReconstructViewPosition(ScreenUV, FloorDepth);
	float3 FloorWorldPos = mul(FloorViewPos, ViewToWorld);
	float FloorZ = FloorWorldPos.z;

	// 8-direction sampling
	const float Diag = 0.707;
	float2 Dirs[8] = {
		float2(1, 0), float2(Diag, Diag), float2(0, 1), float2(-Diag, Diag),
		float2(-1, 0), float2(-Diag, -Diag), float2(0, -1), float2(Diag, -Diag)
	};

	float2 SampleUVs[8];
	for (int i = 0; i < 8; i++)
	{
		SampleUVs[i] = saturate(ScreenUV + Dirs[i] * Offset);
	}

	// Bilinear sampling for smooth results
	float3 Normals[8];
	float Depths[8];
	int ValidCount = 0;

	for (int j = 0; j < 8; j++)
	{
		Normals[j] = FluidNormalTexture.SampleLevel(InputSampler, SampleUVs[j], 0).xyz;
		Depths[j] = FluidDepthTexture.SampleLevel(InputSampler, SampleUVs[j], 0).r;

		if (Depths[j] < BACKGROUND_DEPTH_THRESH && length(Normals[j]) > 0.1)
		{
			Normals[j] = normalize(Normals[j]);
			ValidCount++;
		}
	}

	float EdgeValidity = saturate((float(ValidCount) - 2.0) / 6.0);

	if (ValidCount < 3)
	{
		return 1.0;
	}

	float2 HitCenter = CalculateRefractedFloorHit(CenterWorldPos, CenterNormal, ViewDir, FloorZ, IOR);
	float2 Hits[8];
	float2 OrigPos[8];

	for (int k = 0; k < 8; k++)
	{
		if (Depths[k] < BACKGROUND_DEPTH_THRESH)
		{
			float3 WorldPos = mul(ReconstructViewPosition(SampleUVs[k], Depths[k]), ViewToWorld);
			Hits[k] = CalculateRefractedFloorHit(WorldPos, Normals[k], ViewDir, FloorZ, IOR);
			OrigPos[k] = WorldPos.xz;
		}
		else
		{
			Hits[k] = HitCenter;
			OrigPos[k] = CenterWorldPos.xz;
		}
	}

	// Cardinal Jacobian
	float2 dHit_du_cardinal = (Hits[0] - Hits[4]) / (2.0 * Offset.x);
	float2 dHit_dv_cardinal = (Hits[2] - Hits[6]) / (2.0 * Offset.y);
	float J_cardinal = abs(dHit_du_cardinal.x * dHit_dv_cardinal.y - dHit_du_cardinal.y * dHit_dv_cardinal.x);

	float2 dOrig_du_cardinal = (OrigPos[0] - OrigPos[4]) / (2.0 * Offset.x);
	float2 dOrig_dv_cardinal = (OrigPos[2] - OrigPos[6]) / (2.0 * Offset.y);
	float OrigJ_cardinal = abs(dOrig_du_cardinal.x * dOrig_dv_cardinal.y - dOrig_du_cardinal.y * dOrig_dv_cardinal.x);

	// Diagonal Jacobian
	float DiagScale = 1.414;
	float2 dHit_du_diag = (Hits[1] - Hits[5]) / (2.0 * Offset.x * DiagScale);
	float2 dHit_dv_diag = (Hits[3] - Hits[7]) / (2.0 * Offset.y * DiagScale);
	float J_diag = abs(dHit_du_diag.x * dHit_dv_diag.y - dHit_du_diag.y * dHit_dv_diag.x);

	float2 dOrig_du_diag = (OrigPos[1] - OrigPos[5]) / (2.0 * Offset.x * DiagScale);
	float2 dOrig_dv_diag = (OrigPos[3] - OrigPos[7]) / (2.0 * Offset.y * DiagScale);
	float OrigJ_diag = abs(dOrig_du_diag.x * dOrig_dv_diag.y - dOrig_du_diag.y * dOrig_dv_diag.x);

	float J = (J_cardinal + J_diag) * 0.5;
	float OrigJ = (OrigJ_cardinal + OrigJ_diag) * 0.5;

	float AreaRatio = OrigJ / max(J, 0.0001);
	AreaRatio = clamp(AreaRatio, 0.2, 5.0);

	float Caustic = smoothstep(0.3, 3.0, AreaRatio);
	float Brightness = lerp(0.7, 1.8, Caustic);

	return lerp(1.0, Brightness, EdgeValidity);
}

/**
 * Multi-scale caustic pattern using optical Jacobian.
 */
float CausticPattern(float2 ScreenUV, float3 Normal, float FluidDepth, float FloorDepth,
                     float4x4 ViewMat, float IOR)
{
	float C1 = CalculateCausticJacobian(ScreenUV, Normal, FluidDepth, FloorDepth, ViewMat, IOR, 3.0);
	float C2 = CalculateCausticJacobian(ScreenUV, Normal, FluidDepth, FloorDepth, ViewMat, IOR, 6.0);
	float C3 = CalculateCausticJacobian(ScreenUV, Normal, FluidDepth, FloorDepth, ViewMat, IOR, 12.0);

	float Combined = C1 * 0.25 + C2 * 0.35 + C3 * 0.4;

	return Combined - 1.0;
}

/**
 * Screen Space Reflection using perspective-correct ray march.
 */
float TraceSSR(float3 RayOrigin, float3 RayDir, out float2 OutHitUV, out float3 OutHitColor)
{
	OutHitUV = float2(0, 0);
	OutHitColor = float3(0, 0, 0);
	g_SSRDebugExitReason = 0;

	// Early exit if reflection points toward camera
	if (RayDir.z > 0.1)
	{
		g_SSRDebugExitReason = 1;
		return 0.0;
	}

	// Calculate ray end point
	float RayLength = abs(RayOrigin.z) * 4.0;
	float3 RayEnd = RayOrigin + RayDir * RayLength;

	// Clamp end point to not go behind camera
	if (RayEnd.z > -0.1)
	{
		float t = (-0.1 - RayOrigin.z) / (RayEnd.z - RayOrigin.z);
		RayEnd = RayOrigin + (RayEnd - RayOrigin) * max(t, 0.01);
	}

	// Project start and end to clip space
	float4 StartClip = mul(float4(RayOrigin, 1.0), ProjectionMatrix);
	float4 EndClip = mul(float4(RayEnd, 1.0), ProjectionMatrix);

	// Calculate screen UV for ray length estimation
	float2 StartUV = float2(
		StartClip.x / StartClip.w * 0.5 + 0.5,
		-StartClip.y / StartClip.w * 0.5 + 0.5
	);
	float2 EndUV = float2(
		EndClip.x / EndClip.w * 0.5 + 0.5,
		-EndClip.y / EndClip.w * 0.5 + 0.5
	);

	float2 RayUV = EndUV - StartUV;
	float RayScreenLen = length(RayUV * ViewportSize);

	if (RayScreenLen < 1.0)
	{
		return 0.0;
	}

	int StepCount = ScreenSpaceReflectionMaxSteps;
	float InvStepCount = 1.0 / float(StepCount);

	float StartDepth = -RayOrigin.z;
	float EndDepth = -RayEnd.z;

	float PrevRayDepth = StartDepth;
	float PrevSceneDepth = StartDepth;

	for (int i = 1; i <= StepCount; i++)
	{
		float t = float(i) * InvStepCount;

		// Correct perspective interpolation: lerp in clip space, then perspective divide
		float4 ClipPos = lerp(StartClip, EndClip, t);
		float2 UV = float2(
			ClipPos.x / ClipPos.w * 0.5 + 0.5,
			-ClipPos.y / ClipPos.w * 0.5 + 0.5
		);

		if (any(UV < 0.0) || any(UV > 1.0))
		{
			g_SSRDebugExitReason = 2;
			break;
		}

		// Depth: linear interpolation in view space (RayOrigin.z to RayEnd.z)
		float RayDepth = lerp(StartDepth, EndDepth, t);

		float2 SampleUV = UV * SceneUVScale;
		float SceneDeviceZ = SceneDepthTexture.SampleLevel(PointClampSampler, SampleUV, 0).r;
		float SceneDepth = ConvertFromDeviceZ(SceneDeviceZ);

		g_SSRDebugLastRayDepth = RayDepth;
		g_SSRDebugLastSceneDepth = SceneDepth;
		g_SSRDebugDepthPenetration = RayDepth - SceneDepth;

		if (SceneDepth > 50000.0)
		{
			PrevRayDepth = RayDepth;
			PrevSceneDepth = SceneDepth;
			continue;
		}

		bool bWasInFront = PrevRayDepth <= PrevSceneDepth;
		bool bNowBehind = RayDepth > SceneDepth;

		if (bWasInFront && bNowBehind)
		{
			float Penetration = RayDepth - SceneDepth;
			float MaxThickness = ScreenSpaceReflectionThickness * SceneDepth * 0.05;

			if (Penetration < MaxThickness)
			{
				// Binary search refinement
				float tLo = float(i - 1) * InvStepCount;
				float tHi = t;
				float2 HitUV = UV;

				for (int j = 0; j < 8; j++)
				{
					float tMid = (tLo + tHi) * 0.5;

					// Clip space interpolation (same as main loop)
					float4 MidClip = lerp(StartClip, EndClip, tMid);
					float2 MidUV = float2(
						MidClip.x / MidClip.w * 0.5 + 0.5,
						-MidClip.y / MidClip.w * 0.5 + 0.5
					);
					float MidRayDepth = lerp(StartDepth, EndDepth, tMid);

					float2 MidSampleUV = MidUV * SceneUVScale;
					float MidSceneDepth = ConvertFromDeviceZ(
						SceneDepthTexture.SampleLevel(PointClampSampler, MidSampleUV, 0).r
					);

					if (MidRayDepth > MidSceneDepth)
					{
						tHi = tMid;
						HitUV = MidUV;
					}
					else
					{
						tLo = tMid;
					}
				}

				OutHitUV = HitUV;
				OutHitColor = SceneColorTexture.SampleLevel(InputSampler, HitUV * SceneUVScale, 0).rgb;

				float2 ScreenEdgeDist = min(HitUV, 1.0 - HitUV);
				float EdgeFade = saturate(min(ScreenEdgeDist.x, ScreenEdgeDist.y) / max(ScreenSpaceReflectionEdgeFade, 0.01));
				float DistFade = 1.0 - smoothstep(0.5, 1.0, t);
				float AngleFade = saturate(-RayDir.z * 2.5);

				return EdgeFade * DistFade * AngleFade;
			}
		}

		PrevRayDepth = RayDepth;
		PrevSceneDepth = SceneDepth;
	}

	return 0.0;
}

// -----------------------------------------------------------------------------
// Fluid Surface Data Structure
// -----------------------------------------------------------------------------

/** Sampled fluid surface properties at a screen pixel. */
struct FFluidSurfaceData
{
	float  Depth;           // Linear depth from camera
	float3 Normal;          // World-space normal (normalized)
	float  Thickness;       // Accumulated fluid thickness
	float  OcclusionMask;   // 1.0 = visible, 0.0 = occluded
	float3 ViewPos;         // View-space position
	float3 ViewDir;         // Direction toward camera (normalized)
	float3 LightingNormal;  // Grazing-angle compensated normal for stable shading
	float3 ReflectionNormal;// Normal used for reflection calculations
};

/** Accumulated lighting result from PBR calculations. */
struct FLightingResult
{
	float3 Specular;        // Cook-Torrance specular contribution
	float3 Diffuse;         // Lambertian diffuse contribution
	float3 Ambient;         // Environment/ambient light
	float  Fresnel;         // Fresnel term for reflection blending
};

/** Parameters for reflection calculation. */
struct FReflectionResult
{
	float3 Color;           // Final reflection color
	float  BlendFactor;     // How much to blend reflection with base color
	float  SSRHitRatio;     // SSR hit ratio for Mode 3 blending
	float3 CubemapColor;    // Cubemap color (for Mode 3)
	float3 SSRColor;        // SSR color (for Mode 3)
};

// -----------------------------------------------------------------------------
// Fluid Surface Sampling
// -----------------------------------------------------------------------------

/**
 * Sample fluid surface properties from intermediate textures.
 * @param UV Screen UV coordinate
 * @param SceneUV Scene texture UV coordinate (with SceneUVScale applied)
 * @param OutSurface Output surface data
 * @return true if valid fluid pixel, false if background or occluded
 */
bool SampleFluidSurface(float2 UV, float2 SceneUV, out FFluidSurfaceData OutSurface)
{
	// Initialize output
	OutSurface = (FFluidSurfaceData)0;

	// Sample fluid depth (point sampling to avoid edge artifacts)
	OutSurface.Depth = FluidDepthTexture.Sample(PointClampSampler, UV);

	// Discard background pixels (no fluid)
	if (OutSurface.Depth > BACKGROUND_DEPTH_THRESH)
	{
		return false;
	}

	// Check occlusion mask (precomputed in FluidDepth pass)
	OutSurface.OcclusionMask = OcclusionMaskTexture.SampleLevel(PointClampSampler, UV, 0).r;
	if (OutSurface.OcclusionMask < 0.5)
	{
		return false;
	}

	// Sample normal and thickness
	OutSurface.Normal = FluidNormalTexture.Sample(PointClampSampler, UV).xyz;
	OutSurface.Thickness = FluidThicknessTexture.Sample(PointClampSampler, UV).r;

	// Apply thickness clamping if enabled
	if (bEnableThicknessClamping > 0)
	{
		OutSurface.Thickness = clamp(OutSurface.Thickness, ThicknessMin, ThicknessMax);
	}

	// Validate and normalize normal
	bool bInvalidNormal = any(isnan(OutSurface.Normal)) || any(isinf(OutSurface.Normal)) || length(OutSurface.Normal) < 0.1f;
	if (bInvalidNormal)
	{
		OutSurface.Normal = float3(0, 0, 1);
	}
	else
	{
		OutSurface.Normal = normalize(OutSurface.Normal);
	}

	// Reconstruct view-space position and direction
	OutSurface.ViewPos = ReconstructViewPosition(UV, OutSurface.Depth);
	OutSurface.ViewDir = normalize(-OutSurface.ViewPos);

	// Ensure normal faces camera
	if (dot(OutSurface.Normal, OutSurface.ViewDir) < 0.0)
	{
		OutSurface.Normal = -OutSurface.Normal;
	}

	// Grazing angle compensation for stable shading
	float RawNoV = saturate(dot(OutSurface.Normal, OutSurface.ViewDir));
	float GrazingFade = smoothstep(0.0, 0.15, RawNoV);
	OutSurface.LightingNormal = normalize(lerp(OutSurface.ViewDir, OutSurface.Normal, GrazingFade));
	OutSurface.ReflectionNormal = OutSurface.Normal;

	return true;
}

// -----------------------------------------------------------------------------
// PBR Lighting Calculation
// -----------------------------------------------------------------------------

/**
 * Calculate PBR lighting using Cook-Torrance BRDF with multi-light support.
 * @param Surface Fluid surface data
 * @param OutLighting Output lighting result
 */
void CalculatePBRLighting(FFluidSurfaceData Surface, out FLightingResult OutLighting)
{
	OutLighting = (FLightingResult)0;

	// Calculate F0 from IOR
	float NoV = saturate(dot(Surface.LightingNormal, Surface.ViewDir));
	float IOR_Ratio = (1.0 - RefractiveIndex) / (1.0 + RefractiveIndex);
	float FinalF0 = IOR_Ratio * IOR_Ratio * FresnelStrength;
	float3 F0 = float3(FinalF0, FinalF0, FinalF0);

	// Clamp roughness to prevent divide by zero
	float Roughness = max(SpecularRoughness, 0.04);

	// Determine effective light count
	int EffectiveLightCount = (NumLights > 0) ? NumLights : 1;

	// Accumulate lighting from all lights
	for (int LightIndex = 0; LightIndex < EffectiveLightCount; LightIndex++)
	{
		float3 LightDir;
		float3 LightColor;

		if (NumLights > 0)
		{
			float4 DirAndIntensity = LightDirectionsAndIntensity[LightIndex];
			float4 ColorPacked = LightColors[LightIndex];
			LightDir = normalize(-DirAndIntensity.xyz);
			LightColor = ColorPacked.rgb * DirAndIntensity.w;
		}
		else
		{
			LightDir = normalize(-View.DirectionalLightDirection);
			LightColor = View.DirectionalLightColor.rgb;
		}

		// Calculate dot products
		float NoL = saturate(dot(Surface.LightingNormal, LightDir));
		float3 HalfDir = normalize(LightDir + Surface.ViewDir);
		float NoH = saturate(dot(Surface.LightingNormal, HalfDir));
		float HoV = saturate(dot(HalfDir, Surface.ViewDir));

		// Cook-Torrance BRDF
		float3 SpecularFresnel;
		float3 SpecularBRDF = CookTorranceBRDF(NoV, NoL, NoH, HoV, Roughness, F0, SpecularFresnel);
		OutLighting.Specular += SpecularBRDF * LightColor * NoL * SpecularStrength;

		// Energy-conserving diffuse
		float3 kD = 1.0 - SpecularFresnel;
		OutLighting.Diffuse += kD * NoL * LightColor;
	}

	// Apply lighting scale
	OutLighting.Specular *= LightingScale;

	// Calculate ambient
	float3 EnvironmentColor = View.SkyLightColor.rgb;
	if (dot(EnvironmentColor, float3(1, 1, 1)) < 0.001)
	{
		EnvironmentColor = View.DirectionalLightColor.rgb;
	}
	if (dot(EnvironmentColor, float3(1, 1, 1)) < 0.001)
	{
		EnvironmentColor = float3(1.0, 1.0, 1.0);
	}
	OutLighting.Ambient = EnvironmentColor * AmbientIntensity;

	// Calculate Fresnel for environment reflection (using NoV approximation)
	OutLighting.Fresnel = F0.r + (1.0 - F0.r) * pow(1.0 - NoV, 5.0);
}

// -----------------------------------------------------------------------------
// Volume Scattering
// -----------------------------------------------------------------------------

/**
 * Calculate volume scattering contribution using Henyey-Greenstein phase function.
 * @param Surface Fluid surface data
 * @return Scattering color contribution
 */
float3 CalculateVolumeScattering(FFluidSurfaceData Surface)
{
	// Derive scattering parameters from existing properties
	float ScatterAnisotropy = lerp(0.8, 0.2, Opacity);
	float3 ScatterColor = FluidColor.rgb;
	float ScatterStrength = ThicknessSensitivity;

	if (ScatterStrength < 0.001)
	{
		return float3(0, 0, 0);
	}

	float3 Contribution = float3(0, 0, 0);
	int ScatterLightCount = (NumLights > 0) ? NumLights : 1;

	for (int i = 0; i < ScatterLightCount; i++)
	{
		float3 LightDir;
		float3 LightColor;

		if (NumLights > 0)
		{
			float4 DirAndIntensity = LightDirectionsAndIntensity[i];
			float4 ColorPacked = LightColors[i];
			LightDir = normalize(-DirAndIntensity.xyz);
			LightColor = ColorPacked.rgb * DirAndIntensity.w;
		}
		else
		{
			LightDir = normalize(-View.DirectionalLightDirection);
			LightColor = View.DirectionalLightColor.rgb;
		}

		float VoL = dot(Surface.ViewDir, -LightDir);
		float Phase = HenyeyGreenstein(VoL, ScatterAnisotropy);
		float Extinction = 1.0 - exp(-Surface.Thickness * ScatterStrength * 0.1);

		Contribution += ScatterColor * LightColor * Phase * Extinction;
	}

	return Contribution * LightingScale;
}

// -----------------------------------------------------------------------------
// Refraction
// -----------------------------------------------------------------------------

/**
 * Calculate refracted background color with neighbor sampling fallback.
 * When refraction fails (points to object in front of fluid),
 * sample nearby valid refraction pixels and blend their colors.
 *
 * @param UV Screen UV coordinate
 * @param Surface Fluid surface data
 * @param SceneLinearDepth Scene depth at original UV
 * @param OutRefractedColor Output refracted background color
 * @param OutRefractedDepth Output depth at refracted position (for caustics)
 * @param OutRefractionValidity Output validity factor (1.0 if direct refraction, 0.0~1.0 for neighbor blend)
 */
void CalculateRefraction(
	float2 UV,
	FFluidSurfaceData Surface,
	float SceneLinearDepth,
	out float3 OutRefractedColor,
	out float  OutRefractedDepth,
	out float  OutRefractionValidity)
{
	float2 SceneUV = UV * SceneUVScale;

	if (!bEnableRefraction)
	{
		OutRefractedColor = SceneColorTexture.Sample(InputSampler, SceneUV).rgb;
		OutRefractedDepth = SceneLinearDepth;
		OutRefractionValidity = 0.0;
		return;
	}

	// Fluid view position (reference for depth comparison)
	float3 FluidViewPos = ReconstructViewPosition(UV, Surface.Depth);

	// =========================================================================
	// Physics-based refraction using Snell's Law
	// =========================================================================

	// Incident direction: from camera to surface (FluidViewPos IS the direction from origin)
	float3 IncidentDir = normalize(FluidViewPos);

	// Snell's Law: n1 * sin(θ1) = n2 * sin(θ2)
	// eta = n1/n2 = 1.0/IOR (air to fluid)
	float eta = 1.0 / RefractiveIndex;

	// Calculate refracted direction
	float3 RefractDir = refract(IncidentDir, Surface.Normal, eta);

	// Check for total internal reflection
	bool bTotalInternalReflection = (length(RefractDir) < 0.001);

	// Distance to background (depth difference)
	float DistToBackground = max(SceneLinearDepth - Surface.Depth, 1.0);

	// Apparent depth formula: objects underwater appear at reduced depth
	// apparent_depth = real_depth * (n1/n2) where n1=air(1.0), n2=water(IOR)
	// eta = 1.0/IOR is already the ratio we need
	float ApparentDepth = DistToBackground * eta;
	float RefractDistance = ApparentDepth * RefractionScale;

	// Calculate hit position and project to screen
	float3 HitViewPos = FluidViewPos + RefractDir * RefractDistance;
	float2 RefractedUV_Raw = bTotalInternalReflection ? UV : ProjectToScreenUV(HitViewPos);

	// Clamp UV for sampling (no blending with original - refraction only)
	float2 RefractedUV = saturate(RefractedUV_Raw);

	// Check if direct refraction is valid
	float2 RefractedSceneUV = RefractedUV * SceneUVScale;
	float RefractedDepth = ConvertFromDeviceZ(SceneDepthTexture.SampleLevel(PointClampSampler, RefractedSceneUV, 0).r);

	// Reconstruct 3D view space position of the sampled point
	float3 SampleViewPos = ReconstructViewPosition(RefractedUV, RefractedDepth);

	// Vector from fluid surface to sampled point
	float3 FluidToSample = SampleViewPos - FluidViewPos;

	// The sample is valid if it's in the direction of the refracted ray (behind the fluid)
	// If dot product is positive, sample is along refraction direction (behind fluid surface)
	// If dot product is negative, sample is opposite direction (in front of fluid surface)
	float DotWithRefractDir = dot(FluidToSample, RefractDir);

	bool bNotSky = (RefractedDepth < BACKGROUND_DEPTH_THRESH);
	bool bDepthValid = (DotWithRefractDir > 0.0) && bNotSky;

	if (bDepthValid)
	{
		OutRefractedColor = SceneColorTexture.Sample(InputSampler, RefractedSceneUV).rgb;
		OutRefractedDepth = RefractedDepth;
		OutRefractionValidity = 1.0;
		return;
	}

	// Direct refraction failed - sample valid neighbors
	float2 PixelSize = 1.0 / ViewportSize;
	float SearchRadius = 8.0;  // Search radius in pixels

	// 8 directions
	float2 Directions[8] = {
		float2(1, 0), float2(-1, 0), float2(0, 1), float2(0, -1),
		float2(0.707, 0.707), float2(-0.707, 0.707), float2(0.707, -0.707), float2(-0.707, -0.707)
	};

	float3 AccumColor = float3(0, 0, 0);
	float AccumDepth = 0.0;
	float ValidWeight = 0.0;

	for (int i = 0; i < 8; i++)
	{
		// Sample at neighbor position
		float2 NeighborUV = UV + Directions[i] * PixelSize * SearchRadius;
		NeighborUV = saturate(NeighborUV);

		// Get neighbor's fluid depth
		float NeighborFluidDepth = FluidDepthTexture.SampleLevel(PointClampSampler, NeighborUV, 0).r;

		// Skip if no fluid at neighbor
		if (NeighborFluidDepth > BACKGROUND_DEPTH_THRESH)
		{
			continue;
		}

		// Get neighbor's normal for refraction calculation
		float3 NeighborNormal = FluidNormalTexture.SampleLevel(PointClampSampler, NeighborUV, 0).xyz;
		if (length(NeighborNormal) < 0.1)
		{
			continue;
		}
		NeighborNormal = normalize(NeighborNormal);

		// Physics-based refraction for neighbor
		float3 NeighborFluidViewPos = ReconstructViewPosition(NeighborUV, NeighborFluidDepth);
		float3 NeighborIncidentDir = normalize(NeighborFluidViewPos);
		float3 NeighborRefractDir = refract(NeighborIncidentDir, NeighborNormal, eta);

		float2 NeighborSceneUV = NeighborUV * SceneUVScale;
		float NeighborSceneDepth = ConvertFromDeviceZ(SceneDepthTexture.SampleLevel(PointClampSampler, NeighborSceneUV, 0).r);
		float NeighborDistToBackground = max(NeighborSceneDepth - NeighborFluidDepth, 1.0);
		float NeighborApparentDepth = NeighborDistToBackground * eta;
		float NeighborRefractDistance = NeighborApparentDepth * RefractionScale;

		float3 NeighborHitViewPos = NeighborFluidViewPos + NeighborRefractDir * NeighborRefractDistance;
		float2 NeighborRefractedUV = (length(NeighborRefractDir) < 0.001) ? NeighborUV : ProjectToScreenUV(NeighborHitViewPos);
		NeighborRefractedUV = saturate(NeighborRefractedUV);

		// Check if neighbor's refraction is valid
		float2 NeighborRefractedSceneUV = NeighborRefractedUV * SceneUVScale;
		float NeighborRefractedDepth = ConvertFromDeviceZ(SceneDepthTexture.SampleLevel(PointClampSampler, NeighborRefractedSceneUV, 0).r);

		// Reconstruct 3D view space position of neighbor's sampled point
		float3 NeighborSampleViewPos = ReconstructViewPosition(NeighborRefractedUV, NeighborRefractedDepth);

		// Vector from neighbor's fluid surface to sampled point
		float3 NeighborFluidToSample = NeighborSampleViewPos - NeighborFluidViewPos;

		// Check if sample is along refraction direction (behind fluid)
		float NeighborDotWithRefractDir = dot(NeighborFluidToSample, NeighborRefractDir);

		bool bNeighborNotSky = (NeighborRefractedDepth < BACKGROUND_DEPTH_THRESH);
		bool bNeighborValid = (NeighborDotWithRefractDir > 0.0) && bNeighborNotSky;

		// Screen edge check for neighbor
		float2 NeighborEdgeDist = min(NeighborRefractedUV, 1.0 - NeighborRefractedUV);
		bNeighborValid = bNeighborValid && (min(NeighborEdgeDist.x, NeighborEdgeDist.y) > 0.01);

		if (bNeighborValid)
		{
			// Neighbor has valid refraction - accumulate
			float3 NeighborColor = SceneColorTexture.SampleLevel(InputSampler, NeighborRefractedSceneUV, 0).rgb;
			AccumColor += NeighborColor;
			AccumDepth += NeighborRefractedDepth;
			ValidWeight += 1.0;
		}
	}

	if (ValidWeight > 0.0)
	{
		// Use averaged neighbor colors
		OutRefractedColor = AccumColor / ValidWeight;
		OutRefractedDepth = AccumDepth / ValidWeight;
		OutRefractionValidity = ValidWeight / 8.0;  // How many neighbors were valid
	}
	else
	{
		// No valid neighbors - fallback to original scene color
		OutRefractedColor = SceneColorTexture.Sample(InputSampler, SceneUV).rgb;
		OutRefractedDepth = SceneLinearDepth;
		OutRefractionValidity = 0.0;
	}
}

// -----------------------------------------------------------------------------
// Caustics
// -----------------------------------------------------------------------------

/**
 * Calculate caustic brightness multiplier.
 * @param UV Screen UV coordinate
 * @param Surface Fluid surface data
 * @param RefractedDepth Depth at refracted position
 * @param RefractionValidity Whether refraction was used
 * @return Caustic brightness multiplier (1.0 = no effect)
 */
float CalculateCaustics(float2 UV, FFluidSurfaceData Surface, float RefractedDepth, float RefractionValidity)
{
	// Caustics require refraction to be enabled (physically dependent)
	// User's bEnableCaustics choice is preserved in data for when refraction is re-enabled
	if (!bEnableCaustics || !bEnableRefraction)
	{
		return 1.0;
	}

	float Pattern = CausticPattern(UV, Surface.Normal, Surface.Depth, RefractedDepth, ViewMatrix, RefractiveIndex);
	float Brightness = 1.0 + Pattern * CausticIntensity;

	// Fade based on fluid properties
	// RefractionValidity removed - apply caustics even in fallback regions
	float DepthFade = saturate(1.0 - Surface.Depth * 0.0003);
	float ThicknessFade = exp(-Surface.Thickness * 0.015);
	float TransparencyFade = saturate(1.0 - Opacity * 0.7);
	float CausticFade = DepthFade * ThicknessFade * TransparencyFade;

	return lerp(1.0, Brightness, CausticFade);
}

// -----------------------------------------------------------------------------
// Beer's Law Transmittance
// -----------------------------------------------------------------------------

/**
 * Calculate Beer's Law transmittance and blend with fluid color.
 *
 * Beer's Law: T = exp(-μ * c * d)
 *   μ = absorption coefficient (computed from -log(FluidColor) in C++)
 *   c = concentration (Opacity parameter, 0-1)
 *   d = thickness
 *
 * @param RefractedBackground Refracted/caustic-modified background color
 * @param Thickness Fluid thickness at this pixel
 * @param TotalLighting Total lighting (diffuse + ambient)
 * @return Blended base color
 */
float3 CalculateTransmittance(float3 RefractedBackground, float Thickness, float3 TotalLighting)
{
	// Beer's Law: Transmittance = exp(-absorption * concentration * thickness)
	// AbsorptionColorCoefficients = -log(FluidColor), pre-computed in C++
	// Opacity acts as concentration multiplier (0 = fully transparent, 1 = normal density)
	float3 Transmittance = exp(-AbsorptionColorCoefficients.rgb * Opacity * Thickness);

	// Apply transmittance to background
	float3 TransmittedBackground = RefractedBackground * Transmittance;

	// Blend with fluid color based on overall absorption
	// As more light is absorbed, the fluid's own color becomes more visible
	float OverallAbsorption = 1.0 - dot(Transmittance, float3(0.333, 0.333, 0.333));
	float3 LitFluidColor = FluidColor.rgb * TotalLighting;

	return lerp(TransmittedBackground, LitFluidColor, saturate(OverallAbsorption));
}

// -----------------------------------------------------------------------------
// Reflection (Mode-based)
// -----------------------------------------------------------------------------

/**
 * Calculate cubemap reflection color.
 * @param ViewSpaceReflect Reflection vector in view space
 * @return Cubemap reflection color
 */
float3 SampleCubemapReflection(float3 ViewSpaceReflect)
{
	if (bUseReflectionCubemap > 0)
	{
		float3x3 ViewToWorld = transpose((float3x3)ViewMatrix);
		float3 WorldReflect = mul(ViewSpaceReflect, ViewToWorld);
		float MipLevel = ReflectionMipLevel + SpecularRoughness * 6.0;
		return ReflectionCubemap.SampleLevel(ReflectionCubemapSampler, WorldReflect, MipLevel).rgb * ReflectionIntensity;
	}

	// Fallback to environment light
	float3 FallbackColor = View.SkyLightColor.rgb;
	if (dot(FallbackColor, float3(1, 1, 1)) < 0.001)
	{
		FallbackColor = View.DirectionalLightColor.rgb;
	}
	if (dot(FallbackColor, float3(1, 1, 1)) < 0.001)
	{
		FallbackColor = float3(1.0, 1.0, 1.0);
	}
	return FallbackColor * 0.3;
}

/**
 * Handle SSR debug visualization modes.
 * @return true if debug mode handled (should return early), false otherwise
 */
bool HandleSSRDebugVisualization(
	int DebugMode,
	float SSRHitStrength,
	float2 SSRHitUV,
	float3 SSRHitColor,
	float3 ViewSpaceReflect,
	float3 Normal,
	float3 ViewDir,
	float3 ViewPos,
	float Fresnel,
	out float4 OutColor)
{
	OutColor = float4(0, 0, 0, 1);

	if (DebugMode == 1)
	{
		OutColor = (SSRHitStrength > 0.0) ? float4(SSRHitStrength, 0, 0, 1) : float4(0, 0, 1, 1);
		return true;
	}
	else if (DebugMode == 2)
	{
		OutColor = float4(ViewSpaceReflect * 0.5 + 0.5, 1.0);
		return true;
	}
	else if (DebugMode == 3)
	{
		OutColor = (SSRHitStrength > 0.0) ? float4(SSRHitColor, 1.0) : float4(1, 0, 1, 1);
		return true;
	}
	else if (DebugMode == 4)
	{
		float ReflectZ = ViewSpaceReflect.z;
		OutColor = (ReflectZ < 0.0) ? float4(0, saturate(-ReflectZ), 0, 1) : float4(saturate(ReflectZ), 0, 0, 1);
		return true;
	}
	else if (DebugMode == 5)
	{
		if (SSRHitStrength > 0.0)
		{
			OutColor = float4(1, 1, 0, 1);
		}
		else
		{
			float g = saturate(g_SSRDebugDepthPenetration / 50.0);
			float b = (g_SSRDebugDepthPenetration < 0.0) ? saturate(-g_SSRDebugDepthPenetration / 50.0) : 0.0;
			OutColor = float4(0, g, b, 1);
		}
		return true;
	}
	else if (DebugMode == 6)
	{
		if (SSRHitStrength > 0.0)
		{
			OutColor = float4(1, 1, 0, 1);
		}
		else if (g_SSRDebugExitReason == 1)
		{
			OutColor = float4(1, 0, 0, 1);
		}
		else if (g_SSRDebugExitReason == 2)
		{
			OutColor = float4(0, 1, 0, 1);
		}
		else
		{
			OutColor = float4(0, 0, 1, 1);
		}
		return true;
	}
	else if (DebugMode == 7)
	{
		OutColor = float4(Normal * 0.5 + 0.5, 1.0);
		return true;
	}
	else if (DebugMode == 8)
	{
		OutColor = float4(ViewDir * 0.5 + 0.5, 1.0);
		return true;
	}
	else if (DebugMode == 9)
	{
		OutColor = (ViewPos.z < 0.0) ? float4(0, 0, saturate(-ViewPos.z / 1000.0), 1) : float4(saturate(ViewPos.z / 1000.0), 0, 0, 1);
		return true;
	}
	else if (DebugMode == 10)
	{
		OutColor = float4(Fresnel, Fresnel, Fresnel, 1.0);
		return true;
	}
	else if (DebugMode == 11)
	{
		OutColor = float4(FresnelStrength / 10.0, FresnelReflectionBlend, Fresnel, 1.0);
		return true;
	}
	else if (DebugMode == 12)
	{
		float BlendFactor = Fresnel * FresnelReflectionBlend;
		OutColor = float4(BlendFactor, BlendFactor, BlendFactor, 1.0);
		return true;
	}
	else if (DebugMode == 13)
	{
		if (SSRHitStrength > 0.0)
		{
			OutColor = float4(1, 1, 0, 1);
		}
		else
		{
			bool bIsSky = g_SSRDebugLastSceneDepth > 50000.0;
			float Penetration = g_SSRDebugDepthPenetration;
			float MaxPenetration = ScreenSpaceReflectionThickness * g_SSRDebugLastSceneDepth * 0.1;

			if (bIsSky)
			{
				OutColor = float4(0, 0.5, 0, 1);
			}
			else if (Penetration <= 0.0)
			{
				OutColor = float4(0, 0, 1, 1);
			}
			else if (Penetration > MaxPenetration)
			{
				OutColor = float4(1, 0, 0, 1);
			}
			else
			{
				OutColor = float4(1, 0, 1, 1);
			}
		}
		return true;
	}
	else if (DebugMode == 14)
	{
		OutColor = (SSRHitStrength > 0.0) ? float4(SSRHitUV.x, SSRHitUV.y, SSRHitStrength, 1.0) : float4(0, 0, 0.2, 1);
		return true;
	}

	return false;
}

/**
 * Calculate reflection based on ReflectionMode.
 * @param Surface Fluid surface data
 * @param Fresnel Fresnel term
 * @param OutResult Output reflection result
 * @param OutDebugColor Output debug color (if debug mode active)
 * @return true if debug visualization handled (should return early)
 */
bool CalculateReflection(FFluidSurfaceData Surface, float Fresnel, out FReflectionResult OutResult, out float4 OutDebugColor)
{
	OutResult = (FReflectionResult)0;
	OutDebugColor = float4(0, 0, 0, 1);

	float3 ViewSpaceReflect = reflect(-Surface.ViewDir, Surface.ReflectionNormal);

	// Mode 0: No Reflection
	if (ReflectionMode == 0)
	{
		OutResult.BlendFactor = 0.0;
		return false;
	}

	// Mode 1: Cubemap Only
	if (ReflectionMode == 1)
	{
		OutResult.Color = SampleCubemapReflection(ViewSpaceReflect);
		OutResult.BlendFactor = Fresnel * FresnelReflectionBlend;
		return false;
	}

	// Mode 2: SSR Only
	if (ReflectionMode == 2)
	{
		float2 SSRHitUV;
		float3 SSRHitColor;
		float SSRHitStrength = TraceSSR(Surface.ViewPos, ViewSpaceReflect, SSRHitUV, SSRHitColor);

		// Handle debug visualization
		if (ScreenSpaceReflectionDebugMode > 0)
		{
			if (HandleSSRDebugVisualization(
				ScreenSpaceReflectionDebugMode, SSRHitStrength, SSRHitUV, SSRHitColor,
				ViewSpaceReflect, Surface.Normal, Surface.ViewDir, Surface.ViewPos,
				Fresnel, OutDebugColor))
			{
				return true;
			}
		}

		OutResult.Color = (SSRHitStrength > 0.0) ? SSRHitColor * SSRHitStrength : float3(0, 0, 0);
		OutResult.BlendFactor = Fresnel * ScreenSpaceReflectionIntensity * SSRHitStrength;
		return false;
	}

	// Mode 3: SSR + Cubemap Fallback
	if (ReflectionMode == 3)
	{
		float2 SSRHitUV;
		float3 SSRHitColor;
		float SSRHit = TraceSSR(Surface.ViewPos, ViewSpaceReflect, SSRHitUV, SSRHitColor);

		OutResult.CubemapColor = SampleCubemapReflection(ViewSpaceReflect);
		OutResult.SSRColor = SSRHitColor;
		OutResult.SSRHitRatio = SSRHit;
		OutResult.BlendFactor = 1.0;  // Handled specially in composite
		return false;
	}

	return false;
}

/**
 * Blend reflection with base color based on reflection mode.
 * @param BaseColor Input base color
 * @param Fresnel Fresnel term
 * @param Reflection Reflection result
 * @return Blended color
 */
float3 BlendReflection(float3 BaseColor, float Fresnel, FReflectionResult Reflection)
{
	if (ReflectionMode == 3)
	{
		// Mode 3: Blend each reflection type separately, then combine
		float3 CubemapResult = lerp(BaseColor, Reflection.CubemapColor, Fresnel * FresnelReflectionBlend);
		float3 SSRResult = lerp(BaseColor, Reflection.SSRColor, Fresnel * ScreenSpaceReflectionIntensity);
		return lerp(CubemapResult, SSRResult, Reflection.SSRHitRatio);
	}

	return lerp(BaseColor, Reflection.Color, Reflection.BlendFactor);
}

// -----------------------------------------------------------------------------
// Pixel Shader
// -----------------------------------------------------------------------------

void MainPS(
	FCompositeVSToPS Input,
	out float4 OutColor : SV_Target0)
{
	float2 UV = Input.UV;
	float2 SceneUV = UV * SceneUVScale;

	// Sample fluid surface properties
	FFluidSurfaceData Surface;
	if (!SampleFluidSurface(UV, SceneUV, Surface))
	{
		discard;
		return;
	}

	// Get scene depth
	float SceneDeviceZ = SceneDepthTexture.SampleLevel(InputSampler, SceneUV, 0).r;
	float SceneLinearDepth = ConvertFromDeviceZ(SceneDeviceZ);

	// Calculate PBR lighting
	FLightingResult Lighting;
	CalculatePBRLighting(Surface, Lighting);

	// Calculate volume scattering
	float3 VolumeScatter = CalculateVolumeScattering(Surface);

	// Calculate refraction
	float3 RefractedBackground;
	float RefractedDepth;
	float RefractionValidity;
	CalculateRefraction(UV, Surface, SceneLinearDepth, RefractedBackground, RefractedDepth, RefractionValidity);

	// Apply caustics
	float CausticBrightness = CalculateCaustics(UV, Surface, RefractedDepth, RefractionValidity);
	RefractedBackground *= CausticBrightness;

	// Calculate transmittance and base color
	float3 TotalLighting = (Lighting.Diffuse + Lighting.Ambient) * LightingScale;
	float3 BaseColor = CalculateTransmittance(RefractedBackground, Surface.Thickness, TotalLighting);

	// Calculate reflection
	FReflectionResult Reflection;
	float4 DebugColor;
	if (CalculateReflection(Surface, Lighting.Fresnel, Reflection, DebugColor))
	{
		OutColor = DebugColor;
		return;
	}

	// Blend reflection with base color
	BaseColor = BlendReflection(BaseColor, Lighting.Fresnel, Reflection);

	// Final color composition
	float3 FinalColor = BaseColor + Lighting.Specular + VolumeScatter;

	// Apply PreExposure for UE5 HDR pipeline
	FinalColor *= View.PreExposure;

	// Always opaque within fluid region - Beer's Law already handles transparency
	// Original scene is sampled via refraction, not alpha blending
	OutColor = float4(FinalColor, 1.0);
}
