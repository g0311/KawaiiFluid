// Copyright KawaiiFluid Team. All Rights Reserved.
// Common GPU Physics functions and structures for SPH fluid simulation

#pragma once

#include "/Engine/Public/Platform.ush"

//=============================================================================
// GPU Particle Structure (must match FGPUFluidParticle in C++)
//=============================================================================

struct FGPUFluidParticle
{
	float3 Position;           // 12 bytes
	float Mass;                // 4 bytes (total: 16)

	float3 PredictedPosition;  // 12 bytes
	float Density;             // 4 bytes (total: 32)

	float3 Velocity;           // 12 bytes
	float Lambda;              // 4 bytes (total: 48)

	int ParticleID;            // 4 bytes
	int SourceID;              // 4 bytes - Source Component ID (-1 = invalid)
	uint Flags;                // 4 bytes
	uint NeighborCount;        // 4 bytes (total: 64)
};

//=============================================================================
// Source ID Helper (SourceID = Component's unique ID, -1 = invalid)
//=============================================================================

#define SOURCE_INVALID_SOURCE_ID -1

bool HasValidSource(int sourceID)
{
	return sourceID != SOURCE_INVALID_SOURCE_ID;
}

//=============================================================================
// GPU Particle Flags
//=============================================================================

#define GPU_PARTICLE_FLAG_NONE                0
#define GPU_PARTICLE_FLAG_IS_ATTACHED         (1 << 0)
#define GPU_PARTICLE_FLAG_IS_SURFACE          (1 << 1)
#define GPU_PARTICLE_FLAG_IS_CORE             (1 << 2)
#define GPU_PARTICLE_FLAG_JUST_DETACHED       (1 << 3)
#define GPU_PARTICLE_FLAG_NEAR_GROUND         (1 << 4)
#define GPU_PARTICLE_FLAG_HAS_COLLIDED        (1 << 5)
#define GPU_PARTICLE_FLAG_IS_SLEEPING         (1 << 6)


//=============================================================================
// Constants
//=============================================================================

#ifndef PI
#define PI 3.14159265359f
#endif

#ifndef SMALL_NUMBER
#define SMALL_NUMBER 0.0001f
#endif

//=============================================================================
// Unit Conversion Constants
// Unreal uses centimeters, SPH physics uses meters
// Kernel coefficients are precomputed in meters (C++ side)
//=============================================================================
#define CM_TO_M 0.01f
#define CM_TO_M_SQ 0.0001f  // (0.01)^2

//=============================================================================
// SPH Kernel Functions
// Based on: Müller et al. "Particle-Based Fluid Simulation for Interactive Applications"
//=============================================================================

/**
 * Poly6 kernel (for density calculation)
 * W(r, h) = 315 / (64 * PI * h^9) * (h^2 - r^2)^3
 *
 * @param r2 - Squared distance between particles
 * @param h2 - Squared smoothing radius
 * @return Kernel value (NOT multiplied by coefficient)
 */
float Poly6Kernel(float r2, float h2)
{
	float diff = h2 - r2;
	return (diff > 0.0f) ? diff * diff * diff : 0.0f;
}

/**
 * Poly6 kernel with coefficient
 * @param r2 - Squared distance
 * @param h - Smoothing radius
 * @param coeff - Precomputed coefficient (315 / (64 * PI * h^9))
 */
float Poly6KernelWithCoeff(float r2, float h, float coeff)
{
	float h2 = h * h;
	float diff = h2 - r2;
	return (diff > 0.0f) ? coeff * diff * diff * diff : 0.0f;
}

/**
 * Spiky kernel gradient (for pressure calculation)
 * ∇W(r, h) = -45 / (PI * h^6) * (h - |r|)^2 * r̂
 *
 * @param r - Vector from neighbor to particle (particle.pos - neighbor.pos)
 * @param rLen - Length of r
 * @param h - Smoothing radius
 * @return Gradient vector (NOT multiplied by coefficient)
 */
float3 SpikyGradient(float3 r, float rLen, float h)
{
	if (rLen < SMALL_NUMBER)
	{
		return float3(0.0f, 0.0f, 0.0f);
	}

	float diff = h - rLen;
	if (diff <= 0.0f)
	{
		return float3(0.0f, 0.0f, 0.0f);
	}

	// Normalized direction * (h - r)^2
	float3 dir = r / rLen;
	return dir * (diff * diff);
}

/**
 * Spiky gradient with coefficient
 * @param r - Vector from neighbor to particle
 * @param rLen - Length of r
 * @param h - Smoothing radius
 * @param coeff - Precomputed coefficient (-45 / (PI * h^6))
 */
float3 SpikyGradientWithCoeff(float3 r, float rLen, float h, float coeff)
{
	if (rLen < SMALL_NUMBER)
	{
		return float3(0.0f, 0.0f, 0.0f);
	}

	float diff = h - rLen;
	if (diff <= 0.0f)
	{
		return float3(0.0f, 0.0f, 0.0f);
	}

	float3 dir = r / rLen;
	return coeff * (diff * diff) * dir;
}

/**
 * Optimized Spiky gradient using rsqrt (faster inverse square root)
 * Uses rsqrt(r2) instead of sqrt(r2) for better GPU performance
 *
 * @param r - Vector from neighbor to particle (particle.pos - neighbor.pos)
 * @param r2 - Squared length of r (pre-computed)
 * @param h - Smoothing radius
 * @param h2 - Squared smoothing radius (pre-computed)
 * @return Gradient vector (NOT multiplied by coefficient)
 */
float3 SpikyGradientFast(float3 r, float r2, float h, float h2)
{
	// Early exit for particles too close (avoid div by zero)
	if (r2 < SMALL_NUMBER * SMALL_NUMBER)
	{
		return float3(0.0f, 0.0f, 0.0f);
	}

	// rsqrt is faster than sqrt on GPU (uses special function unit)
	// rLenInv = 1 / sqrt(r2)
	float rLenInv = rsqrt(r2);
	float rLen = r2 * rLenInv;  // rLen = r2 / sqrt(r2) = sqrt(r2)

	float diff = h - rLen;
	if (diff <= 0.0f)
	{
		return float3(0.0f, 0.0f, 0.0f);
	}

	// Normalized direction using rsqrt: r * (1/|r|) = r * rsqrt(r2)
	float3 dir = r * rLenInv;
	return dir * (diff * diff);
}

/**
 * Viscosity kernel Laplacian (for viscosity calculation)
 * ∇²W(r, h) = 45 / (PI * h^6) * (h - |r|)
 *
 * @param rLen - Distance between particles
 * @param h - Smoothing radius
 * @param coeff - Precomputed coefficient (45 / (PI * h^6))
 */
float ViscosityLaplacian(float rLen, float h, float coeff)
{
	float diff = h - rLen;
	return (diff > 0.0f) ? coeff * diff : 0.0f;
}

//=============================================================================
// Cohesion / Adhesion Kernels (Akinci et al. 2013)
//=============================================================================

/**
 * Cohesion kernel for surface tension
 * C(r, h) = 32 / (PI * h^9) * ...
 */
float CohesionKernel(float rLen, float h)
{
	if (rLen > h || rLen < SMALL_NUMBER)
	{
		return 0.0f;
	}

	float h2 = h * h;
	float h3 = h2 * h;
	float h9 = h3 * h3 * h3;
	float coeff = 32.0f / (PI * h9);

	float halfH = h * 0.5f;

	if (rLen > halfH)
	{
		float diff = h - rLen;
		return coeff * diff * diff * diff * rLen * rLen * rLen;
	}
	else
	{
		float diff = h - rLen;
		float term1 = 2.0f * diff * diff * diff * rLen * rLen * rLen;
		float term2 = h3 * h3 / 64.0f;
		return coeff * (term1 - term2);
	}
}

/**
 * Adhesion kernel for boundary adhesion
 * Simple linear falloff: r=0 → max, r=h → 0
 */
float AdhesionKernel(float rLen, float h)
{
	if (rLen > h || rLen < 0.0001f)
	{
		return 0.0f;
	}

	// Linear falloff: r=0 → 1 (max), r=h → 0 (escape)
	return 1.0f - (rLen / h);
}

//=============================================================================
// Utility Functions
//=============================================================================

/**
 * Calculate squared distance between two points
 */
float DistanceSquared(float3 a, float3 b)
{
	float3 diff = a - b;
	return dot(diff, diff);
}

/**
 * Clamp position to bounds with collision response
 * @param position - Current position
 * @param velocity - Current velocity (modified on collision)
 * @param boundsMin - Minimum bounds
 * @param boundsMax - Maximum bounds
 * @param restitution - Bounce factor (0-1)
 * @param friction - Friction factor (0-1)
 * @return Clamped position
 */
float3 ClampToBoundsWithResponse(
	float3 position,
	inout float3 velocity,
	float3 boundsMin,
	float3 boundsMax,
	float particleRadius,
	float restitution,
	float friction)
{
	float3 newPos = position;
	float3 effectiveMin = boundsMin + particleRadius;
	float3 effectiveMax = boundsMax - particleRadius;

	// X axis
	if (newPos.x < effectiveMin.x)
	{
		newPos.x = effectiveMin.x;
		velocity.x = -velocity.x * restitution;
		velocity.yz *= (1.0f - friction);
	}
	else if (newPos.x > effectiveMax.x)
	{
		newPos.x = effectiveMax.x;
		velocity.x = -velocity.x * restitution;
		velocity.yz *= (1.0f - friction);
	}

	// Y axis
	if (newPos.y < effectiveMin.y)
	{
		newPos.y = effectiveMin.y;
		velocity.y = -velocity.y * restitution;
		velocity.xz *= (1.0f - friction);
	}
	else if (newPos.y > effectiveMax.y)
	{
		newPos.y = effectiveMax.y;
		velocity.y = -velocity.y * restitution;
		velocity.xz *= (1.0f - friction);
	}

	// Z axis
	if (newPos.z < effectiveMin.z)
	{
		newPos.z = effectiveMin.z;
		velocity.z = -velocity.z * restitution;
		velocity.xy *= (1.0f - friction);
	}
	else if (newPos.z > effectiveMax.z)
	{
		newPos.z = effectiveMax.z;
		velocity.z = -velocity.z * restitution;
		velocity.xy *= (1.0f - friction);
	}

	return newPos;
}

/**
 * Convert flag check to bool
 */
bool HasFlag(uint flags, uint flag)
{
	return (flags & flag) != 0;
}

/**
 * Set flag
 */
uint SetFlag(uint flags, uint flag)
{
	return flags | flag;
}

/**
 * Clear flag
 */
uint ClearFlag(uint flags, uint flag)
{
	return flags & ~flag;
}

//=============================================================================
// GPU Collision Feedback Structure (must match FGPUCollisionFeedback in C++)
// Used for particle -> player interaction readback
// 80 bytes total for drag-based force calculation + impact offset
//=============================================================================

struct FGPUCollisionFeedback
{
	// Row 1: 16 bytes
	int ParticleIndex;       // 4 bytes - Index of the colliding particle
	int ColliderIndex;       // 4 bytes - Index of the collider
	int ColliderType;        // 4 bytes - 0=Sphere, 1=Capsule, 2=Box, 3=Convex
	float Density;           // 4 bytes - Particle density at collision time

	// Row 2: 16 bytes
	float3 ImpactNormal;     // 12 bytes - Collision surface normal
	float Penetration;       // 4 bytes - Penetration depth (cm)

	// Row 3: 16 bytes
	float3 ParticleVelocity; // 12 bytes - Particle velocity (for drag calculation)
	int ColliderOwnerID;     // 4 bytes - Unique ID of collider owner (actor/component)

	// Row 4: 16 bytes 
	int ParticleSourceID;    // 4 bytes - Particle's SourceID (PresetIndex | ComponentIndex << 16)
	int ParticleActorID;     // 4 bytes - Unique ID of particle's owner actor (reserved)
	int BoneIndex;           // 4 bytes - Bone index for per-bone force calculation (-1 = no bone)
	int Padding1;            // 4 bytes - Alignment padding

	// Row 5: 16 bytes
	float3 ImpactOffset;     // 12 bytes - Impact position in bone-local space
	int Padding2;            // 4 bytes - Alignment padding

};

// Collision primitive type constants
#define COLLIDER_TYPE_SPHERE   0
#define COLLIDER_TYPE_CAPSULE  1
#define COLLIDER_TYPE_BOX      2
#define COLLIDER_TYPE_CONVEX   3
