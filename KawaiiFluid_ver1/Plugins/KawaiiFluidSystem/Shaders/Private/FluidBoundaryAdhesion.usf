// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Fluid Physics - Boundary Adhesion Pass
// Applies adhesion forces between fluid particles and boundary particles
// Based on Akinci 2012 "Versatile Rigid-Fluid Coupling"
//
// Two neighbor search modes:
// 1. Z-Order Mode: O(K) neighbor search using Morton-sorted BoundaryCellStart/End
// 2. Legacy Spatial Hash Mode: O(N) with potential hash collisions
//
// Z-Order mode provides collision-free neighbor lookup for better performance

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"
#include "FluidSpatialHash.ush"
#include "FluidMortonUtils.ush"  // For Morton code functions and INVALID_INDEX

//=============================================================================
// Structures (must match C++ definitions)
//=============================================================================

struct FGPUBoundaryParticle
{
	float3 Position;      // 12 bytes - World position
	float Psi;            // 4 bytes  - Boundary particle "mass"
	float3 Normal;        // 12 bytes - Surface normal
	int OwnerID;          // 4 bytes  - Owner component ID
	float3 Velocity;      // 12 bytes - World velocity (for moving boundaries)
	float Padding;        // 4 bytes  - Alignment padding
};

//=============================================================================
// Shader Parameters
//=============================================================================

// Fluid particles
RWStructuredBuffer<FGPUFluidParticle> Particles;
int ParticleCount;

// Boundary particles
StructuredBuffer<FGPUBoundaryParticle> BoundaryParticles;
int BoundaryParticleCount;

// Boundary Spatial Hash (Legacy mode)
StructuredBuffer<uint> BoundaryCellCounts;
StructuredBuffer<uint> BoundaryParticleIndices;
float BoundaryCellSize;

// Z-Order sorted boundary particles (new mode)
StructuredBuffer<FGPUBoundaryParticle> SortedBoundaryParticles;
StructuredBuffer<uint> BoundaryCellStart;  // BoundaryCellStart[mortonCode] = first boundary index
StructuredBuffer<uint> BoundaryCellEnd;    // BoundaryCellEnd[mortonCode] = last boundary index
int bUseBoundaryZOrder;                    // 1 = use Z-Order sorted boundary, 0 = use legacy spatial hash

// Z-Order bounds (must match fluid simulation)
float3 MortonBoundsMin;
float CellSize;  // Cell size for Morton code calculation

// Parameters
float AdhesionForceStrength;
float AdhesionRadius;
float CohesionStrength;
float SmoothingRadius;
float DeltaTime;
float RestDensity;
float Poly6Coeff;

// Boundary Owner AABB for particle-level early-out
// Skip adhesion calculation for particles far from boundary AABB
float3 BoundaryAABBMin;
float3 BoundaryAABBMax;
int bUseBoundaryAABBCulling;

//=============================================================================
// AABB Distance Function for Particle-Level Early-Out
// Returns squared distance from position to AABB (0 if inside)
//=============================================================================
float DistanceSquaredToAABB(float3 testPos, float3 aabbMin, float3 aabbMax)
{
	float3 closestPoint = clamp(testPos, aabbMin, aabbMax);
	float3 diff = testPos - closestPoint;
	return dot(diff, diff);
}

//=============================================================================
// SPH Kernels for Adhesion (Akinci 2013)
// Note: AdhesionKernel and CohesionKernel are defined in FluidGPUPhysics.ush
//=============================================================================

//=============================================================================
// Z-Order Cell ID Calculation (must match FluidSolveDensityPressure.usf)
//=============================================================================
uint GetMortonCellIDFromCellCoord_Adhesion(int3 cellCoord)
{
	// Compute grid minimum cell
	int3 gridMin = int3(floor(MortonBoundsMin / CellSize));

	// Offset cell coordinates to make them positive (relative to grid min)
	int3 offset = cellCoord - gridMin;

	// Clamp to valid range for current preset
	uint3 uoffset = uint3(max(offset, int3(0, 0, 0)));
	uoffset = min(uoffset, uint3(MORTON_MAX_VALUE, MORTON_MAX_VALUE, MORTON_MAX_VALUE));

	// Compute Morton code using preset-specific function from FluidMortonUtils.ush
	return Morton3D(uoffset.x, uoffset.y, uoffset.z);
}

//=============================================================================
// Pass 1: Clear Boundary Hash (Legacy mode only)
//=============================================================================

RWStructuredBuffer<uint> RWBoundaryCellCounts;
RWStructuredBuffer<uint> RWBoundaryParticleIndices;

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ClearBoundaryHashCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint cellIdx = DispatchThreadId.x;
	if (cellIdx >= SPATIAL_HASH_SIZE)
	{
		return;
	}
	RWBoundaryCellCounts[cellIdx] = 0;
}

//=============================================================================
// Pass 2: Build Boundary Hash
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void BuildBoundaryHashCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint particleIdx = DispatchThreadId.x;
	if (particleIdx >= (uint)BoundaryParticleCount)
	{
		return;
	}

	float3 pos = BoundaryParticles[particleIdx].Position;
	int3 cellCoord = WorldToCell(pos, BoundaryCellSize);
	uint cellHash = HashCell(cellCoord);

	uint slot;
	InterlockedAdd(RWBoundaryCellCounts[cellHash], 1, slot);

	if (slot < MAX_PARTICLES_PER_CELL)
	{
		uint baseOffset = cellHash * MAX_PARTICLES_PER_CELL;
		RWBoundaryParticleIndices[baseOffset + slot] = particleIdx;
	}
}

//=============================================================================
// Pass 3: Boundary Adhesion (Force-based, Akinci 2013)
// Applies adhesion and cohesion forces from boundary particles to fluid
//
// Two modes:
// 1. Z-Order Mode: O(K) neighbor search using Morton-sorted BoundaryCellStart/End
// 2. Legacy Spatial Hash Mode: Uses BoundaryCellCounts/BoundaryParticleIndices
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void BoundaryAdhesionCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)ParticleCount)
	{
		return;
	}

	FGPUFluidParticle particle = Particles[idx];

	// Skip if already attached to primitive (existing adhesion system handles this)
	if (HasFlag(particle.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED))
	{
		return;
	}

	float3 pos = particle.PredictedPosition;

	// =========================================================================
	// PARTICLE-LEVEL EARLY-OUT: Skip if particle is far from boundary AABB
	// This reduces unnecessary neighbor searches for particles outside boundary region
	// =========================================================================
	if (bUseBoundaryAABBCulling)
	{
		float distSqToAABB = DistanceSquaredToAABB(pos, BoundaryAABBMin, BoundaryAABBMax);
		// Note: BoundaryAABB is already expanded by AdhesionRadius on CPU side
		// So we just check if particle is outside the expanded AABB
		if (distSqToAABB > 0.0001f)  // Small epsilon to handle floating point precision
		{
			return;  // Particle is outside expanded AABB, no boundary interaction possible
		}
	}

	float3 adhesionForce = float3(0, 0, 0);
	float3 cohesionForce = float3(0, 0, 0);
	float h = AdhesionRadius;  // Use AdhesionRadius for tighter adhesion range
	float weightSum = 0.0f;  // For normalization

	if (bUseBoundaryZOrder)
	{
		//=====================================================================
		// Z-Order Mode: O(K) neighbor search using Morton code
		// SortedBoundaryParticles are sorted by Morton code
		//=====================================================================
		int3 centerCell = WorldToCell(pos, CellSize);
		int cellRadius = (int)ceil(AdhesionRadius / CellSize);  // Use AdhesionRadius

		for (int dz = -cellRadius; dz <= cellRadius; ++dz)
		{
			for (int dy = -cellRadius; dy <= cellRadius; ++dy)
			{
				for (int dx = -cellRadius; dx <= cellRadius; ++dx)
				{
					int3 neighborCell = centerCell + int3(dx, dy, dz);
					uint cellID = GetMortonCellIDFromCellCoord_Adhesion(neighborCell);
					uint bCellStart = BoundaryCellStart[cellID];
					uint bCellEnd = BoundaryCellEnd[cellID];

					// Skip empty cells
					if (bCellStart == INVALID_INDEX || bCellEnd == INVALID_INDEX) continue;

					// Traverse boundary particles in this cell
					uint maxBoundaryIdx = min(bCellEnd, (uint)(BoundaryParticleCount - 1));
					for (uint bi = bCellStart; bi <= maxBoundaryIdx; ++bi)
					{
						FGPUBoundaryParticle boundary = SortedBoundaryParticles[bi];
						float3 r_vec = pos - boundary.Position;
						float r = length(r_vec);

						if (r > 0.0001f && r < h)
						{
							float3 r_normalized = r_vec / r;

							// Distance-based strength: exponential decay
							// r=0 → closeFactor=10.0, very strong at close range
							// r=h → closeFactor≈3.68, still has significant influence at boundary
							float closeFactor = 50.0 * exp(-r / h);

							// Adhesion force (Akinci 2013)
							// F_adhesion = -beta * m_i * psi_b * A(r,h) * r_normalized
							float A = AdhesionKernel(r, h);
							adhesionForce -= AdhesionForceStrength * particle.Mass * closeFactor * A * r_normalized;

							// Cohesion force (surface tension at boundary)
							// F_cohesion = -gamma * m_i * psi_b * C(r,h) * r_normalized
							float C = CohesionKernel(r, h);
							cohesionForce -= CohesionStrength * particle.Mass * closeFactor * C * r_normalized;

							// Accumulate weight for normalization
							weightSum += A;
						}
					}
				}
			}
		}
	}
	else
	{
		//=====================================================================
		// Legacy Spatial Hash Mode: Uses BoundaryCellCounts/BoundaryParticleIndices
		//=====================================================================
		int3 cellCoord = WorldToCell(pos, BoundaryCellSize);

		// Search neighboring cells in boundary spatial hash
		for (int dx = -1; dx <= 1; ++dx)
		{
			for (int dy = -1; dy <= 1; ++dy)
			{
				for (int dz = -1; dz <= 1; ++dz)
				{
					int3 neighborCell = cellCoord + int3(dx, dy, dz);
					uint cellHash = HashCell(neighborCell);
					uint cellCount = min(BoundaryCellCounts[cellHash], MAX_PARTICLES_PER_CELL);
					uint baseOffset = cellHash * MAX_PARTICLES_PER_CELL;

					for (uint i = 0; i < cellCount; ++i)
					{
						uint bi = BoundaryParticleIndices[baseOffset + i];
						if (bi >= (uint)BoundaryParticleCount) continue;

						FGPUBoundaryParticle boundary = BoundaryParticles[bi];
						float3 r_vec = pos - boundary.Position;
						float r = length(r_vec);

						if (r > 0.0001f && r < h)
						{
							float3 r_normalized = r_vec / r;

							// Distance-based strength: exponential decay
							// r=0 → closeFactor=10.0, very strong at close range
							// r=h → closeFactor≈3.68, still has significant influence at boundary
							float closeFactor = 10.0 * exp(-r / h);

							// Adhesion force (Akinci 2013)
							// F_adhesion = -beta * m_i * psi_b * A(r,h) * r_normalized
							float A = AdhesionKernel(r, h);
							adhesionForce -= AdhesionForceStrength * particle.Mass * closeFactor * A * r_normalized;

							// Cohesion force (surface tension at boundary)
							// F_cohesion = -gamma * m_i * psi_b * C(r,h) * r_normalized
							float C = CohesionKernel(r, h);
							cohesionForce -= CohesionStrength * particle.Mass * closeFactor * C * r_normalized;

							// Accumulate weight for normalization
							weightSum += A;
						}
					}
				}
			}
		}
	}

	// Note: Force normalization removed to allow proper force accumulation
	// Previously divided by weightSum which caused weak adhesion with many boundary particles
	// Now forces accumulate naturally - more neighbors = stronger adhesion

	// Apply forces to velocity
	float3 totalForce = adhesionForce + cohesionForce;

	// Clamp force magnitude to prevent instability
	float forceMag = length(totalForce);
	float maxForce = 10000.0f;  // Maximum force magnitude
	if (forceMag > maxForce)
	{
		totalForce = totalForce * (maxForce / forceMag);
	}

	// Apply as velocity change (F = ma, dv = F/m * dt)
	particle.Velocity += totalForce / particle.Mass * DeltaTime;

	Particles[idx] = particle;
}
