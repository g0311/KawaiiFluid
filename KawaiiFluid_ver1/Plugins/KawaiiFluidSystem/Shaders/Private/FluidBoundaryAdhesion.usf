// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Fluid Physics - Boundary Adhesion Pass
// Applies adhesion forces between fluid particles and boundary particles
// Based on Akinci 2012 "Versatile Rigid-Fluid Coupling"
//
// Two neighbor search modes:
// 1. Z-Order Mode: O(K) neighbor search using Morton-sorted BoundaryCellStart/End
// 2. Legacy Spatial Hash Mode: O(N) with potential hash collisions
//
// Z-Order mode provides collision-free neighbor lookup for better performance

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"
#include "FluidSpatialHash.ush"
#include "FluidMortonUtils.ush"  // For Morton code functions and INVALID_INDEX

//=============================================================================
// Structures (must match C++ definitions)
//=============================================================================

struct FGPUBoundaryParticle
{
	float3 Position;      // 12 bytes - World position
	float Psi;            // 4 bytes  - Boundary particle "mass" (total: 16)
	float3 Normal;        // 12 bytes - Surface normal
	int OwnerID;          // 4 bytes  - Owner component ID (total: 32)
	float3 Velocity;      // 12 bytes - World velocity (for moving boundaries)
	float FrictionCoeff;  // 4 bytes  - Coulomb friction coefficient (total: 48)
	int BoneIndex;        // 4 bytes  - Skeleton bone index (-1 for static mesh)
	float3 Padding;       // 12 bytes - Alignment padding (total: 64)
};

//=============================================================================
// Shader Parameters (SOA - Structure of Arrays)
//=============================================================================

// Fluid particle SOA buffers
RWBuffer<float> Positions;              // float3 packed as 3 floats
RWBuffer<uint2> PackedVelocities;       // B plan: half3 packed as uint2
float UniformParticleMass;              // B plan: uniform mass (same for all particles)
RWBuffer<uint> Flags;                   // uint
int ParticleCount;

// Boundary particles
StructuredBuffer<FGPUBoundaryParticle> BoundaryParticles;
int BoundaryParticleCount;

// Boundary Spatial Hash (Legacy mode)
StructuredBuffer<uint> BoundaryCellCounts;
StructuredBuffer<uint> BoundaryParticleIndices;
float BoundaryCellSize;

// Z-Order sorted boundary particles (new mode)
StructuredBuffer<FGPUBoundaryParticle> SortedBoundaryParticles;
StructuredBuffer<uint> BoundaryCellStart;  // BoundaryCellStart[mortonCode] = first boundary index
StructuredBuffer<uint> BoundaryCellEnd;    // BoundaryCellEnd[mortonCode] = last boundary index
int bUseBoundaryZOrder;                    // 1 = use Z-Order sorted boundary, 0 = use legacy spatial hash

// Z-Order bounds (must match fluid simulation)
float3 MortonBoundsMin;
float CellSize;  // Cell size for Morton code calculation
int bUseHybridTiledZOrder;  // 1 = Hybrid Tiled Z-Order (unlimited range), 0 = Classic Morton (bounded)

// Parameters
float AdhesionForceStrength;
float AdhesionRadius;
float CohesionStrength;
float SmoothingRadius;
float3 Gravity;
float DeltaTime;
float RestDensity;
float Poly6Coeff;

// Boundary Owner AABB for particle-level early-out
// Skip adhesion calculation for particles far from boundary AABB
float3 BoundaryAABBMin;
float3 BoundaryAABBMax;
int bUseBoundaryAABBCulling;

//=============================================================================
// AABB Distance Function for Particle-Level Early-Out
// Returns squared distance from position to AABB (0 if inside)
//=============================================================================
float DistanceSquaredToAABB(float3 testPos, float3 aabbMin, float3 aabbMax)
{
	float3 closestPoint = clamp(testPos, aabbMin, aabbMax);
	float3 diff = testPos - closestPoint;
	return dot(diff, diff);
}

//=============================================================================
// SPH Kernels for Adhesion (Akinci 2013)
// Note: AdhesionKernel and CohesionKernel are defined in FluidGPUPhysics.ush
//=============================================================================

//=============================================================================
// Z-Order Cell ID Calculation (must match FluidSolveDensityPressure.usf)
// IMPORTANT: Result is truncated to fit CellStart/CellEnd buffer size (MAX_CELLS)
//=============================================================================
uint GetMortonCellIDFromCellCoord_Adhesion(int3 cellCoord)
{
	// Hybrid mode: 21-bit key (3-bit TileHash + 18-bit LocalMorton)
	if (bUseHybridTiledZOrder)
	{
		// ComputeHybridTiledKey returns 21-bit key matching MAX_CELLS
		// Mask is a no-op but kept for consistency
		// Hash collisions (8 tile buckets) are filtered by distance check
		return ComputeHybridTiledKey(cellCoord) & (MAX_CELLS - 1);
	}

	// Classic mode: Use bounded Morton code
	// Compute grid minimum cell
	int3 gridMin = int3(floor(MortonBoundsMin / CellSize));

	// Offset cell coordinates to make them positive (relative to grid min)
	int3 offset = cellCoord - gridMin;

	// Clamp to valid range for current preset
	uint3 uoffset = uint3(max(offset, int3(0, 0, 0)));
	uoffset = min(uoffset, uint3(MORTON_MAX_VALUE, MORTON_MAX_VALUE, MORTON_MAX_VALUE));

	// Compute Morton code using preset-specific function from FluidMortonUtils.ush
	return Morton3D(uoffset.x, uoffset.y, uoffset.z);
}

//=============================================================================
// Pass 1: Clear Boundary Hash (Legacy mode only)
//=============================================================================

RWStructuredBuffer<uint> RWBoundaryCellCounts;
RWStructuredBuffer<uint> RWBoundaryParticleIndices;

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ClearBoundaryHashCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint cellIdx = DispatchThreadId.x;
	if (cellIdx >= SPATIAL_HASH_SIZE)
	{
		return;
	}
	RWBoundaryCellCounts[cellIdx] = 0;
}

//=============================================================================
// Pass 2: Build Boundary Hash
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void BuildBoundaryHashCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint particleIdx = DispatchThreadId.x;
	if (particleIdx >= (uint)BoundaryParticleCount)
	{
		return;
	}

	float3 pos = BoundaryParticles[particleIdx].Position;
	int3 cellCoord = WorldToCell(pos, BoundaryCellSize);
	uint cellHash = HashCell(cellCoord);

	uint slot;
	InterlockedAdd(RWBoundaryCellCounts[cellHash], 1, slot);

	if (slot < MAX_PARTICLES_PER_CELL)
	{
		uint baseOffset = cellHash * MAX_PARTICLES_PER_CELL;
		RWBoundaryParticleIndices[baseOffset + slot] = particleIdx;
	}
}

//=============================================================================
// Pass 3: Boundary Adhesion (Force-based, Akinci 2013)
// Applies adhesion and cohesion forces from boundary particles to fluid
//
// Two modes:
// 1. Z-Order Mode: O(K) neighbor search using Morton-sorted BoundaryCellStart/End
// 2. Legacy Spatial Hash Mode: Uses BoundaryCellCounts/BoundaryParticleIndices
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void BoundaryAdhesionCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)ParticleCount)
	{
		return;
	}

	// Read from SOA buffers
	uint idx3 = idx * 3;
	uint flags = Flags[idx];
	float mass = UniformParticleMass;

	// Skip if already attached to primitive (existing adhesion system handles this)
	if (HasFlag(flags, GPU_PARTICLE_FLAG_IS_ATTACHED))
	{
		return;
	}

	// Boundary-attached particles still receive adhesion force
	// They need adhesion to stay attracted to the boundary surface
	// The attachment system only handles character movement (bone delta)

	// Use Position for neighbor search (not PredictedPosition for boundary adhesion)
	float3 pos = float3(Positions[idx3], Positions[idx3 + 1], Positions[idx3 + 2]);

	// =========================================================================
	// PARTICLE-LEVEL EARLY-OUT: Skip if particle is far from boundary AABB
	// This reduces unnecessary neighbor searches for particles outside boundary region
	// =========================================================================
	if (bUseBoundaryAABBCulling)
	{
		float distSqToAABB = DistanceSquaredToAABB(pos, BoundaryAABBMin, BoundaryAABBMax);
		// Note: BoundaryAABB is already expanded by AdhesionRadius on CPU side
		// So we just check if particle is outside the expanded AABB
		if (distSqToAABB > 0.0001f)  // Small epsilon to handle floating point precision
		{
			return;  // Particle is outside expanded AABB, no boundary interaction possible
		}
	}

	float3 adhesionForce = float3(0, 0, 0);
	float3 cohesionForce = float3(0, 0, 0);
	float3 normalAccum = float3(0, 0, 0);
	float normalWeightSum = 0.0f;
	float frictionWeightSum = 0.0f;  // Coulomb friction coefficient weighted sum
	float h = AdhesionRadius;  // Use AdhesionRadius for tighter adhesion range

	// Position-based follow: accumulate bone delta
	float3 totalBoneDelta = float3(0, 0, 0);
	float totalDeltaWeight = 0.0f;

	if (bUseBoundaryZOrder)
	{
		//=====================================================================
		// Z-Order Mode: O(K) neighbor search using Morton code
		// SortedBoundaryParticles are sorted by Morton code
		//=====================================================================
		int3 centerCell = WorldToCell(pos, CellSize);
		int cellRadius = (int)ceil(AdhesionRadius / CellSize);  // Use AdhesionRadius

		for (int dz = -cellRadius; dz <= cellRadius; ++dz)
		{
			for (int dy = -cellRadius; dy <= cellRadius; ++dy)
			{
				for (int dx = -cellRadius; dx <= cellRadius; ++dx)
				{
					int3 neighborCell = centerCell + int3(dx, dy, dz);
					uint cellID = GetMortonCellIDFromCellCoord_Adhesion(neighborCell);
					uint bCellStart = BoundaryCellStart[cellID];
					uint bCellEnd = BoundaryCellEnd[cellID];

					// Skip empty cells
					if (bCellStart == INVALID_INDEX || bCellEnd == INVALID_INDEX) continue;

					// Traverse boundary particles in this cell
					uint maxBoundaryIdx = min(bCellEnd, (uint)(BoundaryParticleCount - 1));
					for (uint bi = bCellStart; bi <= maxBoundaryIdx; ++bi)
					{
						FGPUBoundaryParticle boundary = SortedBoundaryParticles[bi];
						float3 r_vec = pos - boundary.Position;
						float r = length(r_vec);

						if (r > 0.0001f && r < h)
						{
							float3 r_normalized = r_vec / r;

							// Distance-based strength: exponential decay
							// r=0 → closeFactor=50.0, very strong at close range
							// r=h → closeFactor≈18.4, still has significant influence at boundary
							float closeFactor = 50.0 * exp(-r / h);

							// Adhesion force (Akinci 2013)
							// F_adhesion = -beta * m_i * psi_b * A(r,h) * r_normalized
							float A = AdhesionKernel(r, h);
							adhesionForce -= AdhesionForceStrength * mass * closeFactor * A * r_normalized;

							// Cohesion force (surface tension at boundary)
							// F_cohesion = -gamma * m_i * psi_b * C(r,h) * r_normalized
							float C = CohesionKernel(r, h);
							cohesionForce -= CohesionStrength * mass * closeFactor * C * r_normalized;

							// Accumulate weighted normal and friction for Coulomb friction
							float normalWeight = A * closeFactor;
							normalAccum += boundary.Normal * normalWeight;
							normalWeightSum += normalWeight;
							frictionWeightSum += boundary.FrictionCoeff * normalWeight;

							// Accumulate bone delta for position-based follow
							float3 boneDelta = boundary.Velocity * DeltaTime;
							float deltaWeight = 1.0f;  // Full follow within adhesion radius
							totalBoneDelta += boneDelta * deltaWeight;
							totalDeltaWeight += deltaWeight;
						}
					}
				}
			}
		}
	}
	else
	{
		//=====================================================================
		// Legacy Spatial Hash Mode: Uses BoundaryCellCounts/BoundaryParticleIndices
		//=====================================================================
		int3 cellCoord = WorldToCell(pos, BoundaryCellSize);

		// Search neighboring cells in boundary spatial hash
		for (int dx = -1; dx <= 1; ++dx)
		{
			for (int dy = -1; dy <= 1; ++dy)
			{
				for (int dz = -1; dz <= 1; ++dz)
				{
					int3 neighborCell = cellCoord + int3(dx, dy, dz);
					uint cellHash = HashCell(neighborCell);
					uint cellCount = min(BoundaryCellCounts[cellHash], MAX_PARTICLES_PER_CELL);
					uint baseOffset = cellHash * MAX_PARTICLES_PER_CELL;

					for (uint i = 0; i < cellCount; ++i)
					{
						uint bi = BoundaryParticleIndices[baseOffset + i];
						if (bi >= (uint)BoundaryParticleCount) continue;

						FGPUBoundaryParticle boundary = BoundaryParticles[bi];
						float3 r_vec = pos - boundary.Position;
						float r = length(r_vec);

						if (r > 0.0001f && r < h)
						{
							float3 r_normalized = r_vec / r;

							// Distance-based strength: exponential decay
							// r=0 → closeFactor=50.0, very strong at close range
							// r=h → closeFactor≈18.4, still has significant influence at boundary
							float closeFactor = 50.0 * exp(-r / h);

							// Adhesion force (Akinci 2013)
							// F_adhesion = -beta * m_i * psi_b * A(r,h) * r_normalized
							float A = AdhesionKernel(r, h);
							adhesionForce -= AdhesionForceStrength * mass * closeFactor * A * r_normalized;

							// Cohesion force (surface tension at boundary)
							// F_cohesion = -gamma * m_i * psi_b * C(r,h) * r_normalized
							float C = CohesionKernel(r, h);
							cohesionForce -= CohesionStrength * mass * closeFactor * C * r_normalized;

							// Accumulate weighted normal and friction for Coulomb friction
							float normalWeight = A * closeFactor;
							normalAccum += boundary.Normal * normalWeight;
							normalWeightSum += normalWeight;
							frictionWeightSum += boundary.FrictionCoeff * normalWeight;

							// Accumulate bone delta for position-based follow
							float3 boneDelta = boundary.Velocity * DeltaTime;
							float deltaWeight = 1.0f;  // Full follow within adhesion radius
							totalBoneDelta += boneDelta * deltaWeight;
							totalDeltaWeight += deltaWeight;
						}
					}
				}
			}
		}
	}

	//=========================================================================
	// Position-Based Follow: Move particles with bone movement
	// Directly adjusts position by bone delta (not force-based)
	// [DISABLED FOR TESTING] - Test for detachment issues during rotation
	// =========================================================================
	// if (totalDeltaWeight > SMALL_NUMBER)
	// {
	// 	float3 avgBoneDelta = totalBoneDelta / totalDeltaWeight;
	// 	particle.Position += avgBoneDelta;
	// 	particle.PredictedPosition += avgBoneDelta;
	// }

	// Note: Force normalization removed to allow proper force accumulation
	// Previously divided by a weight sum which caused weak adhesion with many boundary particles
	// Now forces accumulate naturally - more neighbors = stronger adhesion

	//=========================================================================
	// Ceiling Detection: Reduce adhesion when boundary normal points down
	// (e.g., bottom of capsule, underside of objects)
	//=========================================================================
	float ceilingFactor = 1.0f;
	float3 avgNormal = float3(0, 0, 1);
	float avgFrictionCoeff = 0.6f;

	if (normalWeightSum > SMALL_NUMBER)
	{
		avgNormal = normalize(normalAccum / normalWeightSum);
		avgFrictionCoeff = frictionWeightSum / normalWeightSum;

		// Surface angle detection: vary adhesion based on surface orientation
		// z > 0.7: top (floor-like) → 100%
		// 0.3 < z <= 0.7: upper slope → 70%
		// -0.3 <= z <= 0.3: side wall → 50%
		// -0.7 <= z < -0.3: lower slope → 30%
		// z < -0.7: bottom (ceiling-like) → 10%
		if (avgNormal.z < -0.7f)
		{
			// Bottom (ceiling): particles should fall
			ceilingFactor = 0.1f;
			avgFrictionCoeff *= 0.1f;
		}
		else if (avgNormal.z < -0.3f)
		{
			// Lower slope: particles slide down
			ceilingFactor = 0.3f;
			avgFrictionCoeff *= 0.3f;
		}
		else if (avgNormal.z < 0.3f)
		{
			// Side wall: particles slide down
			ceilingFactor = 0.5f;
			avgFrictionCoeff *= 0.5f;
		}
		else if (avgNormal.z < 0.7f)
		{
			// Upper slope: particles slide slowly
			ceilingFactor = 0.7f;
			avgFrictionCoeff *= 0.7f;
		}
		// else: top (floor-like) → ceilingFactor = 1.0 (default)
	}

	// Read current velocity from SOA
	float3 velocity = UnpackVelocity(PackedVelocities[idx]);

	// Apply forces to velocity (with ceiling factor applied to adhesion)
	float3 totalForce = (adhesionForce + cohesionForce) * ceilingFactor;

	// Clamp force magnitude to prevent instability
	float forceMag = length(totalForce);
	float maxForce = 10000.0f;  // Maximum force magnitude
	if (forceMag > maxForce)
	{
		totalForce = totalForce * (maxForce / forceMag);
	}

	// Apply as velocity change (F = ma, dv = F/m * dt)
	velocity += totalForce / mass * DeltaTime;

	//=========================================================================
	// Set NEAR_BOUNDARY flag if particle is near boundary (for debug visualization)
	// This allows debug view to show which particles are interacting with boundary
	// Note: Uses NEAR_BOUNDARY flag (not IS_ATTACHED) so physics is not skipped
	//=========================================================================
	if (normalWeightSum > SMALL_NUMBER)
	{
		flags = SetFlag(flags, GPU_PARTICLE_FLAG_NEAR_BOUNDARY);
	}
	else
	{
		flags = ClearFlag(flags, GPU_PARTICLE_FLAG_NEAR_BOUNDARY);
	}

	//=========================================================================
	// Coulomb Friction Model (replaces old gravity cancellation)
	// Slows down tangential velocity based on friction coefficient
	//=========================================================================
	if (normalWeightSum > SMALL_NUMBER)
	{
		// Decompose velocity into normal and tangential components
		float3 vel = velocity;
		float velNormalMag = dot(vel, avgNormal);
		float3 velNormal = velNormalMag * avgNormal;
		float3 velTangential = vel - velNormal;
		float tangentialSpeed = length(velTangential);

		// Apply Coulomb friction to tangential velocity
		if (tangentialSpeed > 0.01f)
		{
			// Friction direction: opposite to sliding
			float3 frictionDir = -velTangential / tangentialSpeed;

			// Normal force: independent of adhesion force magnitude
			// Uses normalWeightSum (contact strength) instead of forceMag
			float normalForce = normalWeightSum * 100.0f * ceilingFactor;

			// Coulomb friction: F = μ × N
			float maxFrictionForce = avgFrictionCoeff * normalForce;

			// Force required to stop (80% safety factor to prevent oscillation)
			float requiredForce = tangentialSpeed * mass / DeltaTime * 0.8f;
			float frictionForceMag = min(maxFrictionForce, requiredForce);

			// Apply friction as velocity change
			float3 frictionAccel = frictionDir * frictionForceMag / mass;
			velocity += frictionAccel * DeltaTime;
		}
	}

	// Write back to SOA buffers
	PackedVelocities[idx] = PackVelocity(velocity);
	Flags[idx] = flags;
}
