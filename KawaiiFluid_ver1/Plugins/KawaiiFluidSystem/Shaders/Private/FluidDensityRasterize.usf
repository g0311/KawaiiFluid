// Copyright KawaiiFluid Team. All Rights Reserved.
//
// Fluid Density Rasterization Compute Shader
//
// Rasterizes particle positions into a 3D density grid texture.
// Used by the shadow system for ray marching against fluid volume.
//
// Pipeline: Particle Positions â†’ 3D Density Grid (R16F)

#include "/Engine/Private/Common.ush"

// Particle data input
StructuredBuffer<float4> ParticlePositions;  // xyz = position, w = radius or unused

// Output: 3D density grid (R16F, UAV)
RWTexture3D<float> DensityGrid;

// Grid parameters
float3 GridBoundsMin;
float3 GridBoundsMax;
float3 GridResolution;
float3 InvGridSize;  // 1.0 / (GridBoundsMax - GridBoundsMin)

// Particle parameters
float ParticleRadius;
int NumParticles;

// Density contribution falloff
float DensityFalloff;

/**
 * Convert world position to grid coordinates (0 to Resolution-1).
 */
int3 WorldToGridCoord(float3 WorldPos)
{
    float3 NormalizedPos = (WorldPos - GridBoundsMin) * InvGridSize;
    int3 GridCoord = int3(NormalizedPos * GridResolution);
    return clamp(GridCoord, int3(0, 0, 0), int3(GridResolution) - 1);
}

/**
 * Check if grid coordinate is within bounds.
 */
bool IsValidGridCoord(int3 Coord)
{
    return all(Coord >= int3(0, 0, 0)) && all(Coord < int3(GridResolution));
}

/**
 * Compute density contribution using smooth kernel.
 * Uses a simple polynomial falloff for smooth blending.
 */
float ComputeDensityKernel(float Distance, float Radius)
{
    if (Distance >= Radius)
    {
        return 0.0f;
    }

    // Smooth polynomial falloff: (1 - (d/r)^2)^3
    float Ratio = Distance / Radius;
    float OneMinusRatioSq = 1.0f - Ratio * Ratio;
    return OneMinusRatioSq * OneMinusRatioSq * OneMinusRatioSq;
}

/**
 * Clear density grid to zero.
 * Dispatch: ceil(Resolution / 8) in each dimension.
 */
[numthreads(THREADGROUP_SIZE_X, THREADGROUP_SIZE_Y, THREADGROUP_SIZE_Z)]
void ClearDensityGridCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    if (any(DispatchThreadId >= uint3(GridResolution)))
    {
        return;
    }

    DensityGrid[DispatchThreadId] = 0.0f;
}

/**
 * Rasterize particles to density grid using atomic add.
 * Each thread processes one particle and splatters density to nearby voxels.
 * Dispatch: ceil(NumParticles / 64)
 */
[numthreads(64, 1, 1)]
void RasterizeParticlesCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint ParticleIndex = DispatchThreadId.x;

    if (ParticleIndex >= uint(NumParticles))
    {
        return;
    }

    // Get particle position
    float4 ParticleData = ParticlePositions[ParticleIndex];
    float3 ParticlePos = ParticleData.xyz;

    // Calculate grid-space radius (how many voxels the particle affects)
    float3 VoxelSize = (GridBoundsMax - GridBoundsMin) / GridResolution;
    float AvgVoxelSize = (VoxelSize.x + VoxelSize.y + VoxelSize.z) / 3.0f;
    int VoxelRadius = max(1, int(ceil(ParticleRadius / AvgVoxelSize)));

    // Get center voxel
    int3 CenterVoxel = WorldToGridCoord(ParticlePos);

    // Splat density to nearby voxels
    for (int z = -VoxelRadius; z <= VoxelRadius; ++z)
    {
        for (int y = -VoxelRadius; y <= VoxelRadius; ++y)
        {
            for (int x = -VoxelRadius; x <= VoxelRadius; ++x)
            {
                int3 Voxel = CenterVoxel + int3(x, y, z);

                if (!IsValidGridCoord(Voxel))
                {
                    continue;
                }

                // Calculate world position of voxel center
                float3 VoxelCenter = GridBoundsMin + (float3(Voxel) + 0.5f) * VoxelSize;

                // Calculate distance to particle
                float Distance = length(VoxelCenter - ParticlePos);

                // Compute density contribution
                float Density = ComputeDensityKernel(Distance, ParticleRadius);

                if (Density > 0.0f)
                {
                    // Use InterlockedAdd for thread-safe accumulation
                    // Note: R16F doesn't support atomics directly, so we use uint conversion
                    // For simplicity, we'll just write max density (last write wins for overlapping particles)
                    // A proper implementation would use a R32_UINT buffer and convert

                    // For now, use simple max operation (works for most cases)
                    float CurrentDensity = DensityGrid[Voxel];
                    DensityGrid[Voxel] = max(CurrentDensity, Density);
                }
            }
        }
    }
}

/**
 * Alternative: Voxel-centric rasterization.
 * Each thread processes one voxel and samples all nearby particles.
 * Better for sparse particles, worse for dense particles.
 * Dispatch: ceil(Resolution / 8) in each dimension.
 */
[numthreads(THREADGROUP_SIZE_X, THREADGROUP_SIZE_Y, THREADGROUP_SIZE_Z)]
void RasterizeVoxelCentricCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    if (any(DispatchThreadId >= uint3(GridResolution)))
    {
        return;
    }

    int3 Voxel = int3(DispatchThreadId);

    // Calculate world position of voxel center
    float3 VoxelSize = (GridBoundsMax - GridBoundsMin) / GridResolution;
    float3 VoxelCenter = GridBoundsMin + (float3(Voxel) + 0.5f) * VoxelSize;

    // Accumulate density from all particles
    float TotalDensity = 0.0f;

    for (int i = 0; i < NumParticles; ++i)
    {
        float4 ParticleData = ParticlePositions[i];
        float3 ParticlePos = ParticleData.xyz;

        float Distance = length(VoxelCenter - ParticlePos);
        TotalDensity += ComputeDensityKernel(Distance, ParticleRadius);
    }

    // Clamp to [0, 1] range
    DensityGrid[Voxel] = saturate(TotalDensity);
}

/**
 * Gaussian blur pass for smoothing the density grid.
 * Separable blur - run once per axis.
 */
Texture3D<float> DensityGridInput;
int BlurAxis;  // 0 = X, 1 = Y, 2 = Z
float BlurSigma;

[numthreads(THREADGROUP_SIZE_X, THREADGROUP_SIZE_Y, THREADGROUP_SIZE_Z)]
void BlurDensityGridCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    if (any(DispatchThreadId >= uint3(GridResolution)))
    {
        return;
    }

    int3 Coord = int3(DispatchThreadId);

    // Gaussian weights (sigma = 1.0, kernel size = 5)
    const float Weights[5] = { 0.0625f, 0.25f, 0.375f, 0.25f, 0.0625f };
    const int KernelRadius = 2;

    float Result = 0.0f;
    float TotalWeight = 0.0f;

    for (int i = -KernelRadius; i <= KernelRadius; ++i)
    {
        int3 SampleCoord = Coord;

        if (BlurAxis == 0)
        {
            SampleCoord.x += i;
        }
        else if (BlurAxis == 1)
        {
            SampleCoord.y += i;
        }
        else
        {
            SampleCoord.z += i;
        }

        // Clamp to bounds
        SampleCoord = clamp(SampleCoord, int3(0, 0, 0), int3(GridResolution) - 1);

        float Weight = Weights[i + KernelRadius];
        Result += DensityGridInput.Load(int4(SampleCoord, 0)) * Weight;
        TotalWeight += Weight;
    }

    DensityGrid[Coord] = Result / TotalWeight;
}
