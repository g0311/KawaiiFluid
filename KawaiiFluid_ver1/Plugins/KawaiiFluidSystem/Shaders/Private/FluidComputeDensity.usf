// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Fluid Physics - Compute Density Pass
// Calculates particle density and XPBD lambda using SPH kernels
//
// [DEPRECATED] This shader is deprecated and will be removed in a future version.
// Use FluidSolveDensityPressure.usf instead, which combines density and pressure
// calculation into a single neighbor traversal for better performance.

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"
#include "FluidSpatialHash.ush"

//=============================================================================
// Shader Parameters
//=============================================================================

RWStructuredBuffer<FGPUFluidParticle> Particles;
StructuredBuffer<uint> CellCounts;
StructuredBuffer<uint> ParticleIndices;

int ParticleCount;
float SmoothingRadius;
float RestDensity;
float Poly6Coeff;
float SpikyCoeff;
float CellSize;
float Compliance;
float DeltaTimeSq;

//=============================================================================
// Main Compute Shader
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ComputeDensityCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)ParticleCount)
	{
		return;
	}

	FGPUFluidParticle particle = Particles[idx];

	// Skip attached particles (CPU or boundary) from density calculation
	// CRITICAL: Attached particles cluster at bone position → high density → explosion!
	if (HasFlag(particle.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED))
	{
		particle.Density = RestDensity;
		particle.Lambda = 0.0f;
		Particles[idx] = particle;
		return;
	}

	float3 pos = particle.PredictedPosition;

	// IMPORTANT: Convert smoothing radius from cm to m for kernel calculations
	// Kernel coefficients (Poly6Coeff, SpikyCoeff) are precomputed with h in meters
	float h = SmoothingRadius * CM_TO_M;  // Convert to meters
	float h2 = h * h;

	// Density accumulator
	float density = 0.0f;

	// Neighbor counter (for statistics)
	uint neighborCount = 0;

	// Gradient accumulators for Lambda calculation
	float3 gradC_i = float3(0.0f, 0.0f, 0.0f);
	float sumGradC2 = 0.0f;

	// Get cell coordinate for this particle (still use cm for spatial hash)
	int3 centerCell = WorldToCell(pos, CellSize);
	int cellRadius = (int)ceil(SmoothingRadius / CellSize);  // Use original cm value

	// Iterate over neighboring cells
	for (int dz = -cellRadius; dz <= cellRadius; ++dz)
	{
		for (int dy = -cellRadius; dy <= cellRadius; ++dy)
		{
			for (int dx = -cellRadius; dx <= cellRadius; ++dx)
			{
				int3 neighborCell = centerCell + int3(dx, dy, dz);
				uint hash = HashCell(neighborCell);
				uint count = min(CellCounts[hash], (uint)MAX_PARTICLES_PER_CELL);
				uint startIdx = hash * MAX_PARTICLES_PER_CELL;

				for (uint i = 0; i < count; ++i)
				{
					uint neighborIdx = ParticleIndices[startIdx + i];
					if (neighborIdx >= (uint)ParticleCount)
					{
						continue;
					}

					FGPUFluidParticle neighbor = Particles[neighborIdx];

					float3 neighborPos = neighbor.PredictedPosition;
					float3 r_cm = pos - neighborPos;           // Distance in cm
					float r2_cm = dot(r_cm, r_cm);             // r² in cm²

					// Convert to meters for kernel calculations
					float r2 = r2_cm * CM_TO_M_SQ;             // r² in m²

					// Within smoothing radius? (both now in m²)
					if (r2 < h2)
					{
						float mass = neighbor.Mass;

						// Poly6 kernel for density (using meter units)
						float w = Poly6Kernel(r2, h2);
						density += mass * Poly6Coeff * w;

						// Count neighbors (excluding self)
						if (neighborIdx != idx)
						{
							neighborCount++;
						}

						// Spiky gradient for constraint (only for Lambda calculation)
						float rLen = sqrt(r2);                 // Distance in meters
						float3 r = r_cm * CM_TO_M;             // Convert r vector to meters
						float3 gradW = SpikyGradient(r, rLen, h);
						// IMPORTANT: Multiply by CM_TO_M to match CPU calculation scale
						// This ensures sumGradC2 has the same magnitude as CPU, making
						// the compliance term (epsilon) work correctly in Lambda calculation
						gradW *= SpikyCoeff * CM_TO_M;

						// Gradient of constraint function
						float3 gradC_j = -gradW / RestDensity;
						sumGradC2 += dot(gradC_j, gradC_j);
						gradC_i += gradW / RestDensity;
					}
				}
			}
		}
	}

	// Self contribution to gradient
	sumGradC2 += dot(gradC_i, gradC_i);

	// Store density
	particle.Density = density;

	// Store neighbor count (for statistics)
	particle.NeighborCount = neighborCount;

	// Calculate Lambda using XPBD formulation
	// C = (density / restDensity) - 1
	float C = (density / RestDensity) - 1.0f;

	// XPBD: α̃ = compliance / dt² (regularization parameter)
	float alphaTilde = Compliance / max(DeltaTimeSq, 0.00001f);

	// XPBD Lambda update with accumulation:
	// Δλ = (-C - α̃·λ_prev) / (|∇C|² + α̃)
	// λ = λ_prev + Δλ
	//
	// This formulation:
	// 1. Uses previous Lambda (λ_prev) for proper constraint accumulation
	// 2. Includes compliance term (α̃·λ_prev) for XPBD regularization
	// 3. Accumulates Lambda across iterations for better convergence
	if (C > 0.0f)
	{
		float lambda_prev = particle.Lambda;
		float deltaLambda = (-C - alphaTilde * lambda_prev) / (sumGradC2 + alphaTilde);
		particle.Lambda = lambda_prev + deltaLambda;
	}
	// If C <= 0 (under-compressed or exactly at rest density), keep previous Lambda
	// This matches CPU behavior and prevents oscillation

	Particles[idx] = particle;
}
