// Copyright KawaiiFluid Team. All Rights Reserved.

#include "/Engine/Private/Common.ush"
#include "/Engine/Private/ScreenPass.ush"
#include "FluidCommon.ush"

//-----------------------------------------------------------------------------
// 파라미터
//-----------------------------------------------------------------------------

// 파티클 데이터 버퍼
StructuredBuffer<float3> ParticlePositions;
StructuredBuffer<float3> ParticleVelocities;

// 렌더링 파라미터
float ParticleRadius;
float4x4 ViewMatrix;
float4x4 ProjectionMatrix;
float4x4 ViewProjectionMatrix;

// Occlusion test용 Scene Depth
Texture2D SceneDepthTexture;
SamplerState SceneDepthSampler;

//-----------------------------------------------------------------------------
// 버텍스 셰이더 (Vertex Shader)
//-----------------------------------------------------------------------------

struct FVertexInput
{
	uint InstanceId : SV_InstanceID;
	uint VertexId : SV_VertexID;
};

struct FVertexOutput
{
	float4 Position : SV_POSITION;
	float2 UV : TEXCOORD0; // UV 좌표 추가
	float3 ViewSpacePosition : TEXCOORD1;
	float3 ParticleCenter : TEXCOORD2;
	float ParticleRadius : TEXCOORD3;
	uint InstanceId : TEXCOORD4;
	float4 ScreenPosition : TEXCOORD5; // Screen space position for depth comparison
};

// 빌보드 쿼드 정점
static const float2 QuadVertices[4] =
{
	float2(-1.0, -1.0),
	float2( 1.0, -1.0),
	float2(-1.0,  1.0),
	float2( 1.0,  1.0)
};

// 빌보드 UV
static const float2 QuadUVs[4] =
{
	float2(0.0, 1.0),
	float2(1.0, 1.0),
	float2(0.0, 0.0),
	float2(1.0, 0.0)
};

FVertexOutput MainVS(FVertexInput Input)
{
	FVertexOutput Output;

	// 파티클 월드 위치 가져오기
	float3 ParticleWorldPosition = ParticlePositions[Input.InstanceId];

	// 뷰 공간(View space)으로 변환
	float4 ParticleViewPosition = mul(float4(ParticleWorldPosition, 1.0), ViewMatrix);

	// 빌보드 쿼드 오프셋 생성
	float2 QuadOffset = QuadVertices[Input.VertexId] * ParticleRadius;

	// 뷰 공간에서 쿼드 오프셋 적용 (카메라를 향하도록)
	float3 ViewSpacePosition = ParticleViewPosition.xyz;
	ViewSpacePosition.xy += QuadOffset;

	// 투영 (Projection)
	Output.Position = mul(float4(ViewSpacePosition, 1.0), ProjectionMatrix);
	Output.UV = QuadUVs[Input.VertexId];
	Output.ViewSpacePosition = ViewSpacePosition;
	Output.ParticleCenter = ParticleViewPosition.xyz;
	Output.ParticleRadius = ParticleRadius;
	Output.InstanceId = Input.InstanceId;
	Output.ScreenPosition = Output.Position; // Screen position for depth comparison

	return Output;
}

//-----------------------------------------------------------------------------
// 픽셀 셰이더 (Pixel Shader)
//-----------------------------------------------------------------------------

struct FPixelOutput
{
    float LinearDepth : SV_Target0;
	float DeviceDepth : SV_Depth;
};

FPixelOutput MainPS(FVertexOutput Input)
{
	FPixelOutput Output;

	// Calculate screen UV for depth sampling
	float2 ScreenUV = Input.ScreenPosition.xy / Input.ScreenPosition.w;
	ScreenUV = ScreenUV * 0.5 + 0.5;
	ScreenUV.y = 1.0 - ScreenUV.y;

	// Sample scene depth and perform occlusion test
	float SceneDeviceDepth = SceneDepthTexture.Sample(SceneDepthSampler, ScreenUV).r;

	// Early discard if quad is behind scene geometry
	// Reversed-Z: 0.0 = far, 1.0 = near, so if quad depth < scene depth, it's farther away
	if (Input.Position.z < SceneDeviceDepth)
	{
		discard;
	}

	// Billboard-Sphere 방식: UV를 사용해 원형 렌더링
	// UV를 (-1, 1) 범위로 변환
	float2 UV = Input.UV * 2.0 - 1.0;

	// UV 거리 계산 (구의 반지름 = 1.0)
	float r2 = dot(UV, UV);

	// 원 밖의 픽셀은 버림 (사각형 → 원형)
	if (r2 > 1.0)
	{
		discard;
	}

	// 구 표면의 Z 오프셋 계산
	float z = sqrt(1.0 - r2);

	// 실제 구 표면 위치 계산 (View Space)
	float3 IntersectionPoint = Input.ParticleCenter + float3(UV * Input.ParticleRadius, -z * Input.ParticleRadius);

	// Linear Depth 계산 (뷰 공간 Z를 양수 거리로 변환)
	// View Space는 -Z가 전방이므로, 음수를 양수로 변환하여 저장
	Output.LinearDepth = -IntersectionPoint.z;

	// Device Depth 계산 (클립 공간)
	float4 ClipPosition = mul(float4(IntersectionPoint, 1.0), ProjectionMatrix);
	Output.DeviceDepth = ClipPosition.z / ClipPosition.w;

	return Output;
}
