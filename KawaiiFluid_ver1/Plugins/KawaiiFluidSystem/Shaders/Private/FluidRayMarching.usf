// Copyright KawaiiFluid Team. All Rights Reserved.
// Ray Marching SDF Fluid Rendering Shader

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidSDFCommon.ush"

// Spatial Hash 가속 (USE_SPATIAL_HASH=1 일 때 사용)
#if USE_SPATIAL_HASH
#include "FluidSpatialHash.ush"
#endif

//=============================================================================
// Shader Parameters
//=============================================================================

// Particle Data (used when USE_SDF_VOLUME is 0)
// Uses FKawaiiRenderParticle struct for GPU mode compatibility
StructuredBuffer<FKawaiiRenderParticle> RenderParticles;
int ParticleCount;
float ParticleRadius;

// Particle Bounding Box (GPU에서 계산된 바운딩 박스)
// 카메라가 멀리 있을 때 빈 셀 건너뛰기 방지
float3 ParticleBoundsMin;
float3 ParticleBoundsMax;

//=============================================================================
// Spatial Hash Parameters (used when USE_SPATIAL_HASH is 1)
// O(k) SDF 평가를 위한 공간 해시 가속 구조
// RenderParticles 버퍼를 재사용 (FKawaiiRenderParticle, 32 bytes)
//=============================================================================
#if USE_SPATIAL_HASH
// 주의: RenderParticles는 위에서 이미 선언됨 (파티클 모드에서 사용)
// Spatial Hash 모드에서도 동일한 RenderParticles 버퍼 사용
StructuredBuffer<uint> CellCounts;           // 셀별 파티클 개수
StructuredBuffer<uint> CellStartIndices;     // 셀별 시작 인덱스 (Prefix Sum)
StructuredBuffer<uint> ParticleIndices;      // 정렬된 파티클 인덱스
float SpatialHashCellSize;                   // 셀 크기 (월드 유닛)
#endif

//=============================================================================
// SDF Volume Parameters (used when USE_SDF_VOLUME is 1)
//=============================================================================
#if USE_SDF_VOLUME
Texture3D<float> SDFVolumeTexture;
SamplerState SDFVolumeSampler;
float3 SDFVolumeMin;
float3 SDFVolumeMax;
int3 SDFVolumeResolution;
#endif

// Ray Marching Parameters
float SDFSmoothness;
int MaxRayMarchSteps;
float RayMarchHitThreshold;
float RayMarchMaxDistance;

// Appearance Parameters
float4 FluidColor;
float FresnelStrength;
float RefractiveIndex;
float AbsorptionCoefficient;
float SpecularStrength;
float SpecularRoughness;
float4 EnvironmentLightColor;

// SSS Parameters
float SSSIntensity;
float4 SSSColor;

// Scene Textures
Texture2D SceneDepthTexture;
Texture2D SceneColorTexture;
SamplerState SceneTextureSampler;

// View Matrices
float4x4 InverseViewMatrix;
float4x4 InverseProjectionMatrix;
float4x4 ViewMatrix;
float4x4 ProjectionMatrix;
float2 ViewportSize;

// SceneDepth UV 변환용 파라미터
float2 SceneViewRect;    // SceneDepth 유효 영역 크기
float2 SceneTextureSize; // SceneDepth 텍스처 전체 크기

// Light Direction accessed from View uniform buffer:
// View.DirectionalLightDirection, View.DirectionalLightColor

//=============================================================================
// Ray Marching Result Structure
//=============================================================================

struct FRayMarchResult
{
	bool bHit;
	float Distance;
	float3 Position;
	float3 Normal;
	float Thickness;
	float LastSDF;
};

//=============================================================================
// Helper Functions
//=============================================================================

// Convert screen UV to world-space camera ray
void GetCameraRay(float2 UV, out float3 RayOrigin, out float3 RayDirection)
{
	// Extract camera world position from InverseViewMatrix (translation is in 4th row for row-major)
	RayOrigin = float3(InverseViewMatrix._41, InverseViewMatrix._42, InverseViewMatrix._43);

	// NDC coordinates
	float2 NDC = UV * 2.0 - 1.0;
	NDC.y = -NDC.y;  // Flip Y for DirectX

	// Clip space far point
	float4 ClipFar = float4(NDC, 1.0, 1.0);

	// Transform clip -> view -> world
	float4 ViewFar = mul(ClipFar, InverseProjectionMatrix);
	ViewFar /= ViewFar.w;
	float4 WorldFar = mul(ViewFar, InverseViewMatrix);

	RayDirection = normalize(WorldFar.xyz - RayOrigin);
}

// Convert device Z to linear depth
float ConvertDeviceZToLinearDepth(float DeviceZ)
{
	// UE4/5 uses reversed-Z
	float4 ClipPos = float4(0, 0, DeviceZ, 1.0);
	float4 ViewPos = mul(ClipPos, InverseProjectionMatrix);
	return ViewPos.z / ViewPos.w;
}

//=============================================================================
// Ray-Box Intersection (공통 함수)
// 파티클 모드와 SDF Volume 모드 모두에서 사용
//=============================================================================

bool RayBoxIntersect(float3 ro, float3 rd, float3 boxMin, float3 boxMax, out float tMin, out float tMax)
{
	float3 invRd = 1.0 / rd;
	float3 t0 = (boxMin - ro) * invRd;
	float3 t1 = (boxMax - ro) * invRd;

	float3 tNear = min(t0, t1);
	float3 tFar = max(t0, t1);

	tMin = max(max(tNear.x, tNear.y), tNear.z);
	tMax = min(min(tFar.x, tFar.y), tFar.z);

	// 카메라가 박스 내부에 있으면 tMin을 0으로 클램프
	tMin = max(tMin, 0.0);

	return tMax >= tMin && tMax > 0.0;
}

//=============================================================================
// SDF Volume Sampling (when USE_SDF_VOLUME is enabled)
//=============================================================================

#if USE_SDF_VOLUME
// Sample SDF from 3D volume texture
float SampleSDFVolume(float3 worldPos)
{
	// Convert world position to normalized UVW coordinates
	float3 uvw = (worldPos - SDFVolumeMin) / (SDFVolumeMax - SDFVolumeMin);

	// Check if position is outside volume bounds
	if (any(uvw < 0.0) || any(uvw > 1.0))
	{
		return 1e10;  // Return large distance if outside volume
	}

	// Sample 3D texture with trilinear interpolation
	return SDFVolumeTexture.SampleLevel(SDFVolumeSampler, uvw, 0);
}

// Calculate normal from SDF volume using central differences
float3 CalculateSDFNormalFromVolume(float3 p, float centerSDF)
{
	const float eps = 0.5;  // Slightly larger epsilon for volume sampling

	float3 n;
	n.x = SampleSDFVolume(p + float3(eps, 0, 0)) - SampleSDFVolume(p - float3(eps, 0, 0));
	n.y = SampleSDFVolume(p + float3(0, eps, 0)) - SampleSDFVolume(p - float3(0, eps, 0));
	n.z = SampleSDFVolume(p + float3(0, 0, eps)) - SampleSDFVolume(p - float3(0, 0, eps));

	return normalize(n);
}
#endif

//=============================================================================
// Ray Marching
//=============================================================================

FRayMarchResult RayMarchSDF(float3 ro, float3 rd, float maxDist)
{
	FRayMarchResult result;
	result.bHit = false;
	result.Distance = 0.0;
	result.Position = float3(0, 0, 0);
	result.Normal = float3(0, 1, 0);
	result.Thickness = 0.0;
	result.LastSDF = 1e10;

	float t = 0.0;
	float marchMaxDist = maxDist;

#if USE_SDF_VOLUME
	// SDF Volume 모드: 볼륨 바운딩 박스 사용
	float tBoxMin, tBoxMax;
	if (!RayBoxIntersect(ro, rd, SDFVolumeMin, SDFVolumeMax, tBoxMin, tBoxMax))
	{
		return result;
	}
	t = tBoxMin + 0.01;
	marchMaxDist = min(maxDist, tBoxMax);
#else
	// 파티클 모드: GPU에서 계산된 바운딩 박스 사용
	// 카메라가 멀리 있을 때 빈 셀에서 1e10 반환하여 파티클 건너뛰는 것 방지
	float tBoxMin, tBoxMax;
	if (!RayBoxIntersect(ro, rd, ParticleBoundsMin, ParticleBoundsMax, tBoxMin, tBoxMax))
	{
		// 레이가 파티클 바운딩 박스와 교차하지 않음
		return result;
	}
	t = tBoxMin + 0.001;  // 박스 진입점에서 시작
	marchMaxDist = min(maxDist, tBoxMax);
#endif

	float lastSDF = 1e10;

	// Main ray marching loop
	for (int i = 0; i < MaxRayMarchSteps && t < marchMaxDist; ++i)
	{
		float3 p = ro + rd * t;

#if USE_SDF_VOLUME
		// Optimized path: Sample from pre-baked 3D SDF texture (O(1))
		float sdf = SampleSDFVolume(p);
#elif USE_SPATIAL_HASH
		// Accelerated path: Spatial Hash neighbor search (O(k))
		// RenderParticles 버퍼 재사용 (FKawaiiRenderParticle, 32 bytes)
		float sdf = EvaluateMetaballSDFWithHash(
			p,
			RenderParticles,  // FKawaiiRenderParticle 버퍼
			CellCounts,
			CellStartIndices,
			ParticleIndices,
			ParticleCount,
			ParticleRadius,
			SDFSmoothness,
			SpatialHashCellSize);
#else
		// Direct path: Evaluate metaball SDF from particle buffer (O(N) particles)
		float sdf = EvaluateMetaballSDFFromRenderParticles(p, RenderParticles, ParticleCount, ParticleRadius, SDFSmoothness);
#endif

		lastSDF = sdf;

		// Hit detection
		if (sdf < RayMarchHitThreshold)
		{
			result.bHit = true;
			result.Distance = t;
			result.Position = p;
			result.LastSDF = sdf;

#if USE_SDF_VOLUME
			// Calculate normal from volume texture
			result.Normal = CalculateSDFNormalFromVolume(p, sdf);
#elif USE_SPATIAL_HASH
			// Calculate normal using 3-tap with Spatial Hash acceleration
			// RenderParticles 버퍼 재사용 (FKawaiiRenderParticle, 32 bytes)
			result.Normal = CalculateSDFNormal3TapWithHash(
				p, sdf,
				RenderParticles,  // FKawaiiRenderParticle 버퍼
				CellCounts,
				CellStartIndices,
				ParticleIndices,
				ParticleCount,
				ParticleRadius,
				SDFSmoothness,
				SpatialHashCellSize);
#else
			// Calculate normal using 3-tap from particle buffer (faster)
			result.Normal = CalculateSDFNormal3TapFromRenderParticles(p, sdf, RenderParticles, ParticleCount, ParticleRadius, SDFSmoothness);
#endif

			// Estimate thickness based on SDF and particle radius (simple approximation)
			// Avoids internal ray marching which causes visible internal boundaries
			float estimatedThickness = ParticleRadius * 4.0 * (1.0 - saturate(abs(sdf) / ParticleRadius));
			result.Thickness = max(estimatedThickness, ParticleRadius);

			break;
		}

		// Adaptive stepping with safety factor (reference: 4rknova blog)
		// Clamp step size to avoid huge jumps when SDF returns 1e10 (no particle found)
		float maxStep = ParticleRadius * 2.0;
		t += clamp(sdf * 0.95, 0.01, maxStep);
	}

	return result;
}

//=============================================================================
// Shading Functions
//=============================================================================

// Schlick Fresnel approximation
float SchlickFresnel(float cosTheta, float F0)
{
	return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

// Blinn-Phong specular
float BlinnPhongSpecular(float3 N, float3 V, float3 L, float roughness)
{
	float3 H = normalize(L + V);
	float NoH = saturate(dot(N, H));
	float shininess = (1.0 - roughness) * 128.0;
	return pow(NoH, shininess);
}

//=============================================================================
// Vertex Shader (Fullscreen Triangle)
//=============================================================================

struct FVertexOutput
{
	float4 Position : SV_POSITION;
	float2 UV : TEXCOORD0;
};

void MainVS(
	in uint VertexID : SV_VertexID,
	out FVertexOutput Output)
{
	// Generate fullscreen triangle vertices
	float2 UV = float2((VertexID << 1) & 2, VertexID & 2);
	Output.UV = UV;
	Output.Position = float4(UV * float2(2.0, -2.0) + float2(-1.0, 1.0), 0.5, 1.0);
}

//=============================================================================
// Pixel Shader
//=============================================================================

void MainPS(
	FVertexOutput Input,
	out float4 OutColor : SV_Target0)
{
	float2 UV = Input.UV;

#if USE_SDF_VOLUME
	// SDF Volume mode: no early exit based on ParticleCount
	// We use the pre-baked 3D SDF texture instead
#else
	// Legacy mode: Early out if no particles
	if (ParticleCount <= 0)
	{
		discard;
		return;
	}
#endif

	// Get camera ray
	float3 RayOrigin, RayDirection;
	GetCameraRay(UV, RayOrigin, RayDirection);

	// ============ Early bounding box rejection ============
	// 바운딩 박스와 교차하지 않는 픽셀은 scene depth 샘플링 전에 discard
	// 성능 최적화: 불필요한 텍스처 샘플링 방지
#if !USE_SDF_VOLUME
	{
		float tBoxMinEarly, tBoxMaxEarly;
		if (!RayBoxIntersect(RayOrigin, RayDirection, ParticleBoundsMin, ParticleBoundsMax, tBoxMinEarly, tBoxMaxEarly))
		{
			discard;
			return;
		}
	}
#endif

	// Get scene depth for occlusion
	// SceneDepth UV 변환: ScreenUV를 SceneDepth의 유효 영역에 매핑
	float2 SceneUV = UV * (SceneViewRect / SceneTextureSize);
	float SceneDeviceZ = SceneDepthTexture.SampleLevel(SceneTextureSampler, SceneUV, 0).r;
	float SceneLinearDepth = ConvertDeviceZToLinearDepth(SceneDeviceZ);

	// Clamp max distance to scene depth
	float MaxDist = min(RayMarchMaxDistance, SceneLinearDepth * 100.0);  // Convert to world units

	// Ray march
	FRayMarchResult result = RayMarchSDF(RayOrigin, RayDirection, RayMarchMaxDistance);

	if (!result.bHit)
	{
		discard;
		return;
	}

	// Depth occlusion test: Compare hit point depth with scene depth
	// Transform hit position to clip space to get its device Z
	float4 HitViewPos = mul(float4(result.Position, 1.0), ViewMatrix);
	float4 HitClipPos = mul(HitViewPos, ProjectionMatrix);
	float HitDeviceZ = HitClipPos.z / HitClipPos.w;

	// UE5 uses reversed-Z: closer objects have higher Z values
	// If hit point is behind scene geometry, discard
	// Add small bias to prevent flickering at depth boundaries
	float DepthBias = 0.0001;
	if (HitDeviceZ < SceneDeviceZ - DepthBias)
	{
		discard;
		return;
	}

	//=========================================================================
	// Shading
	//=========================================================================

	float3 N = result.Normal;
	float3 V = -RayDirection;
	float3 P = result.Position;
	float Thickness = result.Thickness;

	// Default light direction (top-down sun angle)
	float3 L = normalize(float3(0.5, 0.5, -0.707));

	// Fresnel (Schlick approximation) - use smoothstep for softer transition
	float NoV = saturate(dot(N, V));
	float FresnelRaw = SchlickFresnel(NoV, FresnelStrength);
	float Fresnel = smoothstep(0.0, 1.0, FresnelRaw) * 0.5;  // Soften and reduce

	// Specular (Blinn-Phong) - softer specular
	float NoL = saturate(dot(N, L));
	float SpecularRaw = BlinnPhongSpecular(N, V, L, max(SpecularRoughness, 0.5));  // Min roughness 0.5
	float Specular = smoothstep(0.0, 1.0, SpecularRaw) * SpecularStrength * NoL * 0.3;  // Reduce intensity

	// Beer's Law absorption - gentler
	float AbsorptionFactor = 1.0 - exp(-Thickness * AbsorptionCoefficient * 0.05);

	// Refracted background sampling
	float3 RefractDir = refract(-V, N, 1.0 / RefractiveIndex);
	float2 RefractedUV = UV + RefractDir.xy * 0.02;  // Reduce distortion
	RefractedUV = saturate(RefractedUV);
	float3 RefractedBackground = SceneColorTexture.Sample(SceneTextureSampler, RefractedUV).rgb;

	// Base color - mostly fluid color with subtle background blend
	float3 BaseColor = lerp(RefractedBackground, FluidColor.rgb, saturate(AbsorptionFactor + 0.7));

	//=========================================================================
	// Subsurface Scattering (SSS) - Jelly Effect (simplified)
	//=========================================================================

	// SSS: simple rim lighting effect
	float RimFactor = 1.0 - NoV;
	float SSSFactor = smoothstep(0.3, 1.0, RimFactor) * SSSIntensity * 0.5;
	float3 SSSContribution = SSSColor.rgb * SSSFactor;

	//=========================================================================
	// Final Composition
	//=========================================================================

	// Fresnel reflection (subtle environment reflection)
	float3 ReflectedColor = EnvironmentLightColor.rgb * Fresnel;

	// Simple diffuse lighting
	float Diffuse = NoL * 0.5 + 0.5;  // Half-lambert for softer shading

	// Combine all lighting
	float3 FinalColor = BaseColor * Diffuse;
	FinalColor += ReflectedColor * 0.3;
	FinalColor += SSSContribution;
	FinalColor += Specular;

	// Alpha - simpler calculation
	float Alpha = saturate(0.85 + Fresnel * 0.15);

	OutColor = float4(FinalColor, Alpha);
}
