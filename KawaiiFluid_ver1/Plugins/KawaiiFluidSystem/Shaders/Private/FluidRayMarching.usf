// Copyright KawaiiFluid Team. All Rights Reserved.
// Ray Marching SDF Fluid Rendering Shader

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidSDFCommon.ush"

//=============================================================================
// Shader Parameters
//=============================================================================

// Particle Data (used when USE_SDF_VOLUME is 0)
// Uses FKawaiiRenderParticle struct for GPU mode compatibility
StructuredBuffer<FKawaiiRenderParticle> RenderParticles;
int ParticleCount;
float ParticleRadius;

//=============================================================================
// SoA (Structure of Arrays) Particle Buffers
// - RenderPositions: 12B/particle (vs 32B AoS) - 62% bandwidth reduction
// - RenderVelocities: Motion blur only
//=============================================================================
#if USE_SOA_BUFFERS
StructuredBuffer<float3> RenderPositions;
StructuredBuffer<float3> RenderVelocities;
#endif

//=============================================================================
// SDF Volume Parameters (used when USE_SDF_VOLUME is 1)
//=============================================================================
#if USE_SDF_VOLUME
Texture3D<float> SDFVolumeTexture;
SamplerState SDFVolumeSampler;

// Bounds can come from uniform (CPU mode) or buffer (GPU mode)
#if USE_GPU_BOUNDS
StructuredBuffer<float3> BoundsBuffer;  // [0] = Min, [1] = Max
#else
float3 SDFVolumeMin;
float3 SDFVolumeMax;
#endif

int3 SDFVolumeResolution;

// Helper functions to get bounds (works for both CPU and GPU modes)
float3 GetSDFVolumeMin()
{
#if USE_GPU_BOUNDS
	return BoundsBuffer[0];
#else
	return SDFVolumeMin;
#endif
}

float3 GetSDFVolumeMax()
{
#if USE_GPU_BOUNDS
	return BoundsBuffer[1];
#else
	return SDFVolumeMax;
#endif
}
#endif

//=============================================================================
// Spatial Hash Parameters (used when USE_SDF_VOLUME && USE_SPATIAL_HASH)
// HYBRID MODE: SDF Volume for fast 90% approach, Spatial Hash for precise 10% final
//=============================================================================
#if USE_SDF_VOLUME && USE_SPATIAL_HASH
StructuredBuffer<uint2> CellData;                   // {startIndex, count} per cell
StructuredBuffer<uint> SpatialHashParticleIndices;  // Sorted particle indices
float SpatialHashCellSize;
#endif

// Ray Marching Parameters
float SDFSmoothness;
int MaxRayMarchSteps;
float RayMarchHitThreshold;
float RayMarchMaxDistance;

// Appearance Parameters
float4 FluidColor;
float FresnelStrength;
float RefractiveIndex;
float AbsorptionCoefficient;
float SpecularStrength;
float SpecularRoughness;
float4 EnvironmentLightColor;

// SSS Parameters
float SSSIntensity;
float4 SSSColor;

// Scene Textures
Texture2D SceneDepthTexture;
Texture2D SceneColorTexture;
SamplerState SceneTextureSampler;

// View Matrices
float4x4 InverseViewMatrix;
float4x4 InverseProjectionMatrix;
float4x4 ViewMatrix;
float4x4 ProjectionMatrix;
float2 ViewportSize;

// SceneDepth UV 변환용 파라미터
float2 SceneViewRect;    // SceneDepth 유효 영역 크기
float2 SceneTextureSize; // SceneDepth 텍스처 전체 크기

// Light Direction accessed from View uniform buffer:
// View.DirectionalLightDirection, View.DirectionalLightColor

//=============================================================================
// Ray Marching Result Structure
//=============================================================================

struct FRayMarchResult
{
	bool bHit;
	float Distance;
	float3 Position;
	float3 Normal;
	float Thickness;
	float LastSDF;
};

//=============================================================================
// Helper Functions
//=============================================================================

// Convert screen UV to world-space camera ray
void GetCameraRay(float2 UV, out float3 RayOrigin, out float3 RayDirection)
{
	// Extract camera world position from InverseViewMatrix (translation is in 4th row for row-major)
	RayOrigin = float3(InverseViewMatrix._41, InverseViewMatrix._42, InverseViewMatrix._43);

	// NDC coordinates
	float2 NDC = UV * 2.0 - 1.0;
	NDC.y = -NDC.y;  // Flip Y for DirectX

	// Clip space far point
	float4 ClipFar = float4(NDC, 1.0, 1.0);

	// Transform clip -> view -> world
	float4 ViewFar = mul(ClipFar, InverseProjectionMatrix);
	ViewFar /= ViewFar.w;
	float4 WorldFar = mul(ViewFar, InverseViewMatrix);

	RayDirection = normalize(WorldFar.xyz - RayOrigin);
}

// Convert device Z to linear depth
float ConvertDeviceZToLinearDepth(float DeviceZ)
{
	// UE4/5 uses reversed-Z
	float4 ClipPos = float4(0, 0, DeviceZ, 1.0);
	float4 ViewPos = mul(ClipPos, InverseProjectionMatrix);
	return ViewPos.z / ViewPos.w;
}

//=============================================================================
// SDF Volume Sampling (when USE_SDF_VOLUME is enabled)
//=============================================================================

#if USE_SDF_VOLUME
// Sample SDF from 3D volume texture
float SampleSDFVolume(float3 worldPos)
{
	// Convert world position to normalized UVW coordinates
	float3 volumeMin = GetSDFVolumeMin();
	float3 volumeMax = GetSDFVolumeMax();
	float3 uvw = (worldPos - volumeMin) / (volumeMax - volumeMin);

	// Check if position is outside volume bounds
	if (any(uvw < 0.0) || any(uvw > 1.0))
	{
		return 1e10;  // Return large distance if outside volume
	}

	// Sample 3D texture with trilinear interpolation
	return SDFVolumeTexture.SampleLevel(SDFVolumeSampler, uvw, 0);
}

// Calculate normal from SDF volume using central differences
float3 CalculateSDFNormalFromVolume(float3 p, float centerSDF)
{
	const float eps = 0.5;  // Slightly larger epsilon for volume sampling

	float3 n;
	n.x = SampleSDFVolume(p + float3(eps, 0, 0)) - SampleSDFVolume(p - float3(eps, 0, 0));
	n.y = SampleSDFVolume(p + float3(0, eps, 0)) - SampleSDFVolume(p - float3(0, eps, 0));
	n.z = SampleSDFVolume(p + float3(0, 0, eps)) - SampleSDFVolume(p - float3(0, 0, eps));

	return normalize(n);
}

// Ray-Box Intersection (for SDF Volume bounds)
// Returns true if ray intersects AABB, outputs entry and exit distances
bool RayBoxIntersect(float3 ro, float3 rd, float3 boxMin, float3 boxMax, out float tMin, out float tMax)
{
	float3 invRd = 1.0 / rd;
	float3 t0 = (boxMin - ro) * invRd;
	float3 t1 = (boxMax - ro) * invRd;

	float3 tNear = min(t0, t1);
	float3 tFar = max(t0, t1);

	tMin = max(max(tNear.x, tNear.y), tNear.z);
	tMax = min(min(tFar.x, tFar.y), tFar.z);

	// Clamp tMin to 0 if camera is inside the box
	tMin = max(tMin, 0.0);

	return tMax >= tMin && tMax > 0.0;
}
#endif

//=============================================================================
// Ray Marching with Temporal Jittering
//=============================================================================
// Jittering + TAA optimization:
// - Add noise to ray start position -> converts banding to noise
// - TAA averages noise over time -> smooth result with fewer steps
//=============================================================================

FRayMarchResult RayMarchSDF(float3 ro, float3 rd, float maxDist, float2 screenPos)
{
	FRayMarchResult result;
	result.bHit = false;
	result.Distance = 0.0;
	result.Position = float3(0, 0, 0);
	result.Normal = float3(0, 1, 0);
	result.Thickness = 0.0;
	result.LastSDF = 1e10;

#if USE_SDF_VOLUME
	// Find where ray enters/exits the SDF volume bounds
	float tBoxMin, tBoxMax;
	float3 volumeMin = GetSDFVolumeMin();
	float3 volumeMax = GetSDFVolumeMax();
	if (!RayBoxIntersect(ro, rd, volumeMin, volumeMax, tBoxMin, tBoxMax))
	{
		// Ray doesn't intersect volume - no hit possible
		return result;
	}

	// Start marching from volume entry point
	float t = tBoxMin + 0.01;
	float marchMaxDist = min(maxDist, tBoxMax);

	// [JITTERING] Temporal noise for TAA integration
	// InterleavedGradientNoise: Blue noise-like, TAA-friendly
	// View.StateFrameIndexMod8: Changes every frame for temporal variation
	float jitterNoise = InterleavedGradientNoise(screenPos, View.StateFrameIndexMod8);

	// Sample SDF at entry point to get safe jitter distance
	float3 entryPos = ro + rd * t;
	float entrySDF = SampleSDFVolume(entryPos);

	// Jitter start position within safe distance (won't overshoot surface)
	t += entrySDF * jitterNoise * 0.5;
#else
	float t = 0.0;
	float marchMaxDist = maxDist;
#endif

	float lastSDF = 1e10;

	// Main ray marching loop
	for (int i = 0; i < MaxRayMarchSteps && t < marchMaxDist; ++i)
	{
		float3 p = ro + rd * t;

#if USE_SDF_VOLUME
		// Phase 1: Fast approach using SDF Volume (O(1) texture sampling)
		float sdf = SampleSDFVolume(p);

	#if USE_SPATIAL_HASH
		bool bUsedSpatialHash = false;

		// HYBRID MODE: When close to surface, switch to Spatial Hash for precise evaluation
		// SDF Volume is fast but approximate, Spatial Hash gives accurate surface detection
		if (sdf < SpatialHashCellSize)
		{
			// Phase 2: Precise evaluation using Spatial Hash (O(k) neighbor lookup)
		#if USE_SOA_BUFFERS
			// SoA: 62% bandwidth reduction (12B vs 32B per particle)
			float hashSdf = EvaluateMetaballSDFWithSpatialHash_SoA(p, RenderPositions, CellData, SpatialHashParticleIndices, ParticleCount, ParticleRadius, SDFSmoothness, SpatialHashCellSize);
		#else
			float hashSdf = EvaluateMetaballSDFWithSpatialHash(p, RenderParticles, CellData, SpatialHashParticleIndices, ParticleCount, ParticleRadius, SDFSmoothness, SpatialHashCellSize);
		#endif

			// Fallback: If Spatial Hash finds no particles (smin blend surface without nearby particles),
			// keep SDF Volume value to avoid huge step that would skip the surface
			if (hashSdf < 1e9)
			{
				sdf = hashSdf;
				bUsedSpatialHash = true;
			}
			// else: keep SDF Volume value (sdf) for blend surfaces
		}
	#endif
#else
		// Fallback: Direct O(N) particle iteration (legacy mode, no SDF Volume)
	#if USE_SOA_BUFFERS
		float sdf = EvaluateMetaballSDFFromPositions_SoA(p, RenderPositions, ParticleCount, ParticleRadius, SDFSmoothness);
	#else
		float sdf = EvaluateMetaballSDFFromRenderParticles(p, RenderParticles, ParticleCount, ParticleRadius, SDFSmoothness);
	#endif
#endif

		lastSDF = sdf;

		// Hit detection
		if (sdf < RayMarchHitThreshold)
		{
			result.bHit = true;
			result.Distance = t;
			result.Position = p;
			result.LastSDF = sdf;

#if USE_SDF_VOLUME
	#if USE_SPATIAL_HASH
			// Use appropriate normal calculation based on which SDF source was used
			if (bUsedSpatialHash)
			{
				// Analytic gradient normal from Spatial Hash (1-Loop instead of 5-Loop)
			#if USE_SOA_BUFFERS
				result.Normal = CalculateNormalAnalyticWithSpatialHash_SoA(p, sdf, RenderPositions, CellData, SpatialHashParticleIndices, ParticleCount, ParticleRadius, SDFSmoothness, SpatialHashCellSize);
			#else
				result.Normal = CalculateNormalAnalyticWithSpatialHash(p, sdf, RenderParticles, CellData, SpatialHashParticleIndices, ParticleCount, ParticleRadius, SDFSmoothness, SpatialHashCellSize);
			#endif
			}
			else
			{
				// Fallback to SDF Volume normal for blend surfaces without nearby particles
				result.Normal = CalculateSDFNormalFromVolume(p, sdf);
			}
	#else
			// Normal from SDF Volume texture
			result.Normal = CalculateSDFNormalFromVolume(p, sdf);
	#endif
#else
			// Fallback: Normal from direct particle evaluation
		#if USE_SOA_BUFFERS
			result.Normal = CalculateSDFNormal3Tap_SoA(p, sdf, RenderPositions, ParticleCount, ParticleRadius, SDFSmoothness);
		#else
			result.Normal = CalculateSDFNormal3TapFromRenderParticles(p, sdf, RenderParticles, ParticleCount, ParticleRadius, SDFSmoothness);
		#endif
#endif

			// Estimate thickness based on SDF and particle radius (simple approximation)
			// Avoids internal ray marching which causes visible internal boundaries
			float estimatedThickness = ParticleRadius * 4.0 * (1.0 - saturate(abs(sdf) / ParticleRadius));
			result.Thickness = max(estimatedThickness, ParticleRadius);

			break;
		}

		// Adaptive stepping with safety factor (reference: 4rknova blog)
		t += max(sdf * 0.95, 0.01);
	}

	return result;
}

//=============================================================================
// Shading Functions
//=============================================================================

// Schlick Fresnel approximation
float SchlickFresnel(float cosTheta, float F0)
{
	return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

// Blinn-Phong specular
float BlinnPhongSpecular(float3 N, float3 V, float3 L, float roughness)
{
	float3 H = normalize(L + V);
	float NoH = saturate(dot(N, H));
	float shininess = (1.0 - roughness) * 128.0;
	return pow(NoH, shininess);
}

//=============================================================================
// Vertex Shader (Fullscreen Triangle)
//=============================================================================

struct FVertexOutput
{
	float4 Position : SV_POSITION;
	float2 UV : TEXCOORD0;
};

void MainVS(
	in uint VertexID : SV_VertexID,
	out FVertexOutput Output)
{
	// Generate fullscreen triangle vertices
	float2 UV = float2((VertexID << 1) & 2, VertexID & 2);
	Output.UV = UV;
	Output.Position = float4(UV * float2(2.0, -2.0) + float2(-1.0, 1.0), 0.5, 1.0);
}

//=============================================================================
// Pixel Shader
//=============================================================================

void MainPS(
	FVertexOutput Input,
	out float4 OutColor : SV_Target0
#if OUTPUT_DEPTH
	, out float OutDepth : SV_Target1
#endif
)
{
	float2 UV = Input.UV;

#if OUTPUT_DEPTH
	OutDepth = 0.0;  // Default: no hit = far plane (reversed-Z)
#endif

#if USE_SDF_VOLUME
	// SDF Volume mode: no early exit based on ParticleCount
	// We use the pre-baked 3D SDF texture instead
#else
	// Legacy mode: Early out if no particles
	if (ParticleCount <= 0)
	{
		discard;
		return;
	}
#endif

	// Get camera ray
	float3 RayOrigin, RayDirection;
	GetCameraRay(UV, RayOrigin, RayDirection);

	// Get scene depth for occlusion
	// SceneDepth UV 변환: ScreenUV를 SceneDepth의 유효 영역에 매핑
	float2 SceneUV = UV * (SceneViewRect / SceneTextureSize);
	float SceneDeviceZ = SceneDepthTexture.SampleLevel(SceneTextureSampler, SceneUV, 0).r;
	float SceneLinearDepth = ConvertDeviceZToLinearDepth(SceneDeviceZ);

	// Clamp max distance to scene depth
	float MaxDist = min(RayMarchMaxDistance, SceneLinearDepth * 100.0);  // Convert to world units

	// Ray march (with screen position for temporal jittering)
	FRayMarchResult result = RayMarchSDF(RayOrigin, RayDirection, RayMarchMaxDistance, Input.Position.xy);

	if (!result.bHit)
	{
		discard;
		return;
	}

	// Depth occlusion test: Compare hit point depth with scene depth
	// Transform hit position to clip space to get its device Z
	float4 HitViewPos = mul(float4(result.Position, 1.0), ViewMatrix);
	float4 HitClipPos = mul(HitViewPos, ProjectionMatrix);
	float HitDeviceZ = HitClipPos.z / HitClipPos.w;

	// UE5 uses reversed-Z: closer objects have higher Z values
	// If hit point is behind scene geometry, discard
	// Add small bias to prevent flickering at depth boundaries
	float DepthBias = 0.0001;
	if (HitDeviceZ < SceneDeviceZ - DepthBias)
	{
		discard;
		return;
	}

#if OUTPUT_DEPTH
	// Output fluid depth for shadow projection
	OutDepth = HitDeviceZ;
#endif

	//=========================================================================
	// Shading
	//=========================================================================

	float3 N = result.Normal;
	float3 V = -RayDirection;
	float3 P = result.Position;
	float Thickness = result.Thickness;

	// Default light direction (top-down sun angle)
	float3 L = normalize(float3(0.5, 0.5, -0.707));

	// Fresnel (Schlick approximation) - use smoothstep for softer transition
	float NoV = saturate(dot(N, V));
	float FresnelRaw = SchlickFresnel(NoV, FresnelStrength);
	float Fresnel = smoothstep(0.0, 1.0, FresnelRaw) * 0.5;  // Soften and reduce

	// Specular (Blinn-Phong) - softer specular
	float NoL = saturate(dot(N, L));
	float SpecularRaw = BlinnPhongSpecular(N, V, L, max(SpecularRoughness, 0.5));  // Min roughness 0.5
	float Specular = smoothstep(0.0, 1.0, SpecularRaw) * SpecularStrength * NoL * 0.3;  // Reduce intensity

	// Beer's Law absorption - gentler
	float AbsorptionFactor = 1.0 - exp(-Thickness * AbsorptionCoefficient * 0.05);

	// Refracted background sampling
	float3 RefractDir = refract(-V, N, 1.0 / RefractiveIndex);
	float2 RefractedUV = UV + RefractDir.xy * 0.02;  // Reduce distortion
	RefractedUV = saturate(RefractedUV);
	float3 RefractedBackground = SceneColorTexture.Sample(SceneTextureSampler, RefractedUV).rgb;

	// Base color - mostly fluid color with subtle background blend
	float3 BaseColor = lerp(RefractedBackground, FluidColor.rgb, saturate(AbsorptionFactor + 0.7));

	//=========================================================================
	// Subsurface Scattering (SSS) - Jelly Effect (simplified)
	//=========================================================================

	// SSS: simple rim lighting effect
	float RimFactor = 1.0 - NoV;
	float SSSFactor = smoothstep(0.3, 1.0, RimFactor) * SSSIntensity * 0.5;
	float3 SSSContribution = SSSColor.rgb * SSSFactor;

	//=========================================================================
	// Final Composition
	//=========================================================================

	// Fresnel reflection (subtle environment reflection)
	float3 ReflectedColor = EnvironmentLightColor.rgb * Fresnel;

	// Simple diffuse lighting
	float Diffuse = NoL * 0.5 + 0.5;  // Half-lambert for softer shading

	// Combine all lighting
	float3 FinalColor = BaseColor * Diffuse;
	FinalColor += ReflectedColor * 0.3;
	FinalColor += SSSContribution;
	FinalColor += Specular;

	// Alpha - simpler calculation
	float Alpha = saturate(0.85 + Fresnel * 0.15);

	OutColor = float4(FinalColor, Alpha);
}
