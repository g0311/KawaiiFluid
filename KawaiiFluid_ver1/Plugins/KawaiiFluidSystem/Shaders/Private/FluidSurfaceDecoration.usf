// Copyright KawaiiFluid Team. All Rights Reserved.
//
// Surface Decoration Shader for Fluid Rendering
// Applies texture overlays, foam, emissive effects on fluid surfaces.

#include "/Engine/Private/Common.ush"

//=============================================================================
// Input Textures (from SSFR pipeline)
//=============================================================================

Texture2D<float> DepthTexture;
Texture2D<float4> NormalTexture;
Texture2D<float> ThicknessTexture;
Texture2D<float4> SceneColorTexture;
SamplerState PointClampSampler;
SamplerState BilinearWrapSampler;
SamplerState BilinearMirrorSampler;

//=============================================================================
// Decoration Textures
//=============================================================================

Texture2D<float4> FoamTexture;
Texture2D<float4> LayerTexture;
Texture2D<float4> LayerNormalMap;
Texture2D<float2> FlowMapTexture;
Texture2D<float2> VelocityMapTexture;     // Screen-space velocity from Depth pass (RDG)
Texture2D<float2> AccumulatedFlowTexture; // Accumulated flow offset in world units (velocity-based, RDG)
Texture2D<float> OcclusionMaskTexture;    // Occlusion mask (R8: 1.0=visible, 0.0=occluded by scene geometry)
SamplerState BilinearClampSampler;        // For screen-space textures that shouldn't wrap

//=============================================================================
// Parameters
//=============================================================================

float2 TextureSize;
float2 SSFRTextureSize;  // Size of SSFR intermediate textures (may differ from TextureSize)
float4 ViewRect;  // xy = Min, zw = Max
float Time;

// View reconstruction
float4x4 InvViewProjectionMatrix;
float4x4 ViewMatrix;
float4x4 InvViewMatrix;
float4x4 InvProjectionMatrix;
float3 CameraPosition;

// Global
float GlobalOpacity;
float BlendWithFluidColor;

// Foam
int bFoamEnabled;
float4 FoamColor;
float FoamVelocityThreshold;
float FoamIntensity;
float FoamTilingScale;
int bWaveCrestFoam;
int FoamAddressingMode;  // 0 = Wrap (repeat), 1 = Mirror

// Emissive (dynamic glow)
int bEmissiveEnabled;
float4 EmissiveColor;
float EmissiveIntensity;
int bVelocityEmissive;
float VelocitySensitivity;
float MinEmissive;
float PulsePeriod;
float PulseAmplitude;

// Flow
int bFlowEnabled;
int bUseAccumulatedFlow;  // Use accumulated flow (velocity-based) instead of Time-based
float FlowSpeed;
float FlowDistortionStrength;

// Layer
int bLayerEnabled;
float LayerTilingScale;
int LayerAddressingMode;  // 0 = Wrap (repeat), 1 = Mirror
float LayerOpacity;
float LayerNormalZThreshold;
float LayerFlowInfluence;
float2 LayerScrollSpeed;
int bLayerNormalMapEnabled;
float LayerNormalStrength;

// Lighting parameters for texture shading
int bApplyLightingToTextures;
float3 LightDirection;  // World space light direction (normalized)
float3 LightColor;      // Directional light color
float3 AmbientColor;    // Ambient light color
float TextureSpecularStrength;
float TextureSpecularRoughness;

// Debug
int DebugMode;  // 0=off, 1=AccumulatedFlow, 2=Velocity, 3=Both

// Output
RWTexture2D<float4> OutputTexture;

//=============================================================================
// Helper Functions
//=============================================================================

// Background depth threshold (matches FluidSmoothing.usf and FluidFlowAccumulation.usf)
// This value should be consistent across all fluid shaders
#define BACKGROUND_DEPTH_THRESH 3.0e30f

// Minimum foam amount to process (avoids unnecessary work for negligible foam)
#define FOAM_MIN_AMOUNT 0.01

// Fallback thresholds for velocity-based flow when accumulated flow is near zero
// These help diagnose flow accumulation issues
#define ACCUMULATED_FLOW_MIN_THRESHOLD 0.1
#define VELOCITY_FALLBACK_THRESHOLD 1.0

// Reconstruct view-space position from linear depth
float3 ReconstructViewPosition(float2 ScreenUV, float LinearDepth)
{
	// Convert texture UV to NDC (Clip Space)
	// Texture UV: (0,0) = top-left, (1,1) = bottom-right
	// NDC: (-1,-1) = bottom-left, (1,1) = top-right
	// Therefore Y must be flipped: ClipY = 1 - UV.y * 2
	float2 ClipXY = float2(ScreenUV.x * 2.0 - 1.0, 1.0 - ScreenUV.y * 2.0);
	float4 ClipPosition = float4(ClipXY, 0.5, 1.0);

	// Unproject to View Space
	float4 ViewPosition = mul(ClipPosition, InvProjectionMatrix);
	ViewPosition /= ViewPosition.w;

	// Extract ray direction (normalize so Z = 1)
	float3 ViewRay = ViewPosition.xyz / ViewPosition.z;

	// Scale by depth: LinearDepth is positive, ViewSpace Z is negative for in-front objects
	return ViewRay * (-LinearDepth);
}

// Reconstruct world position from view-space linear depth
float3 ReconstructWorldPosition(float2 UV, float LinearDepth)
{
	// First get view-space position
	float3 ViewPos = ReconstructViewPosition(UV, LinearDepth);

	// Transform to world space
	float4 WorldPos = mul(float4(ViewPos, 1.0), InvViewMatrix);

	return WorldPos.xyz;
}

// Sample flow direction (from velocity map or static flow map)
float2 SampleFlowDirection(float2 UV)
{
	if (bFlowEnabled > 0)
	{
		// Try velocity map first (runtime generated)
		float2 Velocity = VelocityMapTexture.SampleLevel(BilinearWrapSampler, UV, 0).xy;
		if (length(Velocity) > 0.001)
		{
			return normalize(Velocity);
		}

		// Fallback to static flow map
		return FlowMapTexture.SampleLevel(BilinearWrapSampler, UV, 0).xy * 2.0 - 1.0;
	}
	return float2(0, 0);
}

// Get accumulated flow offset (velocity-based, accumulated over time)
// Returns the flow offset in world units (cm)
// Still water: returns near-zero (no movement)
// Flowing water: returns accumulated offset (texture moves)
// SSFRTexcoord: UV coordinates in SSFR texture space [0,1]
float2 GetAccumulatedFlowOffset(float2 SSFRTexcoord)
{
	if (bUseAccumulatedFlow > 0)
	{
		// Sample accumulated flow using SSFR coordinates
		// Use BilinearClampSampler to avoid wrapping at screen edges
		// Returns world-space offset in cm (accumulated velocity * dt)
		return AccumulatedFlowTexture.SampleLevel(BilinearClampSampler, SSFRTexcoord, 0).xy;
	}
	return float2(0, 0);
}

// Flow-based UV animation (two-phase blend to avoid seams)
// When bUseAccumulatedFlow is true, uses accumulated flow instead of Time
float2 FlowUV(float2 BaseUV, float2 FlowDir, float Phase, float2 AccumulatedOffset)
{
	if (bUseAccumulatedFlow > 0)
	{
		// Velocity-based flow: use accumulated offset directly
		// The accumulated offset already encodes the flow amount over time
		// For dual-phase, use different phases of the accumulated offset
		float Progress = frac(length(AccumulatedOffset) * FlowSpeed + Phase);
		return BaseUV + AccumulatedOffset * FlowDistortionStrength + FlowDir * Progress * FlowDistortionStrength * 0.1;
	}
	else
	{
		// Time-based flow (original behavior)
		float Progress = frac(Time * FlowSpeed + Phase);
		return BaseUV + FlowDir * Progress * FlowDistortionStrength;
	}
}

// Legacy FlowUV for compatibility (used where accumulated flow is not needed)
float2 FlowUV_Legacy(float2 BaseUV, float2 FlowDir, float Phase)
{
	float Progress = frac(Time * FlowSpeed + Phase);
	return BaseUV + FlowDir * Progress * FlowDistortionStrength;
}

// Sample foam texture with addressing mode support
float4 SampleFoamTexture(float2 UV)
{
	if (FoamAddressingMode == 1)
	{
		// Mirror addressing mode
		return FoamTexture.SampleLevel(BilinearMirrorSampler, UV, 0);
	}
	else
	{
		// Wrap (repeat) addressing mode (default)
		return FoamTexture.SampleLevel(BilinearWrapSampler, UV, 0);
	}
}

// Sample layer texture with addressing mode support
float4 SampleLayerTexture(float2 UV)
{
	if (LayerAddressingMode == 1)
	{
		// Mirror addressing mode
		return LayerTexture.SampleLevel(BilinearMirrorSampler, UV, 0);
	}
	else
	{
		// Wrap (repeat) addressing mode (default)
		return LayerTexture.SampleLevel(BilinearWrapSampler, UV, 0);
	}
}

// Sample layer normal map with addressing mode support
float3 SampleLayerNormalMap(float2 UV)
{
	float4 NormalSample;
	if (LayerAddressingMode == 1)
	{
		NormalSample = LayerNormalMap.SampleLevel(BilinearMirrorSampler, UV, 0);
	}
	else
	{
		NormalSample = LayerNormalMap.SampleLevel(BilinearWrapSampler, UV, 0);
	}
	// Decode from [0,1] to [-1,1]
	return NormalSample.xyz * 2.0 - 1.0;
}

// Blend two normals using Reoriented Normal Mapping (RNM)
// Reference: "Blending in Detail" by Colin Barr√©-Brisebois & Stephen Hill
// BaseNormal: existing surface normal (world space, normalized)
// DetailNormal: texture normal (tangent space, Z-up, in [-1,1] range)
// Strength: blend strength (0 = base only, 1 = full detail)
float3 BlendNormalsRNM(float3 BaseNormal, float3 DetailNormal, float Strength)
{
	// Scale detail normal XY by strength, keep Z unchanged
	float3 ScaledDetail = float3(DetailNormal.xy * Strength, DetailNormal.z);

	// Ensure both normals are normalized
	float3 n1 = normalize(BaseNormal);
	float3 n2 = normalize(ScaledDetail);

	// RNM blend formula (correct version)
	// This reorients n2 from tangent space to the coordinate frame defined by n1
	float3 t = n1 + float3(0, 0, 1);
	float3 u = n2 * float3(-1, -1, 1);

	// Avoid division by zero when base normal is (0, 0, -1)
	float tDotU = dot(t, u);
	if (abs(t.z) < 0.0001f)
	{
		// Fallback to simple lerp for edge case
		return normalize(lerp(n1, n2, Strength));
	}

	return normalize(t * tDotU / t.z - u);
}

// Build TBN matrix from world normal (for Z-axis projection)
// Since we project from Z-axis, tangent is along X, bitangent along Y
float3x3 BuildTBNFromWorldNormal(float3 WorldNormal)
{
	// For Z-axis projection, use world X and Y as tangent/bitangent
	// Then adjust based on the actual surface normal
	float3 Up = abs(WorldNormal.z) < 0.999 ? float3(0, 0, 1) : float3(1, 0, 0);
	float3 Tangent = normalize(cross(Up, WorldNormal));
	float3 Bitangent = cross(WorldNormal, Tangent);
	return float3x3(Tangent, Bitangent, WorldNormal);
}

// Apply normal map to existing world normal
float3 ApplyNormalMap(float3 WorldNormal, float3 TangentNormal, float Strength)
{
	if (Strength <= 0.0)
	{
		return WorldNormal;
	}

	// Build TBN matrix
	float3x3 TBN = BuildTBNFromWorldNormal(WorldNormal);

	// Transform tangent-space normal to world space
	float3 DetailWorldNormal = normalize(mul(TangentNormal, TBN));

	// Blend with original normal
	return normalize(lerp(WorldNormal, DetailWorldNormal, Strength));
}

// Compute lighting for texture albedo
// Returns lit color with diffuse + specular
// Uses View.DirectionalLightDirection if available (same as FluidComposite.usf)
float3 ComputeTextureLighting(float3 Albedo, float3 WorldNormal, float3 WorldPos)
{
	if (bApplyLightingToTextures <= 0)
	{
		// No lighting - return albedo as-is
		return Albedo;
	}

	// View direction (camera to surface)
	float3 ViewDir = normalize(CameraPosition - WorldPos);

	// Get light direction from View uniform buffer (same as FluidComposite.usf)
	// View.DirectionalLightDirection is TO the light, so negate for FROM light
	float3 EffectiveLightDir = normalize(-View.DirectionalLightDirection);
	float3 EffectiveLightColor = View.DirectionalLightColor.rgb;

	// Fallback to passed parameters if View light is invalid (zero direction)
	if (length(View.DirectionalLightDirection) < 0.001)
	{
		EffectiveLightDir = -LightDirection;
		EffectiveLightColor = LightColor;
	}

	// Diffuse (Lambert)
	float NoL = saturate(dot(WorldNormal, EffectiveLightDir));
	float3 Diffuse = Albedo * NoL * EffectiveLightColor;

	// Ambient
	float3 Ambient = Albedo * AmbientColor;

	// Specular (Blinn-Phong)
	float3 HalfDir = normalize(EffectiveLightDir + ViewDir);
	float NoH = saturate(dot(WorldNormal, HalfDir));
	float Shininess = (1.0 - TextureSpecularRoughness) * 128.0;
	float3 Specular = pow(NoH, Shininess) * TextureSpecularStrength * EffectiveLightColor;

	return Diffuse + Ambient + Specular;
}

// Compute foam intensity based on various factors
float ComputeFoamIntensity(float2 UV, float3 WorldNormal, float Depth, float2 DepthGradient, float VelocityMag)
{
	float Foam = 0.0;

	// Velocity-based foam
	float VelocityFoam = saturate((VelocityMag - FoamVelocityThreshold) / FoamVelocityThreshold);
	Foam += VelocityFoam;

	// Wave crest foam (high depth gradient = wave breaking)
	if (bWaveCrestFoam > 0)
	{
		float GradientMag = length(DepthGradient);
		float CrestFoam = saturate(GradientMag * 10.0);  // Tune multiplier

		// Only on top surfaces
		CrestFoam *= saturate(WorldNormal.z);
		Foam += CrestFoam * 0.5;
	}

	return saturate(Foam * FoamIntensity);
}

// Compute emissive intensity (for lava, magic, etc.)
// BaseVelocity: internal reference velocity (200 cm/s = typical lava flow)
#define EMISSIVE_BASE_VELOCITY 200.0

// Returns HDR emissive value directly
// MinEmissive: HDR base brightness (always applied)
// EmissiveIntensity: scales dynamic parts (velocity, pulse) only
float ComputeEmissiveIntensity(float VelocityMag, float3 WorldNormal)
{
	// Dynamic part: velocity and pulse contributions (0~1+ normalized)
	float DynamicPart = 0.0;

	if (bVelocityEmissive > 0)
	{
		// Higher velocity = brighter emissive (useful for lava, magic fluids)
		// VelocitySensitivity scales how quickly it reaches max brightness
		// Sensitivity 1.0 = max at 200 cm/s, 2.0 = max at 100 cm/s, 0.5 = max at 400 cm/s
		float VelocityFactor = saturate(VelocityMag * VelocitySensitivity / EMISSIVE_BASE_VELOCITY);
		DynamicPart += VelocityFactor;
	}

	// Pulsation effect (PulsePeriod = seconds per cycle, 0 = disabled)
	if (PulsePeriod > 0.0)
	{
		float Pulse = sin(Time * 2.0 * PI / PulsePeriod) * 0.5 + 0.5;
		DynamicPart += Pulse * PulseAmplitude;
	}

	// MinEmissive (HDR direct) + DynamicPart * Intensity
	return MinEmissive + DynamicPart * EmissiveIntensity;
}

//=============================================================================
// Main Compute Shader
//=============================================================================

[numthreads(8, 8, 1)]
void SurfaceDecorationCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	// Output texture size (SceneColorTexture / OutputTexture size)
	int2 OutputSize = int2(TextureSize);

	// Bounds check against output size
	if (any(DispatchThreadId.xy >= uint2(OutputSize)))
	{
		return;
	}

	// Output pixel coordinate
	int2 PixelCoord = int2(DispatchThreadId.xy);

	// Sample SceneColor using output coordinates (same size as output)
	float4 SceneColor = SceneColorTexture.Load(int3(PixelCoord, 0));

	// ViewRect defines where SSFR textures are mapped in output space
	// SSFR(0,0) = ViewRect.Min, SSFR(SSFRSize) = ViewRect.Max
	int2 ViewRectMin = int2(ViewRect.xy);
	int2 ViewRectMax = int2(ViewRect.zw);
	int2 ViewRectSize = ViewRectMax - ViewRectMin;

	// Check if pixel is within ViewRect (where fluid is rendered)
	if (PixelCoord.x < ViewRectMin.x || PixelCoord.x >= ViewRectMax.x ||
	    PixelCoord.y < ViewRectMin.y || PixelCoord.y >= ViewRectMax.y)
	{
		// Outside ViewRect - pass through scene color (no fluid here)
		OutputTexture[PixelCoord] = SceneColor;
		return;
	}

	// Map output pixel to SSFR texture coordinate
	// OutputPixel in ViewRect -> SSFR coordinate
	int2 SSFRSize = int2(SSFRTextureSize);
	float2 ViewRectUV = float2(PixelCoord - ViewRectMin) / float2(ViewRectSize);
	int2 SSFRPixelCoord = int2(ViewRectUV * float2(SSFRSize));
	// Clamp to valid range
	SSFRPixelCoord = clamp(SSFRPixelCoord, int2(0, 0), SSFRSize - int2(1, 1));

	// UV normalized to 0-1 range within ViewRect (for decoration textures)
	float2 UV = ViewRectUV;

	// Sample SSFR outputs using SSFR coordinates
	float Depth = DepthTexture.Load(int3(SSFRPixelCoord, 0));
	float4 NormalData = NormalTexture.Load(int3(SSFRPixelCoord, 0));
	float Thickness = ThicknessTexture.Load(int3(SSFRPixelCoord, 0));

	// Background check - pass through
	if (Depth > BACKGROUND_DEPTH_THRESH || Thickness < 0.001)
	{
		OutputTexture[PixelCoord] = SceneColor;
		return;
	}

	// Occlusion check - if pixel is occluded by scene geometry, pass through scene color
	// OcclusionMask: 1.0 = fluid is visible, 0.0 = fluid is occluded by closer scene geometry
	// Threshold 0.5 provides hysteresis to prevent flickering at boundaries
	float OcclusionMask = OcclusionMaskTexture.Load(int3(SSFRPixelCoord, 0));
	const float OcclusionThreshold = 0.5;
	if (OcclusionMask < OcclusionThreshold)
	{
		OutputTexture[PixelCoord] = SceneColor;
		return;
	}

	// Extract world normal (assuming NormalTexture stores view-space normal)
	float3 ViewNormal = NormalData.xyz * 2.0 - 1.0;
	float3x3 ViewToWorld = transpose((float3x3)ViewMatrix);
	float3 WorldNormal = normalize(mul(ViewNormal, ViewToWorld));

	// Reconstruct world position for camera-independent texturing
	float3 WorldPos = ReconstructWorldPosition(UV, Depth);

	// Fixed Z-axis projection (XY plane) - texture always projected from above
	// This ensures consistent appearance regardless of viewing angle
	float2 WorldUV = WorldPos.xy;

	// SSFR texture coordinate (normalized [0,1] for SSFR-sized textures like Velocity, AccumulatedFlow)
	float2 SSFRTexcoord = (float2(SSFRPixelCoord) + 0.5) / float2(SSFRSize);

	// Sample velocity for flow and foam (use SSFR coordinates for screen-space textures)
	float2 Velocity = VelocityMapTexture.SampleLevel(BilinearClampSampler, SSFRTexcoord, 0).xy;
	float VelocityMag = length(Velocity);
	float2 FlowDir = SampleFlowDirection(UV);
	float2 AccumulatedFlow = GetAccumulatedFlowOffset(SSFRTexcoord);

	// Compute depth gradient for wave crest detection (using SSFR coordinates)
	float DepthL = DepthTexture.Load(int3(max(SSFRPixelCoord.x - 1, 0), SSFRPixelCoord.y, 0));
	float DepthR = DepthTexture.Load(int3(min(SSFRPixelCoord.x + 1, SSFRSize.x - 1), SSFRPixelCoord.y, 0));
	float DepthT = DepthTexture.Load(int3(SSFRPixelCoord.x, max(SSFRPixelCoord.y - 1, 0), 0));
	float DepthB = DepthTexture.Load(int3(SSFRPixelCoord.x, min(SSFRPixelCoord.y + 1, SSFRSize.y - 1), 0));
	float2 DepthGradient = float2(DepthR - DepthL, DepthB - DepthT) * 0.5;

	//=========================================================================
	// Accumulate decoration effects
	//=========================================================================

	float3 DecorationColor = float3(0, 0, 0);
	float DecorationAlpha = 0.0;
	float3 EmissiveAccum = float3(0, 0, 0);

	//-------------------------------------------------------------------------
	// Foam Effect - Z-axis projection (XY plane)
	//-------------------------------------------------------------------------
	if (bFoamEnabled > 0)
	{
		float FoamAmount = ComputeFoamIntensity(UV, WorldNormal, Depth, DepthGradient, VelocityMag);

		if (FoamAmount > FOAM_MIN_AMOUNT)
		{
			// Flow offset for foam (AccumulatedFlow is in world-space units cm)
			float2 FoamFlowOffset = float2(0, 0);
			if (bUseAccumulatedFlow > 0)
			{
				// Scale to UV space using FoamTilingScale
				// AccumulatedFlow (cm) * TilingScale (1/cm-per-tile) = UV offset
				FoamFlowOffset = AccumulatedFlow * FoamTilingScale;

				// Debug fallback: if accumulated flow is zero but we have velocity
				float AccumMag = length(AccumulatedFlow);
				if (AccumMag < ACCUMULATED_FLOW_MIN_THRESHOLD && VelocityMag > VELOCITY_FALLBACK_THRESHOLD)
				{
					// Use instantaneous velocity as fallback (diagnostic)
					FoamFlowOffset = Velocity * FoamTilingScale * 0.01;
				}
			}

			// Phase for dual-blend (use length of accumulated flow for phase cycling)
			float Phase = (bUseAccumulatedFlow > 0) ? frac(length(AccumulatedFlow) * FoamTilingScale * FlowSpeed) : frac(Time * FlowSpeed);
			float BlendPhase = abs(Phase * 2.0 - 1.0);

			// Z-axis projection UV (XY plane)
			// Subtract flow offset so texture moves with flow direction
			float2 FoamUV1 = WorldUV * FoamTilingScale - FoamFlowOffset;
			float2 FoamUV2 = WorldUV * FoamTilingScale - FoamFlowOffset * 0.5;

			// Sample foam (single projection) with addressing mode support
			float4 FoamSample1 = SampleFoamTexture(FoamUV1);
			float4 FoamSample2 = SampleFoamTexture(FoamUV2);

			// Dual-phase blend
			float4 FoamSample = lerp(FoamSample1, FoamSample2, BlendPhase);

			// Use texture RGB as color, grayscale (R) as mask
			float3 FoamRGB = FoamSample.rgb * FoamColor.rgb;
			float FoamMask = FoamSample.r * FoamAmount;

			DecorationColor += FoamRGB * FoamMask;
			DecorationAlpha = max(DecorationAlpha, FoamMask * FoamColor.a);
		}
	}

	//-------------------------------------------------------------------------
	// Emissive Effect (dynamic glow for lava, magic, etc.)
	// - MinEmissive: HDR base brightness (always applied)
	// - VelocityEmissive: faster flow = brighter (scaled by Intensity)
	// - Pulse: periodic brightness variation (scaled by Intensity)
	// - Thickness compensation: thicker areas get boosted to appear consistent
	//-------------------------------------------------------------------------
	if (bEmissiveEnabled > 0)
	{
		// ComputeEmissiveIntensity returns HDR value: MinEmissive + DynamicPart * Intensity
		float EmissiveAmount = ComputeEmissiveIntensity(VelocityMag, WorldNormal);

		// Thickness compensation: thicker areas appear darker due to FluidComposite absorption
		// Boost emissive in thicker areas to maintain visual consistency
		// ThicknessBoost: 1.0 at Thickness=0, ~1.5 at Thickness=5, ~2.0 at Thickness=10
		float ThicknessBoost = 1.0 + Thickness * 0.1;

		float FinalEmissive = EmissiveAmount * ThicknessBoost;

		EmissiveAccum += EmissiveColor.rgb * FinalEmissive;
	}

	//-------------------------------------------------------------------------
	// Layer (custom texture overlay) - Z-axis projection
	// With normal map, flow animation, and lighting support
	//-------------------------------------------------------------------------
	if (bLayerEnabled > 0)
	{
		// Flow offset (in UV space - scaled by TilingScale to match WorldUV scale)
		// SUBTRACT flow offset so texture appears to move WITH the fluid direction
		float2 FlowOffset = float2(0, 0);
		if (LayerFlowInfluence > 0.0)
		{
			if (bUseAccumulatedFlow > 0)
			{
				// AccumulatedFlow is in world-space units (cm), scale to UV space
				// FlowOffset = AccumulatedFlow (cm) * TilingScale (1/cm-per-tile) * Influence
				FlowOffset = AccumulatedFlow * LayerTilingScale * LayerFlowInfluence;

				// Debug fallback: if AccumulatedFlow is near zero but velocity is non-zero,
				// use time-based flow as fallback (helps diagnose accumulation issues)
				float AccumMag = length(AccumulatedFlow);
				if (AccumMag < ACCUMULATED_FLOW_MIN_THRESHOLD && VelocityMag > VELOCITY_FALLBACK_THRESHOLD)
				{
					// Fallback to velocity-based instant flow (diagnostic mode)
					FlowOffset = Velocity * LayerTilingScale * LayerFlowInfluence * 0.01;
				}
			}
			else
			{
				FlowOffset = FlowDir * Time * FlowSpeed * LayerFlowInfluence;
			}
		}
		float2 ScrollOffset = LayerScrollSpeed * Time;

		// Z-axis projection UV (XY plane)
		// Subtract FlowOffset so texture moves in the direction of flow
		float2 LayerUV = WorldUV * LayerTilingScale - FlowOffset + ScrollOffset;

		// Sample texture (single projection) with addressing mode support
		float4 LayerSample = SampleLayerTexture(LayerUV);

		// Use texture alpha if available (> 0), otherwise use full opacity
		float TextureAlpha = LayerSample.a > 0.001 ? LayerSample.a : 1.0;
		float LayerAlpha = TextureAlpha * LayerOpacity;

		// Apply normal map if enabled
		float3 ShadingNormal = WorldNormal;
		if (bLayerNormalMapEnabled > 0 && LayerNormalStrength > 0.0)
		{
			float3 TangentNormal = SampleLayerNormalMap(LayerUV);
			ShadingNormal = ApplyNormalMap(WorldNormal, TangentNormal, LayerNormalStrength);
		}

		// Compute lighting for texture albedo
		float3 LitLayerColor = ComputeTextureLighting(LayerSample.rgb, ShadingNormal, WorldPos);

		DecorationColor = lerp(DecorationColor, LitLayerColor, LayerAlpha);
		DecorationAlpha = max(DecorationAlpha, LayerAlpha);
	}

	//=========================================================================
	// Final Composite
	//=========================================================================

	float3 FinalColor = SceneColor.rgb;

	// Blend decoration with scene
	float EffectiveAlpha = DecorationAlpha * GlobalOpacity;

	// Option to blend with fluid color instead of replacing
	if (BlendWithFluidColor > 0.0)
	{
		DecorationColor = lerp(DecorationColor, DecorationColor * SceneColor.rgb, BlendWithFluidColor);
	}

	FinalColor = lerp(FinalColor, DecorationColor, EffectiveAlpha);

	// Add emissive (additive)
	FinalColor += EmissiveAccum;

	//=========================================================================
	// Debug Visualization
	//=========================================================================
	if (DebugMode > 0)
	{
		float3 DebugColor = float3(0, 0, 0);

		// AccumulatedFlow debug (DebugMode 1 or 3)
		if (DebugMode == 1 || DebugMode == 3)
		{
			// Visualize accumulated flow as color
			// Scale to make small values visible (assume max ~1000 cm)
			float2 FlowNorm = AccumulatedFlow / 100.0;  // Normalize to ~10 units visible
			DebugColor.r = saturate(abs(FlowNorm.x));   // Red = X flow magnitude
			DebugColor.g = saturate(abs(FlowNorm.y));   // Green = Y flow magnitude
		}

		// Velocity debug (DebugMode 2 or 3)
		if (DebugMode == 2 || DebugMode == 3)
		{
			// Visualize velocity as blue channel
			// Scale to make reasonable velocities visible (assume max ~500 cm/s)
			float VelNorm = VelocityMag / 100.0;
			DebugColor.b = saturate(VelNorm);
		}

		// Blend debug color with scene (50% overlay)
		FinalColor = lerp(FinalColor, DebugColor, 0.7);
	}

	OutputTexture[PixelCoord] = float4(FinalColor, SceneColor.a);
}
