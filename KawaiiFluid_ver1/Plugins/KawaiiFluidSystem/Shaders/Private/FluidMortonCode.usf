// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Fluid Physics - Morton Code (Z-Order Curve) Computation
//
// Morton Code encodes 3D spatial coordinates into a 1D integer that preserves spatial locality.
// Particles sorted by Morton Code will have spatially close particles also close in memory.
//
// Configuration:
//   MORTON_GRID_AXIS_BITS = 7 (defined by C++ GPUFluidSimulatorShaders.h)
//   Grid Resolution = 2^7 = 128 per axis
//   Morton Code = 21 bits (7 × 3)
//   Max Cells = 128^3 = 2,097,152
//
// This matches the Preset's GridAxisBits and provides optimal cell size = SmoothingRadius.

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"

//=============================================================================
// Shader Parameters
//=============================================================================

// IMPORTANT: Use full particle structure to access PredictedPosition
// This must match the Solver which uses PredictedPosition for neighbor search
StructuredBuffer<FGPUFluidParticle> Particles;
RWStructuredBuffer<uint> MortonCodes;    // Output: Morton codes for sorting
RWStructuredBuffer<uint> ParticleIndices; // Output: Particle indices (0, 1, 2, ... N-1)

int ParticleCount;
float3 BoundsMin;      // Simulation bounds minimum
float3 BoundsExtent;   // Simulation bounds extent (Max - Min)
float CellSize;        // Grid cell size (= SmoothingRadius)

//=============================================================================
// Z-Order Sorting Configuration
// CRITICAL: Must match GPUFluidSimulatorShaders.h and FluidCellStartEnd.usf
//
// Default: 7 bits per axis → 21-bit Morton code → 2M cells
// The Morton code IS the Cell ID (no truncation needed)
//=============================================================================
#ifndef MORTON_GRID_AXIS_BITS
#define MORTON_GRID_AXIS_BITS 7  // 7 bits per axis (from GPUFluidSimulatorShaders.h)
#endif

#define MORTON_GRID_SIZE (1 << MORTON_GRID_AXIS_BITS)  // 128 (2^7)
#define MORTON_MAX_VALUE (MORTON_GRID_SIZE - 1)        // 127 (7-bit max)
#define MAX_CELLS (MORTON_GRID_SIZE * MORTON_GRID_SIZE * MORTON_GRID_SIZE)  // 2,097,152

//=============================================================================
// Morton Code Encoding Functions
// Interleaves bits: x0y0z0 x1y1z1 x2y2z2 ...
// Supports 6, 7, and 8-bit presets (Small, Medium, Large)
//=============================================================================

//-----------------------------------------------------------------------------
// 6-bit Morton Code (Small preset: 64³ cells)
// Each coordinate is 0-63, Morton code is 18 bits
//-----------------------------------------------------------------------------
uint ExpandBits6(uint v)
{
    v = v & 0x3Fu;  // 63 max (6 bits)
    v = (v | (v << 8)) & 0x0000F00Fu;
    v = (v | (v << 4)) & 0x000C30C3u;
    v = (v | (v << 2)) & 0x00249249u;
    return v;
}

uint Morton3D_6bit(uint x, uint y, uint z)
{
    x = min(x, 63u);
    y = min(y, 63u);
    z = min(z, 63u);
    return (ExpandBits6(z) << 2) | (ExpandBits6(y) << 1) | ExpandBits6(x);
}

//-----------------------------------------------------------------------------
// 7-bit Morton Code (Medium preset: 128³ cells)
// Each coordinate is 0-127, Morton code is 21 bits
//-----------------------------------------------------------------------------
uint ExpandBits7(uint v)
{
    v = v & 0x7Fu;  // 127 max (7 bits)
    v = (v | (v << 8)) & 0x0000F00Fu;
    v = (v | (v << 4)) & 0x000C30C3u;
    v = (v | (v << 2)) & 0x00249249u;
    return v;
}

uint Morton3D_7bit(uint x, uint y, uint z)
{
    x = min(x, 127u);
    y = min(y, 127u);
    z = min(z, 127u);
    return (ExpandBits7(z) << 2) | (ExpandBits7(y) << 1) | ExpandBits7(x);
}

//-----------------------------------------------------------------------------
// 8-bit Morton Code (Large preset: 256³ cells)
// Each coordinate is 0-255, Morton code is 24 bits
//-----------------------------------------------------------------------------
uint ExpandBits8(uint v)
{
    v = v & 0xFFu;  // 255 max (8 bits)
    v = (v | (v << 16)) & 0x030000FFu;
    v = (v | (v << 8)) & 0x0300F00Fu;
    v = (v | (v << 4)) & 0x030C30C3u;
    v = (v | (v << 2)) & 0x09249249u;
    return v;
}

uint Morton3D_8bit(uint x, uint y, uint z)
{
    x = min(x, 255u);
    y = min(y, 255u);
    z = min(z, 255u);
    return (ExpandBits8(z) << 2) | (ExpandBits8(y) << 1) | ExpandBits8(x);
}

//-----------------------------------------------------------------------------
// Generic Morton3D function - selects based on MORTON_GRID_AXIS_BITS
//-----------------------------------------------------------------------------
uint Morton3D(uint x, uint y, uint z)
{
#if MORTON_GRID_AXIS_BITS == 6
    return Morton3D_6bit(x, y, z);
#elif MORTON_GRID_AXIS_BITS == 8
    return Morton3D_8bit(x, y, z);
#else  // Default to 7-bit (Medium)
    return Morton3D_7bit(x, y, z);
#endif
}

// Legacy 10-bit version (for reference, not used)
uint ExpandBits10(uint v)
{
    v = (v * 0x00010001u) & 0xFF0000FFu;
    v = (v * 0x00000101u) & 0x0F00F00Fu;
    v = (v * 0x00000011u) & 0xC30C30C3u;
    v = (v * 0x00000005u) & 0x49249249u;
    return v;
}

uint Morton3D_10bit(uint x, uint y, uint z)
{
    x = min(x, 1023u);
    y = min(y, 1023u);
    z = min(z, 1023u);
    uint xx = ExpandBits10(x);
    uint yy = ExpandBits10(y);
    uint zz = ExpandBits10(z);
    return (zz << 2) | (yy << 1) | xx;
}

//=============================================================================
// Alternative: Cell-based Morton Code
// Uses cell coordinates instead of normalized positions
// Better for spatial hash grid alignment
//=============================================================================

int3 WorldToCell(float3 WorldPos, float CellSz)
{
    return int3(floor(WorldPos / CellSz));
}

uint Morton3DFromCell(int3 CellCoord, int3 GridMin)
{
    // Offset to make all coordinates positive (relative to grid min)
    int3 offset = CellCoord - GridMin;

    // Clamp negative values to 0 (particles outside bounds)
    // This must match FluidSolveDensityPressure.usf's GetMortonCellIDFromCellCoord
    uint3 uoffset = uint3(max(offset, int3(0, 0, 0)));
    uoffset = min(uoffset, uint3(MORTON_MAX_VALUE, MORTON_MAX_VALUE, MORTON_MAX_VALUE));

    // Use preset-specific Morton function
    return Morton3D(uoffset.x, uoffset.y, uoffset.z);
}

//=============================================================================
// Main Compute Shader: Compute Morton Codes (Legacy - not recommended)
// Uses normalized position quantization
//=============================================================================

#define THREAD_GROUP_SIZE 256

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ComputeMortonCodesCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint idx = DispatchThreadId.x;
    if (idx >= (uint)ParticleCount)
    {
        return;
    }

    // Read particle position
    float3 pos = Particles[idx].xyz;

    // Normalize position to [0, 1] range within simulation bounds
    float3 normalizedPos = saturate((pos - BoundsMin) / BoundsExtent);

    // Quantize to grid-bit integer (matches MORTON_GRID_SIZE)
    uint3 quantized = uint3(normalizedPos * float(MORTON_MAX_VALUE));

    // Compute Morton code using preset-specific function
    uint mortonCode = Morton3D(quantized.x, quantized.y, quantized.z);

    // Output Morton code and initial particle index
    MortonCodes[idx] = mortonCode;
    ParticleIndices[idx] = idx;
}

//=============================================================================
// Cell-based Morton Code Computation (RECOMMENDED)
// Uses cell coordinates for better grid alignment with SPH
//
// Key change from 10-bit version:
//   - 7-bit per axis → 21-bit Morton code = Cell ID (NO truncation needed!)
//   - Morton code directly maps to cell buffer index
//   - CellSize = SmoothingRadius for optimal SPH neighbor search
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ComputeMortonCodesCellBasedCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint idx = DispatchThreadId.x;
    if (idx >= (uint)ParticleCount)
    {
        return;
    }

    // IMPORTANT: Use PredictedPosition for Morton code calculation!
    // This MUST match the Solver which uses PredictedPosition for centerCell lookup.
    // Using Position here would cause mismatch: Morton codes based on old position,
    // but Solver searches neighbors based on predicted (new) position.
    float3 pos = Particles[idx].PredictedPosition;

    // Convert to cell coordinate
    int3 cellCoord = WorldToCell(pos, CellSize);

    // Compute grid minimum cell (based on bounds)
    int3 gridMin = int3(floor(BoundsMin / CellSize));

    // Compute 21-bit Morton code from cell coordinate
    // With 7-bit per axis: Morton code = Cell ID (no truncation needed!)
    uint mortonCode = Morton3DFromCell(cellCoord, gridMin);

    // Output Morton code as sort key (21-bit = Cell ID directly)
    // No truncation needed since MAX_CELLS = 128^3 = 2,097,152 < 2^21
    MortonCodes[idx] = mortonCode;
    ParticleIndices[idx] = idx;
}
