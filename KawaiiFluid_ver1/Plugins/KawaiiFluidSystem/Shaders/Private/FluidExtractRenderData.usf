// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Fluid Physics - Extract Render Data Pass
// Converts physics particle buffer to render particle buffer (GPU → GPU)

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"

//=============================================================================
// Render Particle Structure (must match FKawaiiRenderParticle - 32 bytes)
//=============================================================================

struct FRenderParticle
{
	float3 Position;
	float3 Velocity;
	float Radius;
	float Padding;
};

//=============================================================================
// Shader Parameters
//=============================================================================

StructuredBuffer<FGPUFluidParticle> PhysicsParticles;
RWStructuredBuffer<FRenderParticle> RenderParticles;
int ParticleCount;
float ParticleRadius;

// SoA (Structure of Arrays) 출력 버퍼 - 메모리 대역폭 최적화
RWStructuredBuffer<float3> RenderPositions;   // 12B per particle (SDF 핫패스)
RWStructuredBuffer<float3> RenderVelocities;  // 12B per particle (모션블러용)

//=============================================================================
// Main Compute Shader (Legacy AoS 출력)
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ExtractRenderDataCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)ParticleCount)
	{
		return;
	}

	FGPUFluidParticle physics = PhysicsParticles[idx];

	// Validate position - skip particles with invalid/extreme positions
	float3 pos = physics.Position;
	bool bValidPosition = !any(isnan(pos)) && !any(isinf(pos)) &&
						  abs(pos.x) < 1e10 && abs(pos.y) < 1e10 && abs(pos.z) < 1e10;

	FRenderParticle render;
	if (bValidPosition)
	{
		render.Position = pos;
		render.Velocity = physics.Velocity;
	}
	else
	{
		// Invalid particle - place at infinity so it won't be rendered
		render.Position = float3(1e20, 1e20, 1e20);
		render.Velocity = float3(0, 0, 0);
	}
	render.Radius = ParticleRadius;
	render.Padding = 0.0f;

	RenderParticles[idx] = render;
}

//=============================================================================
// SoA Compute Shader (메모리 대역폭 최적화)
// - 32B/particle → 12B/particle (Position만 사용 시 62% 절감)
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ExtractRenderDataSoACS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)ParticleCount)
	{
		return;
	}

	FGPUFluidParticle physics = PhysicsParticles[idx];

	// Validate position - skip particles with invalid/extreme positions
	float3 pos = physics.Position;
	float3 vel = physics.Velocity;

	bool bValidPosition = !any(isnan(pos)) && !any(isinf(pos)) &&
						  abs(pos.x) < 1e10 && abs(pos.y) < 1e10 && abs(pos.z) < 1e10;

	if (!bValidPosition)
	{
		// Invalid particle - place at infinity so it won't be rendered
		pos = float3(1e20, 1e20, 1e20);
		vel = float3(0, 0, 0);
	}

	// SoA 출력 - 각 속성을 별도 버퍼에 저장
	RenderPositions[idx] = pos;
	RenderVelocities[idx] = vel;
}
