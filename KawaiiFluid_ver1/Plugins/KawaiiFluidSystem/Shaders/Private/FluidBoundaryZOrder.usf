// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Fluid Physics - Boundary Particle Z-Order Sorting
// Computes Morton codes and Cell Start/End for boundary particles
// Enables O(K) neighbor search instead of O(M) full traversal

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidMortonUtils.ush"

//=============================================================================
// Structures (must match C++ definitions in GPUFluidParticle.h)
//=============================================================================

struct FGPUBoundaryParticle
{
	float3 Position;      // 12 bytes - World position
	float Psi;            // 4 bytes  - Boundary particle "volume" (density contribution)
	float3 Normal;        // 12 bytes - Surface normal
	int OwnerID;          // 4 bytes  - Owner component ID
	float3 Velocity;      // 12 bytes - World velocity (for moving boundaries)
	float FrictionCoeff;  // 4 bytes  - Coulomb friction coefficient (0~2)
};  // Total: 64 bytes - must match C++ FGPUBoundaryParticle

//=============================================================================
// Shared Parameters
//=============================================================================

int BoundaryParticleCount;
float3 BoundsMin;
float CellSize;

//=============================================================================
// Pass 1: Compute Boundary Morton Codes
// Calculates Morton code for each boundary particle based on position
//=============================================================================

StructuredBuffer<FGPUBoundaryParticle> BoundaryParticlesIn;
RWStructuredBuffer<uint> BoundaryMortonCodes;
RWStructuredBuffer<uint> BoundaryParticleIndices;

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ComputeBoundaryMortonCodesCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)BoundaryParticleCount)
	{
		return;
	}

	float3 pos = BoundaryParticlesIn[idx].Position;

	// Compute cell coordinates
	int3 cellCoord = int3(floor(pos / CellSize));

	// Compute grid offset relative to bounds minimum
	int3 gridMin = int3(floor(BoundsMin / CellSize));
	int3 offset = cellCoord - gridMin;

	// Clamp to valid Morton code range
	uint3 uoffset = uint3(max(offset, int3(0, 0, 0)));
	uoffset = min(uoffset, uint3(MORTON_MAX_VALUE, MORTON_MAX_VALUE, MORTON_MAX_VALUE));

	// Compute Morton code
	uint mortonCode = Morton3D(uoffset.x, uoffset.y, uoffset.z);

	BoundaryMortonCodes[idx] = mortonCode;
	BoundaryParticleIndices[idx] = idx;
}

//=============================================================================
// Pass 2: Clear Boundary Cell Start/End
// Initializes cell arrays to INVALID_INDEX before computing
//=============================================================================

RWStructuredBuffer<uint> BoundaryCellStart;
RWStructuredBuffer<uint> BoundaryCellEnd;

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ClearBoundaryCellIndicesCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint cellIdx = DispatchThreadId.x;
	if (cellIdx >= MAX_CELLS)
	{
		return;
	}

	BoundaryCellStart[cellIdx] = INVALID_INDEX;
	BoundaryCellEnd[cellIdx] = INVALID_INDEX;
}

//=============================================================================
// Pass 3: Reorder Boundary Particles by Sorted Indices
// Rearranges boundary particles according to sorted Morton code order
//=============================================================================

StructuredBuffer<FGPUBoundaryParticle> OldBoundaryParticles;
StructuredBuffer<uint> SortedBoundaryIndices;
RWStructuredBuffer<FGPUBoundaryParticle> SortedBoundaryParticles;

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ReorderBoundaryParticlesCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)BoundaryParticleCount)
	{
		return;
	}

	uint oldIdx = SortedBoundaryIndices[idx];
	SortedBoundaryParticles[idx] = OldBoundaryParticles[oldIdx];
}

//=============================================================================
// Pass 4: Compute Boundary Cell Start/End
// Must be called AFTER boundary particles are sorted by Morton code
// Determines the range [start, end] of particles in each cell
//=============================================================================

StructuredBuffer<uint> SortedBoundaryMortonCodes;

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ComputeBoundaryCellStartEndCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)BoundaryParticleCount)
	{
		return;
	}

	uint currentMorton = SortedBoundaryMortonCodes[idx];

	// First particle or different from previous - this is a cell start
	if (idx == 0)
	{
		BoundaryCellStart[currentMorton] = idx;
	}
	else
	{
		uint prevMorton = SortedBoundaryMortonCodes[idx - 1];
		if (currentMorton != prevMorton)
		{
			// End of previous cell
			BoundaryCellEnd[prevMorton] = idx - 1;
			// Start of current cell
			BoundaryCellStart[currentMorton] = idx;
		}
	}

	// Last particle - this is a cell end
	if (idx == (uint)(BoundaryParticleCount - 1))
	{
		BoundaryCellEnd[currentMorton] = idx;
	}
}
