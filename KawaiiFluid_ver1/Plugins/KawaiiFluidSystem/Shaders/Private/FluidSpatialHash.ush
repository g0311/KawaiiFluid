// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Spatial Hash for accelerated SDF evaluation
// Reduces O(N) per-sample to O(k) where k = avg particles per cell

#pragma once

//=============================================================================
// Spatial Hash Configuration
//=============================================================================

// Hash table size (must be power of 2 for fast modulo)
#ifndef SPATIAL_HASH_SIZE
#define SPATIAL_HASH_SIZE 65536  // 2^16 = 64K cells
#endif

// Search radius multiplier (how many cells to search)
// CellSize >= InfluenceRadius 이면 1로 충분 (내 셀 + 인접 셀만 검색)
// (2*1+1)³ = 27 셀 vs (2*8+1)³ = 4913 셀 → 180배 성능 향상
#ifndef SPATIAL_HASH_SEARCH_RADIUS
#define SPATIAL_HASH_SEARCH_RADIUS 1
#endif

//=============================================================================
// Spatial Hash Data Structures (Multi-pass version)
//=============================================================================
//
// 버퍼 구조:
//   CellCounts[HASH_SIZE]       : 셀별 파티클 개수
//   CellStartIndices[HASH_SIZE] : 셀별 시작 인덱스 (Prefix Sum 결과)
//   ParticleIndices[N]          : 셀 순서로 정렬된 파티클 ID
//
// 사용 예:
//   셀 H의 파티클 순회:
//     uint Start = CellStartIndices[H];
//     uint Count = CellCounts[H];
//     for (uint i = 0; i < Count; i++) {
//         uint ParticleIdx = ParticleIndices[Start + i];
//         ...
//     }

//=============================================================================
// Hash Functions
//=============================================================================

// Convert world position to cell coordinate
int3 WorldToCell(float3 WorldPos, float CellSize)
{
    return int3(floor(WorldPos / CellSize));
}

// Hash function for 3D cell coordinate
// Uses prime multiplication for better distribution
uint HashCell(int3 CellCoord)
{
    // Large primes for hash mixing
    const uint p1 = 73856093u;
    const uint p2 = 19349663u;
    const uint p3 = 83492791u;

    uint h = (uint(CellCoord.x) * p1) ^ (uint(CellCoord.y) * p2) ^ (uint(CellCoord.z) * p3);
    return h & (SPATIAL_HASH_SIZE - 1);  // Fast modulo for power of 2
}

// Alternative: Morton code (Z-order curve) for better cache locality
uint MortonHash(int3 CellCoord)
{
    // Expand bits for interleaving
    uint x = uint(CellCoord.x) & 0x1FF;  // 9 bits
    uint y = uint(CellCoord.y) & 0x1FF;
    uint z = uint(CellCoord.z) & 0x1FF;

    // Interleave bits
    x = (x | (x << 16)) & 0x030000FF;
    x = (x | (x << 8)) & 0x0300F00F;
    x = (x | (x << 4)) & 0x030C30C3;
    x = (x | (x << 2)) & 0x09249249;

    y = (y | (y << 16)) & 0x030000FF;
    y = (y | (y << 8)) & 0x0300F00F;
    y = (y | (y << 4)) & 0x030C30C3;
    y = (y | (y << 2)) & 0x09249249;

    z = (z | (z << 16)) & 0x030000FF;
    z = (z | (z << 8)) & 0x0300F00F;
    z = (z | (z << 4)) & 0x030C30C3;
    z = (z | (z << 2)) & 0x09249249;

    return (x | (y << 1) | (z << 2)) & (SPATIAL_HASH_SIZE - 1);
}

//=============================================================================
// SDF Evaluation with Spatial Hash
//=============================================================================

// Evaluate metaball SDF using spatial hash for acceleration
// Instead of O(N) all particles, only checks O(k) nearby particles
//
// 버퍼 구조 (멀티패스):
//   CellCounts[Hash]       : 해당 셀의 파티클 개수
//   CellStartIndices[Hash] : 해당 셀의 시작 인덱스 (Prefix Sum 결과)
//   ParticleIndices[N]     : 정렬된 파티클 ID 배열
//   RenderParticles[N]     : FKawaiiRenderParticle (32 bytes) 버퍼
//
// 주의: FKawaiiRenderParticle은 KawaiiRenderParticle.ush에서 정의됨
//       FluidSDFCommon.ush → KawaiiRenderParticle.ush include 체인 사용
float EvaluateMetaballSDFWithHash(
    float3 p,
    StructuredBuffer<FKawaiiRenderParticle> RenderParticles,  // FKawaiiRenderParticle (32 bytes)
    StructuredBuffer<uint> CellCounts,          // 셀별 파티클 개수
    StructuredBuffer<uint> CellStartIndices,    // 셀별 시작 인덱스 (Prefix Sum)
    StructuredBuffer<uint> ParticleIndices,     // 정렬된 파티클 ID
    int ParticleCount,
    float ParticleRadius,
    float Smoothness,
    float CellSize)
{
    if (ParticleCount <= 0)
        return 1e10;

    // CellSize 유효성 검사
    if (CellSize <= 0.0)
        return 1e10;

    // CellSize >= InfluenceRadius 조건에서 CellRadius = 1로 충분
    // 내 셀(0) + 인접 셀(±1) = 27셀만 검색
    int CellRadius = SPATIAL_HASH_SEARCH_RADIUS;  // = 1

    // Get center cell
    int3 CenterCell = WorldToCell(p, CellSize);

    // Initialize SDF to large value
    float sdf = 1e10;
    bool bFoundAny = false;

    // Search neighboring cells
    for (int dz = -CellRadius; dz <= CellRadius; ++dz)
    {
        for (int dy = -CellRadius; dy <= CellRadius; ++dy)
        {
            for (int dx = -CellRadius; dx <= CellRadius; ++dx)
            {
                int3 NeighborCell = CenterCell + int3(dx, dy, dz);
                uint Hash = HashCell(NeighborCell);

                // 셀별 시작 인덱스와 개수 조회
                uint StartIndex = CellStartIndices[Hash];
                uint Count = CellCounts[Hash];

                // Hash collision 시 모든 파티클을 검사할 수 없으므로
                // 검사 파티클 수 제한 (성능 보호)
                uint MaxCheck = min(Count, 256u);

                // Process particles in this cell
                for (uint i = 0; i < MaxCheck; ++i)
                {
                    uint ParticleIdx = ParticleIndices[StartIndex + i];

                    // 인덱스 유효성 검사
                    if (ParticleIdx >= (uint)ParticleCount)
                        continue;

                    // FKawaiiRenderParticle에서 Position 추출
                    float3 ParticlePos = RenderParticles[ParticleIdx].Position;

                    // 파티클까지의 거리 계산
                    float3 diff = p - ParticlePos;
                    float distSq = dot(diff, diff);
                    float d = sqrt(distSq) - ParticleRadius;

                    if (!bFoundAny)
                    {
                        sdf = d;
                        bFoundAny = true;
                    }
                    else
                    {
                        // Smooth minimum (polynomial)
                        float h = max(Smoothness - abs(sdf - d), 0.0) / Smoothness;
                        sdf = min(sdf, d) - h * h * Smoothness * 0.25;
                    }
                }
            }
        }
    }

    return bFoundAny ? sdf : 1e10;
}

//=============================================================================
// Normal Calculation with Spatial Hash
//=============================================================================

float3 CalculateSDFNormal3TapWithHash(
    float3 p,
    float centerSDF,
    StructuredBuffer<FKawaiiRenderParticle> RenderParticles,  // FKawaiiRenderParticle (32 bytes)
    StructuredBuffer<uint> CellCounts,
    StructuredBuffer<uint> CellStartIndices,
    StructuredBuffer<uint> ParticleIndices,
    int ParticleCount,
    float ParticleRadius,
    float Smoothness,
    float CellSize)
{
    const float eps = 0.001;

    float3 n;
    n.x = EvaluateMetaballSDFWithHash(p + float3(eps, 0, 0), RenderParticles, CellCounts, CellStartIndices, ParticleIndices, ParticleCount, ParticleRadius, Smoothness, CellSize) - centerSDF;
    n.y = EvaluateMetaballSDFWithHash(p + float3(0, eps, 0), RenderParticles, CellCounts, CellStartIndices, ParticleIndices, ParticleCount, ParticleRadius, Smoothness, CellSize) - centerSDF;
    n.z = EvaluateMetaballSDFWithHash(p + float3(0, 0, eps), RenderParticles, CellCounts, CellStartIndices, ParticleIndices, ParticleCount, ParticleRadius, Smoothness, CellSize) - centerSDF;

    return normalize(n);
}
