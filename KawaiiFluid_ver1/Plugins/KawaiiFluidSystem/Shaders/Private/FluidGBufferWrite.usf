// Copyright KawaiiFluid Team. All Rights Reserved.

#include "/Engine/Private/Common.ush"
#include "/Engine/Private/DeferredShadingCommon.ush"
#include "FluidCommon.ush"

//-----------------------------------------------------------------------------
// Parameters
//-----------------------------------------------------------------------------

// Input textures (from shared passes)
Texture2D<float> SmoothedDepthTexture;
Texture2D<float4> NormalTexture;
Texture2D<float> ThicknessTexture;
Texture2D<float> FluidSceneDepthTexture;

SamplerState PointClampSampler;
SamplerState BilinearClampSampler;

// Material parameters
float3 FluidBaseColor;
float Metallic;
float Roughness;
float SubsurfaceOpacity;
float AbsorptionCoefficient;

// Background depth threshold
#ifndef BACKGROUND_DEPTH_THRESH
#define BACKGROUND_DEPTH_THRESH 3.0e30f
#endif

//-----------------------------------------------------------------------------
// Vertex Shader
//-----------------------------------------------------------------------------

/**
 * @brief Output structure for vertex-to-pixel data
 */
struct FGBufferVSToPS
{
	float4 Position : SV_POSITION;
	noperspective float2 UV : TEXCOORD0;
};

/**
 * @brief Fullscreen triangle vertex shader
 *
 * @param VertexID System-generated vertex index (0, 1, or 2)
 * @param Output Vertex-to-pixel interpolated data
 */
void MainVS(
	in uint VertexID : SV_VertexID,
	out FGBufferVSToPS Output)
{
	float2 UV = float2((VertexID << 1) & 2, VertexID & 2);
	Output.UV = UV;
	Output.Position = float4(UV * float2(2, -2) + float2(-1, 1), 0.5f, 1.0f);
}

//-----------------------------------------------------------------------------
// Helper Functions
//-----------------------------------------------------------------------------

/**
 * @brief Reconstruct view space position from screen UV and linear depth
 *
 * @param ScreenUV Screen-space UV coordinates [0,1]
 * @param LinearDepth Linear depth in view space
 * @return View space position
 */
float3 ReconstructViewPosition(float2 ScreenUV, float LinearDepth)
{
	float4 ClipPosition = float4(ScreenUV * 2.0 - 1.0, 0.5, 1.0);
	float4 ViewPosition = mul(ClipPosition, View.ClipToView);
	ViewPosition /= ViewPosition.w;
	float3 ViewRay = ViewPosition.xyz / ViewPosition.z;

	// Use negative depth because camera looks down -Z axis in view space
	return ViewRay * (-LinearDepth);
}

/**
 * @brief Apply Beer's Law absorption based on thickness
 *
 * @param BaseColor Base fluid color
 * @param Thickness Accumulated particle thickness
 * @return Absorbed color
 */
float3 ApplyBeerLawAbsorption(float3 BaseColor, float Thickness)
{
	float Absorption = exp(-AbsorptionCoefficient * Thickness);
	return BaseColor * Absorption;
}

//-----------------------------------------------------------------------------
// Output Structure
//-----------------------------------------------------------------------------

/**
 * @brief GBuffer Multiple Render Targets output
 */
struct FGBufferOutput
{
	float4 GBufferA : SV_Target0;  // World Normal (RGB), PerObjectGBufferData (A)
	float4 GBufferB : SV_Target1;  // Metallic, Specular, Roughness, ShadingModelID
	float4 GBufferC : SV_Target2;  // BaseColor (RGB), AO (A)
	float4 GBufferD : SV_Target3;  // Custom data (Subsurface, etc)
	float  OutDepth : SV_Depth;
};

//-----------------------------------------------------------------------------
// Main Pixel Shader
//-----------------------------------------------------------------------------

/**
 * @brief Writes fluid surface to GBuffer
 *
 * @param Input Vertex-to-pixel interpolated data
 * @return GBuffer data (MRT output)
 */
FGBufferOutput MainPS(FGBufferVSToPS Input)
{
	FGBufferOutput Output = (FGBufferOutput)0;

	float2 UV = Input.UV;

	float FluidDepth = SmoothedDepthTexture.SampleLevel(PointClampSampler, UV, 0);

	if (FluidDepth > BACKGROUND_DEPTH_THRESH)
	{
		discard;
	}

	// Occlusion test with bias to prevent false culling
	float SceneDeviceZ = FluidSceneDepthTexture.SampleLevel(PointClampSampler, UV, 0);
	float SceneLinearDepth = ConvertFromDeviceZ(SceneDeviceZ);

	if (FluidDepth > SceneLinearDepth + 2.0f)
	{
		discard;
	}

	// Convert linear depth to device Z for depth buffer write
	float3 FluidViewPos = ReconstructViewPosition(UV, FluidDepth);
	float4 FluidClipPos = mul(float4(FluidViewPos, 1.0), View.ViewToClip);
	float FluidDeviceZ = FluidClipPos.z / FluidClipPos.w;

	float3 ViewSpaceNormal = NormalTexture.SampleLevel(BilinearClampSampler, UV, 0).xyz;

	// Normal validation with proper NaN/Inf check
	bool bInvalidNormal = any(isnan(ViewSpaceNormal)) || any(isinf(ViewSpaceNormal)) || length(ViewSpaceNormal) < 0.1f;
	if (bInvalidNormal)
	{
		// Default to camera-facing normal (View space: surface facing camera = +Z)
		// Camera looks down -Z, so surface normal pointing at camera is +Z
		ViewSpaceNormal = float3(0, 0, 1);
	}
	else
	{
		ViewSpaceNormal = normalize(ViewSpaceNormal);
	}

	float3 WorldNormal = mul((float3x3)View.ViewToTranslatedWorld, ViewSpaceNormal);
	WorldNormal = normalize(WorldNormal);

	// Final safety check for WorldNormal
	if (any(isnan(WorldNormal)) || any(isinf(WorldNormal)))
	{
		WorldNormal = float3(0, 0, 1);
	}

	float Thickness = ThicknessTexture.SampleLevel(BilinearClampSampler, UV, 0);
	float3 AbsorbedColor = ApplyBeerLawAbsorption(FluidBaseColor, Thickness);

	// Encode to GBuffer
	Output.GBufferA = float4(WorldNormal * 0.5f + 0.5f, 0.0f);

	uint ShadingModelID = SHADINGMODELID_DEFAULT_LIT;
	Output.GBufferB = float4(Metallic, 0.5f, Roughness, float(ShadingModelID) / 255.0f);

	Output.GBufferC = float4(AbsorbedColor, 1.0f);
	Output.GBufferD = float4(0.0f, 0.0f, 0.0f, 0.0f);

	Output.OutDepth = FluidDeviceZ;

	return Output;
}
