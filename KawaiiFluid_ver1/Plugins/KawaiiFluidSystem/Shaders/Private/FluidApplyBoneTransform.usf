// Copyright 2026 Team_Bruteforce. All Rights Reserved.
// GPU Fluid Physics - Apply Boundary Attachment Pass
//
// Runs at SIMULATION START: Moves attached particles to follow bone transforms
// DIRECTLY applies bone transforms to local positions - same as BoundarySkinningCS
// This eliminates 1-frame delay by using the SAME bone transform buffer.
//
// Legacy approach: Use WorldBoundaryParticles[idx].Position (pre-computed)
// New approach: Apply BoneTransforms[BoneIndex] * LocalPosition directly
//
// Both BoundarySkinningCS and this pass now use the IDENTICAL bone transform data,
// guaranteeing perfect synchronization with skeletal mesh rendering.

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"
#include "FluidBoneDeltaAttachment.ush"

//=============================================================================
// Local Boundary Particle Structure (must match C++ FGPUBoundaryParticleLocal)
//=============================================================================

struct FGPUBoundaryParticleLocal
{
	float3 LocalPosition;   // 12 bytes - Bone-local position
	float Psi;              // 4 bytes  - Volume contribution
	float3 LocalNormal;     // 12 bytes - Bone-local surface normal
	float FrictionCoeff;    // 4 bytes  - Coulomb friction coefficient
	int BoneIndex;          // 4 bytes  - Skeleton bone index (-1 for static mesh)
	float3 Padding;         // 12 bytes - Alignment padding (total: 48 bytes)
};

//=============================================================================
// Shader Parameters
//=============================================================================

// Particles buffer (read/write)
RWStructuredBuffer<FGPUFluidParticle> Particles;
int ParticleCount;

// Bone Delta Attachment buffer (read only for this pass)
StructuredBuffer<FGPUBoneDeltaAttachment> BoneDeltaAttachments;

// Local boundary particles (persistent, same data used by BoundarySkinningCS)
StructuredBuffer<FGPUBoundaryParticleLocal> LocalBoundaryParticles;
int BoundaryParticleCount;

// Bone transforms (SAME buffer as BoundarySkinningCS - this is the key!)
StructuredBuffer<float4x4> BoneTransforms;
int BoneCount;

// Fallback transform for static meshes (BoneIndex == -1)
float4x4 ComponentTransform;

// Time parameter for velocity calculation
float DeltaTime;

//=============================================================================
// Main Compute Shader
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ApplyBoneTransformCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)ParticleCount)
	{
		return;
	}

	// Read particle first to check NEAR_BOUNDARY flag
	FGPUFluidParticle particle = Particles[idx];

	// CRITICAL: Only apply attachment to particles with NEAR_BOUNDARY flag
	// This prevents non-attached (blue) particles from following boundaries
	if (!HasFlag(particle.Flags, GPU_PARTICLE_FLAG_NEAR_BOUNDARY))
	{
		return;
	}

	// Read attachment data
	FGPUBoneDeltaAttachment attachment = BoneDeltaAttachments[idx];

	// Skip if not attached to a boundary particle
	if (attachment.BoundaryParticleIndex < 0 || attachment.BoundaryParticleIndex >= BoundaryParticleCount)
	{
		return;
	}

	// =========================================================================
	// DIRECT BONE TRANSFORM APPLICATION (Legacy-style, no 1-frame delay!)
	// Instead of reading pre-computed WorldBoundaryParticles.Position,
	// we directly apply the bone transform to the local position.
	// This uses the EXACT SAME bone transform buffer as BoundarySkinningCS,
	// guaranteeing perfect synchronization.
	// =========================================================================

	// Get the local boundary particle data
	FGPUBoundaryParticleLocal localParticle = LocalBoundaryParticles[attachment.BoundaryParticleIndex];

	// Select the appropriate transform based on bone index
	float4x4 transform;
	if (localParticle.BoneIndex >= 0 && localParticle.BoneIndex < BoneCount)
	{
		// Skeletal mesh: use bone transform
		transform = BoneTransforms[localParticle.BoneIndex];
	}
	else
	{
		// Static mesh or invalid bone: use component transform
		transform = ComponentTransform;
	}

	// Transform local position to world space (row-major, Unreal convention)
	float4 localPos4 = float4(localParticle.LocalPosition, 1.0f);
	float3 boundaryWorldPos = mul(localPos4, transform).xyz;

	// Apply LocalOffset (stored in attachment)
	// This allows physics to affect the particle while still following the boundary
	float3 localOffset = attachment.LocalOffset;
	float3 targetPos = boundaryWorldPos + localOffset;

	// =========================================================================
	// VELOCITY-ONLY CORRECTION (Based on Bone Delta)
	// Update only velocity using bone movement without position correction
	// PreviousPosition = (Bone Position + LocalOffset) saved from previous frame
	// =========================================================================

	// Use bone position from previous frame (already stored in PreviousPosition)
	// PreviousPosition = (boundaryWorldPos + localOffset) from previous frame
	float3 prevTargetPos = attachment.PreviousPosition;

	// Bone movement velocity = (Current Bone Pos - Previous Bone Pos) / dt
	float3 boneVelocity = float3(0, 0, 0);
	if (DeltaTime > 0.0001f)
	{
		boneVelocity = (targetPos - prevTargetPos) / DeltaTime;
	}

	// Set velocity to bone velocity (No position/PredictedPosition correction)
	particle.Velocity = boneVelocity;

	// Write back
	Particles[idx] = particle;
}
