// Copyright 2026 Team_Bruteforce. All Rights Reserved.
// GPU Fluid Physics - Apply Boundary Attachment Pass
//
// Runs at SIMULATION START: Moves attached particles to follow bone transforms
// DIRECTLY applies bone transforms to local positions - same as BoundarySkinningCS
// This eliminates 1-frame delay by using the SAME bone transform buffer.
//
// Legacy approach: Use WorldBoundaryParticles[idx].Position (pre-computed)
// New approach: Apply BoneTransforms[BoneIndex] * LocalPosition directly
//
// Both BoundarySkinningCS and this pass now use the IDENTICAL bone transform data,
// guaranteeing perfect synchronization with skeletal mesh rendering.

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"
#include "FluidBoneDeltaAttachment.ush"

//=============================================================================
// Local Boundary Particle Structure (must match C++ FGPUBoundaryParticleLocal)
//=============================================================================

struct FGPUBoundaryParticleLocal
{
	float3 LocalPosition;   // 12 bytes - Bone-local position
	float Psi;              // 4 bytes  - Volume contribution
	float3 LocalNormal;     // 12 bytes - Bone-local surface normal
	float FrictionCoeff;    // 4 bytes  - Coulomb friction coefficient
	int BoneIndex;          // 4 bytes  - Skeleton bone index (-1 for static mesh)
	float3 Padding;         // 12 bytes - Alignment padding (total: 48 bytes)
};

//=============================================================================
// Shader Parameters
//=============================================================================

// Particles buffer (read/write)
RWStructuredBuffer<FGPUFluidParticle> Particles;
int ParticleCount;

// Bone Delta Attachment buffer (read only for this pass)
StructuredBuffer<FGPUBoneDeltaAttachment> BoneDeltaAttachments;

// Local boundary particles (persistent, same data used by BoundarySkinningCS)
StructuredBuffer<FGPUBoundaryParticleLocal> LocalBoundaryParticles;
int BoundaryParticleCount;

// Bone transforms (SAME buffer as BoundarySkinningCS - this is the key!)
StructuredBuffer<float4x4> BoneTransforms;
int BoneCount;

// Fallback transform for static meshes (BoneIndex == -1)
float4x4 ComponentTransform;

// Time parameter for velocity calculation
float DeltaTime;

//=============================================================================
// Main Compute Shader
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ApplyBoneTransformCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)ParticleCount)
	{
		return;
	}

	// Read particle first to check NEAR_BOUNDARY flag
	FGPUFluidParticle particle = Particles[idx];

	// CRITICAL: Only apply attachment to particles with NEAR_BOUNDARY flag
	// This prevents non-attached (blue) particles from following boundaries
	if (!HasFlag(particle.Flags, GPU_PARTICLE_FLAG_NEAR_BOUNDARY))
	{
		return;
	}

	// Read attachment data
	FGPUBoneDeltaAttachment attachment = BoneDeltaAttachments[idx];

	// Skip if not attached to a boundary particle
	if (attachment.BoundaryParticleIndex < 0 || attachment.BoundaryParticleIndex >= BoundaryParticleCount)
	{
		return;
	}

	// =========================================================================
	// DIRECT BONE TRANSFORM APPLICATION (Legacy-style, no 1-frame delay!)
	// Instead of reading pre-computed WorldBoundaryParticles.Position,
	// we directly apply the bone transform to the local position.
	// This uses the EXACT SAME bone transform buffer as BoundarySkinningCS,
	// guaranteeing perfect synchronization.
	// =========================================================================

	// Get the local boundary particle data
	FGPUBoundaryParticleLocal localParticle = LocalBoundaryParticles[attachment.BoundaryParticleIndex];

	// Select the appropriate transform based on bone index
	float4x4 transform;
	if (localParticle.BoneIndex >= 0 && localParticle.BoneIndex < BoneCount)
	{
		// Skeletal mesh: use bone transform
		transform = BoneTransforms[localParticle.BoneIndex];
	}
	else
	{
		// Static mesh or invalid bone: use component transform
		transform = ComponentTransform;
	}

	// Transform local position to world space (row-major, Unreal convention)
	float4 localPos4 = float4(localParticle.LocalPosition, 1.0f);
	float3 boundaryWorldPos = mul(localPos4, transform).xyz;

	// Apply LocalOffset (stored in Reserved field)
	// This allows physics to affect the particle while still following the boundary
	float3 localOffset = attachment.Reserved;
	float3 targetPos = boundaryWorldPos + localOffset;

	// =========================================================================
	// VELOCITY-ONLY CORRECTION (위치 텔레포트 없음!)
	// 위치를 직접 바꾸지 않고, bone이 이동한 만큼의 속도만 설정
	// 물리 시뮬레이션이 position += velocity * dt로 자연스럽게 이동시킴
	// 이렇게 하면 순간이동으로 인한 밀도 급증/압력 폭발 방지
	// =========================================================================

	if (DeltaTime > 0.0001f)
	{
		// 현재 위치에서 목표 위치까지의 변위
		float3 displacement = targetPos - particle.Position;

		// 한 프레임에 이 거리를 이동하기 위한 속도
		// velocity = displacement / dt → position += velocity * dt = displacement
		particle.Velocity = displacement / DeltaTime;
	}

	// 위치는 건드리지 않음! 물리가 알아서 이동시킴
	// particle.Position = 변경 안함
	// particle.PredictedPosition = 변경 안함

	// Write back
	Particles[idx] = particle;
}
