// Copyright KawaiiFluid Team. All Rights Reserved.

#pragma once

// Common utility functions

/**
 * Sphere-Ray Intersection
 * Calculate depth at intersection point between spherical particle and ray
 *
 * @param SphereCenter Sphere center position (View Space)
 * @param SphereRadius Sphere radius
 * @param RayOrigin Ray start point (camera position)
 * @param RayDirection Normalized ray direction
 * @return Distance to intersection point (-1 on failure)
 */
float CalculateSphereDepth(float3 SphereCenter, float SphereRadius, float3 RayOrigin, float3 RayDirection)
{
	// Vector from ray origin to sphere center
	float3 VectorToSphere = SphereCenter - RayOrigin;

	// Project sphere center onto ray to find closest approach distance
	float TimeToClosestApproach = dot(VectorToSphere, RayDirection);

	// No intersection if ray points away from sphere
	if (TimeToClosestApproach < 0.0)
	{
		return -1.0;
	}

	// Calculate squared distance from closest approach point to sphere center
	// Using Pythagorean theorem: d^2 = |V|^2 - t^2
	float DistanceSquared = dot(VectorToSphere, VectorToSphere) - TimeToClosestApproach * TimeToClosestApproach;
	float RadiusSquared = SphereRadius * SphereRadius;

	// Ray misses the sphere
	if (DistanceSquared > RadiusSquared)
	{
		return -1.0;
	}

	// Half-length of the intersection chord
	float HalfChordLength = sqrt(RadiusSquared - DistanceSquared);

	// Distance to front intersection (back intersection = TimeToClosestApproach + HalfChordLength)
	float IntersectionDistance = TimeToClosestApproach - HalfChordLength;

	return IntersectionDistance;
}

/**
 * Calculate View Ray Direction from Screen UV
 *
 * @param ScreenUV Screen UV coordinates (0~1)
 * @param InverseProjectionMatrix Inverse projection matrix
 * @return Normalized View Space ray direction
 */
float3 CalculateViewRayDirection(float2 ScreenUV, float4x4 InverseProjectionMatrix)
{
	// Convert Screen UV (0~1) to NDC coordinates (-1~1)
	float2 NormalizedDeviceCoords = ScreenUV * 2.0 - 1.0;

	// Transform NDC to View Space
	float4 ViewSpacePosition = mul(float4(NormalizedDeviceCoords, 1.0, 1.0), InverseProjectionMatrix);

	// Perspective divide (homogeneous coordinate normalization)
	ViewSpacePosition.xyz /= ViewSpacePosition.w;

	// Return normalized direction vector
	return normalize(ViewSpacePosition.xyz);
}

/**
 * Reconstruct View Space Position from Screen UV and Linear Depth
 *
 * UE5 coordinate conventions:
 * - Screen UV: (0,0) = top-left, (1,1) = bottom-right
 * - Clip Space: (-1,-1) = bottom-left, (1,1) = top-right (Y is flipped from UV)
 * - View Space: Z < 0 = in front of camera
 *
 * @param ScreenUV Screen UV coordinates (0~1)
 * @param LinearDepth Linear depth (positive, distance from camera)
 * @param InverseProjectionMatrix Inverse projection matrix
 * @return View Space position (Z < 0)
 */
float3 ReconstructViewPositionFromDepth(float2 ScreenUV, float LinearDepth, float4x4 InverseProjectionMatrix)
{
	// Convert UV to Clip Space (Y-axis flip applied)
	// UV (0,0) top-left -> Clip (-1, 1) top-left
	float2 ClipXY = float2(ScreenUV.x * 2.0 - 1.0, 1.0 - ScreenUV.y * 2.0);
	float4 ClipPosition = float4(ClipXY, 0.5, 1.0);

	// Clip Space -> View Space
	float4 ViewPosition = mul(ClipPosition, InverseProjectionMatrix);
	ViewPosition /= ViewPosition.w;

	// Calculate View Ray direction (normalized to Z = 1)
	// Use abs() to ensure sign consistency
	float3 ViewRay = ViewPosition.xyz / abs(ViewPosition.z);

	// Apply Linear Depth to calculate final position
	// In View Space, Z < 0 is in front of camera
	// UE5's InverseProjectionMatrix outputs Z+ as forward, so X,Y must also be negated
	float Depth = abs(LinearDepth);
	return float3(-ViewRay.x, -ViewRay.y, -1.0) * Depth;
}

/**
 * Project View Space Position to Screen UV
 *
 * @param ViewPos View Space position
 * @param ProjectionMatrix Projection matrix
 * @return Screen UV coordinates (0~1)
 */
float2 ProjectViewPositionToScreenUV(float3 ViewPos, float4x4 ProjectionMatrix)
{
	float4 ClipPos = mul(float4(ViewPos, 1.0), ProjectionMatrix);
	ClipPos.xy /= ClipPos.w;

	// Clip Space -> UV (Y-axis flip applied)
	return float2(ClipPos.x * 0.5 + 0.5, -ClipPos.y * 0.5 + 0.5);
}
