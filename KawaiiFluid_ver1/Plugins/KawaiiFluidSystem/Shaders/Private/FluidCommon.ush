// Copyright 2026 Team_Bruteforce. All Rights Reserved.

#pragma once

// Common utility functions

/**
 * Sphere-Ray Intersection
 * Calculate depth at intersection point between spherical particle and ray
 *
 * @param SphereCenter Sphere center position (View Space)
 * @param SphereRadius Sphere radius
 * @param RayOrigin Ray start point (camera position)
 * @param RayDirection Normalized ray direction
 * @return Distance to intersection point (-1 on failure)
 */
float CalculateSphereDepth(float3 SphereCenter, float SphereRadius, float3 RayOrigin, float3 RayDirection)
{
	// Vector from ray origin to sphere center
	float3 VectorToSphere = SphereCenter - RayOrigin;

	// Project sphere center onto ray to find closest approach distance
	float TimeToClosestApproach = dot(VectorToSphere, RayDirection);

	// No intersection if ray points away from sphere
	if (TimeToClosestApproach < 0.0)
	{
		return -1.0;
	}

	// Calculate squared distance from closest approach point to sphere center
	// Using Pythagorean theorem: d^2 = |V|^2 - t^2
	float DistanceSquared = dot(VectorToSphere, VectorToSphere) - TimeToClosestApproach * TimeToClosestApproach;
	float RadiusSquared = SphereRadius * SphereRadius;

	// Ray misses the sphere
	if (DistanceSquared > RadiusSquared)
	{
		return -1.0;
	}

	// Half-length of the intersection chord
	float HalfChordLength = sqrt(RadiusSquared - DistanceSquared);

	// Distance to front intersection (back intersection = TimeToClosestApproach + HalfChordLength)
	float IntersectionDistance = TimeToClosestApproach - HalfChordLength;

	return IntersectionDistance;
}

/**
 * Calculate View Ray Direction from Screen UV
 *
 * @param ScreenUV Screen UV coordinates (0~1)
 * @param InverseProjectionMatrix Inverse projection matrix
 * @return Normalized View Space ray direction
 */
float3 CalculateViewRayDirection(float2 ScreenUV, float4x4 InverseProjectionMatrix)
{
	// Convert Screen UV (0~1) to NDC coordinates (-1~1)
	float2 NormalizedDeviceCoords = ScreenUV * 2.0 - 1.0;

	// Transform NDC to View Space
	float4 ViewSpacePosition = mul(float4(NormalizedDeviceCoords, 1.0, 1.0), InverseProjectionMatrix);

	// Perspective divide (homogeneous coordinate normalization)
	ViewSpacePosition.xyz /= ViewSpacePosition.w;

	// Return normalized direction vector
	return normalize(ViewSpacePosition.xyz);
}

/**
 * Reconstruct View Space Position from Screen UV and Linear Depth
 *
 * UE5 coordinate conventions:
 * - Screen UV: (0,0) = top-left, (1,1) = bottom-right
 * - Clip Space: (-1,-1) = bottom-left, (1,1) = top-right (Y is flipped from UV)
 * - View Space: X = right, Y = up, Z = backward (camera looks toward -Z)
 *   Objects in front of camera have Z < 0
 *
 * @param ScreenUV Screen UV coordinates (0~1)
 * @param LinearDepth Linear depth (positive, distance from camera)
 * @param InverseProjectionMatrix Inverse projection matrix
 * @return View Space position (Z < 0 for visible objects)
 */
float3 ReconstructViewPositionFromDepth(float2 ScreenUV, float LinearDepth, float4x4 InverseProjectionMatrix)
{
	// Step 1: UV -> Clip Space (with Y-axis flip)
	// UV (0,0) top-left  -> Clip (-1, +1)
	// UV (1,1) bot-right -> Clip (+1, -1)
	float2 ClipXY = float2(ScreenUV.x * 2.0 - 1.0, 1.0 - ScreenUV.y * 2.0);

	// Z = 0.5 is arbitrary - we only need the ray DIRECTION, not a specific depth.
	// Any Z value yields the same ray direction after normalization.
	float4 ClipPosition = float4(ClipXY, 0.5, 1.0);

	// Step 2: Clip Space -> View Space (via InverseProjectionMatrix)
	float4 ViewPosition = mul(ClipPosition, InverseProjectionMatrix);
	ViewPosition /= ViewPosition.w;

	// Step 3: Normalize ray direction (scale so |Z| = 1)
	// This gives us a unit ray in the Z direction that we can scale by LinearDepth.
	float3 ViewRay = ViewPosition.xyz / abs(ViewPosition.z);

	// Step 4: Scale ray by LinearDepth and flip to UE5 View Space convention
	// UE5's InverseProjectionMatrix outputs Z+ as forward, but UE5 View Space
	// convention is Z- as forward. We negate all components to convert.
	// Result: Z = -Depth (always negative, in front of camera)
	float Depth = abs(LinearDepth);
	return float3(-ViewRay.x, -ViewRay.y, -1.0) * Depth;
}

/**
 * Project View Space Position to Screen UV
 *
 * @param ViewPos View Space position
 * @param ProjectionMatrix Projection matrix
 * @return Screen UV coordinates (0~1)
 */
float2 ProjectViewPositionToScreenUV(float3 ViewPos, float4x4 ProjectionMatrix)
{
	float4 ClipPos = mul(float4(ViewPos, 1.0), ProjectionMatrix);
	ClipPos.xy /= ClipPos.w;

	// Clip Space -> UV (Y-axis flip applied)
	return float2(ClipPos.x * 0.5 + 0.5, -ClipPos.y * 0.5 + 0.5);
}
