// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Fluid Physics - Combined Viscosity and Cohesion Pass
//
// Merges ApplyViscosity and ApplyCohesion into a single pass for performance.
// This saves one full neighbor iteration (~35-40% faster than separate passes).
//
// Components:
// 1. XSPH Viscosity: Velocity smoothing between particles
// 2. Laplacian Viscosity: Physical drag force
// 3. Cohesion: Surface tension (particle attraction)
// 4. Boundary Viscosity: Fluid following moving boundaries

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"
#include "FluidSpatialHash.ush"
#include "FluidMortonUtils.ush"

//=============================================================================
// Shader Parameters
//=============================================================================

RWStructuredBuffer<FGPUFluidParticle> Particles;
StructuredBuffer<uint> CellCounts;
StructuredBuffer<uint> ParticleIndices;

// Neighbor caching buffers (reused from DensityPressure pass)
StructuredBuffer<uint> NeighborList;
StructuredBuffer<uint> NeighborCounts;

int ParticleCount;
float SmoothingRadius;
float CellSize;
float DeltaTime;
int bUseNeighborCache;

// Viscosity parameters
float ViscosityCoefficient;
float Poly6Coeff;
float ViscLaplacianCoeff;  // 45 / (PI * h^6)

// Cohesion parameters (Akinci 2013 surface tension, without curvature)
float CohesionStrength;
float RestDensity;
float MaxSurfaceTensionForce;

// Viscosity tuning constants
#define LAPLACIAN_VISCOSITY_SCALE 0.0001f
#define VELOCITY_DRAG_SCALE 5.0f

//=============================================================================
// Boundary Particles
//=============================================================================
struct FGPUBoundaryParticle
{
	float3 Position;      // 12 bytes - World position
	float Psi;            // 4 bytes  - Boundary particle "mass" (total: 16)
	float3 Normal;        // 12 bytes - Surface normal
	int OwnerID;          // 4 bytes  - Owner component ID (total: 32)
	float3 Velocity;      // 12 bytes - World velocity
	float FrictionCoeff;  // 4 bytes  - Coulomb friction coefficient (total: 48)
};

StructuredBuffer<FGPUBoundaryParticle> BoundaryParticles;
int BoundaryParticleCount;
int bUseBoundaryViscosity;
float AdhesionStrength;
float AdhesionRadius;

// Z-Order sorted boundary particles
StructuredBuffer<FGPUBoundaryParticle> SortedBoundaryParticles;
StructuredBuffer<uint> BoundaryCellStart;
StructuredBuffer<uint> BoundaryCellEnd;
int bUseBoundaryZOrder;
float3 MortonBoundsMin;

// Boundary velocity transfer
float BoundaryVelocityTransferStrength;
float BoundaryDetachSpeedThreshold;
float BoundaryMaxDetachSpeed;

//=============================================================================
// Z-Order Cell ID Calculation
//=============================================================================
uint GetMortonCellIDFromCellCoord(int3 cellCoord)
{
	int3 gridMin = int3(floor(MortonBoundsMin / CellSize));
	int3 offset = cellCoord - gridMin;
	uint3 uoffset = uint3(max(offset, int3(0, 0, 0)));
	uoffset = min(uoffset, uint3(MORTON_MAX_VALUE, MORTON_MAX_VALUE, MORTON_MAX_VALUE));
	return Morton3D(uoffset.x, uoffset.y, uoffset.z);
}

//=============================================================================
// Main Compute Shader
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ApplyViscosityAndCohesionCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)ParticleCount)
	{
		return;
	}

	FGPUFluidParticle particle = Particles[idx];

	// Skip CPU-attached particles only (they follow bone position directly)
	// Boundary-attached particles still receive physics - they just follow character movement
	if (HasFlag(particle.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED))
	{
		return;
	}

	// Skip if both viscosity and cohesion are disabled
	bool doViscosity = (ViscosityCoefficient > 0.0f);
	bool doCohesion = (CohesionStrength > 0.0f);
	if (!doViscosity && !doCohesion)
	{
		return;
	}

	float3 pos = particle.PredictedPosition;
	float3 vel = particle.Velocity;
	float rho_i = particle.Density;
	float m_i = particle.Mass;

	// Convert smoothing radius to meters for kernel calculations
	float h_m = SmoothingRadius * CM_TO_M;
	float h2 = h_m * h_m;
	float smoothingRadiusSq_cm = SmoothingRadius * SmoothingRadius;

	// Viscosity accumulators
	float3 velocityCorrection = float3(0.0f, 0.0f, 0.0f);
	float weightSum = 0.0f;
	float3 laplacianForce = float3(0.0f, 0.0f, 0.0f);

	// Cohesion accumulator
	float3 cohesionForce = float3(0.0f, 0.0f, 0.0f);

	//=========================================================================
	// Single neighbor loop: Viscosity + Cohesion combined
	//=========================================================================
	if (bUseNeighborCache)
	{
		uint cachedCount = NeighborCounts[idx];
		uint baseIdx = idx * MAX_NEIGHBORS_PER_PARTICLE;

		for (uint n = 0; n < cachedCount; ++n)
		{
			uint neighborIdx = NeighborList[baseIdx + n];

			if (neighborIdx == idx)
			{
				continue;
			}

			FGPUFluidParticle neighbor = Particles[neighborIdx];

			// Skip CPU-attached neighbors only
			if (HasFlag(neighbor.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED))
			{
				continue;
			}

			float3 r_cm = pos - neighbor.PredictedPosition;
			float r2_cm = dot(r_cm, r_cm);

			if (r2_cm < SMALL_NUMBER || r2_cm > smoothingRadiusSq_cm)
			{
				continue;
			}

			float rLenInv_cm = rsqrt(r2_cm);
			float dist_cm = r2_cm * rLenInv_cm;
			float dist_m = dist_cm * CM_TO_M;
			float r2_m = dist_m * dist_m;

			//=================================================================
			// Viscosity calculation
			//=================================================================
			if (doViscosity && r2_m < h2)
			{
				float w = Poly6Kernel(r2_m, h2) * Poly6Coeff;
				float3 velDiff = neighbor.Velocity - vel;
				velocityCorrection += velDiff * w;
				weightSum += w;

				// Laplacian viscosity
				float laplacian = ViscosityLaplacian(dist_m, h_m, ViscLaplacianCoeff);
				float neighborDensity = max(neighbor.Density, 0.001f);
				laplacianForce += velDiff * laplacian * neighbor.Mass / neighborDensity;
			}

			//=================================================================
			// Cohesion calculation (without curvature)
			//=================================================================
			if (doCohesion)
			{
				float m_j = neighbor.Mass;
				float rho_j = neighbor.Density;
				float3 gradDir = r_cm * rLenInv_cm;

				// K_ij correction factor for particle deficiency
				float K_ij = 1.0f;
				if (rho_i > SMALL_NUMBER && rho_j > SMALL_NUMBER)
				{
					K_ij = (2.0f * RestDensity) / (rho_i + rho_j);
					K_ij = clamp(K_ij, 0.5f, 2.0f);
				}

				// Cohesion force (Akinci 2013)
				float cohesionWeight = CohesionKernel(dist_m, h_m);
				if (abs(cohesionWeight) > SMALL_NUMBER * 0.001f)
				{
					float3 direction = -gradDir;
					float forceMag = m_i * m_j * cohesionWeight;
					cohesionForce += K_ij * forceMag * direction;
				}
			}
		}
	}
	else
	{
		//=====================================================================
		// Fallback: Hash-based neighbor search
		//=====================================================================
		int3 centerCell = WorldToCell(pos, CellSize);
		int cellRadius = (int)ceil(SmoothingRadius / CellSize);

		for (int dz = -cellRadius; dz <= cellRadius; ++dz)
		{
			for (int dy = -cellRadius; dy <= cellRadius; ++dy)
			{
				for (int dx = -cellRadius; dx <= cellRadius; ++dx)
				{
					int3 neighborCell = centerCell + int3(dx, dy, dz);
					uint hash = HashCell(neighborCell);
					uint count = min(CellCounts[hash], (uint)MAX_PARTICLES_PER_CELL);
					uint startIdx = hash * MAX_PARTICLES_PER_CELL;

					for (uint i = 0; i < count; ++i)
					{
						uint neighborIdx = ParticleIndices[startIdx + i];
						if (neighborIdx == idx || neighborIdx >= (uint)ParticleCount) continue;

						FGPUFluidParticle neighbor = Particles[neighborIdx];
						if (HasFlag(neighbor.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED)) continue;

						float3 r_cm = pos - neighbor.PredictedPosition;
						float r2_cm = dot(r_cm, r_cm);
						if (r2_cm < SMALL_NUMBER || r2_cm > smoothingRadiusSq_cm) continue;

						float rLenInv_cm = rsqrt(r2_cm);
						float dist_cm = r2_cm * rLenInv_cm;
						float dist_m = dist_cm * CM_TO_M;
						float r2_m = dist_m * dist_m;

						// Viscosity
						if (doViscosity && r2_m < h2)
						{
							float w = Poly6Kernel(r2_m, h2) * Poly6Coeff;
							float3 velDiff = neighbor.Velocity - vel;
							velocityCorrection += velDiff * w;
							weightSum += w;

							float laplacian = ViscosityLaplacian(dist_m, h_m, ViscLaplacianCoeff);
							float neighborDensity = max(neighbor.Density, 0.001f);
							laplacianForce += velDiff * laplacian * neighbor.Mass / neighborDensity;
						}

						// Cohesion
						if (doCohesion)
						{
							float m_j = neighbor.Mass;
							float rho_j = neighbor.Density;
							float3 gradDir = r_cm * rLenInv_cm;

							float K_ij = 1.0f;
							if (rho_i > SMALL_NUMBER && rho_j > SMALL_NUMBER)
							{
								K_ij = (2.0f * RestDensity) / (rho_i + rho_j);
								K_ij = clamp(K_ij, 0.5f, 2.0f);
							}

							float cohesionWeight = CohesionKernel(dist_m, h_m);
							if (abs(cohesionWeight) > SMALL_NUMBER * 0.001f)
							{
								float3 direction = -gradDir;
								float forceMag = m_i * m_j * cohesionWeight;
								cohesionForce += K_ij * forceMag * direction;
							}
						}
					}
				}
			}
		}
	}

	//=========================================================================
	// Boundary Viscosity (fluid following moving boundaries)
	//=========================================================================
	if (bUseBoundaryViscosity && BoundaryParticleCount > 0 && AdhesionStrength > 0.0f && AdhesionRadius > 0.0f)
	{
		float clampedAdhesion = saturate(AdhesionStrength);
		float adhesionRadius_m = AdhesionRadius * CM_TO_M;
		float adhesionRadius2 = adhesionRadius_m * adhesionRadius_m;

		if (bUseBoundaryZOrder)
		{
			int3 centerCell = WorldToCell(pos, CellSize);
			int cellRadius = (int)ceil(AdhesionRadius / CellSize);

			for (int dz = -cellRadius; dz <= cellRadius; ++dz)
			{
				for (int dy = -cellRadius; dy <= cellRadius; ++dy)
				{
					for (int dx = -cellRadius; dx <= cellRadius; ++dx)
					{
						int3 neighborCell = centerCell + int3(dx, dy, dz);
						uint cellID = GetMortonCellIDFromCellCoord(neighborCell);
						uint bCellStart = BoundaryCellStart[cellID];
						uint bCellEnd = BoundaryCellEnd[cellID];

						if (bCellStart == INVALID_INDEX || bCellEnd == INVALID_INDEX)
							continue;

						for (uint bi = bCellStart; bi <= bCellEnd; ++bi)
						{
							FGPUBoundaryParticle boundary = SortedBoundaryParticles[bi];
							float3 r_cm = pos - boundary.Position;
							float r2_cm = dot(r_cm, r_cm);
							float r2 = r2_cm * CM_TO_M_SQ;

							if (r2 < adhesionRadius2 && r2 > SMALL_NUMBER)
							{
								float w = Poly6Kernel(r2, adhesionRadius2) * Poly6Coeff;

								float3 relativeVelocity = vel - boundary.Velocity;
								float relativeSpeed = length(relativeVelocity);

								float detachFactor = smoothstep(BoundaryDetachSpeedThreshold, BoundaryMaxDetachSpeed, relativeSpeed);
								float transferFactor = (1.0f - detachFactor) * BoundaryVelocityTransferStrength;

								float3 velDiff = boundary.Velocity - vel;
								velocityCorrection += velDiff * w * boundary.Psi * clampedAdhesion * transferFactor;
								weightSum += w * boundary.Psi * clampedAdhesion * transferFactor;
							}
						}
					}
				}
			}
		}
		else
		{
			for (int bi = 0; bi < BoundaryParticleCount; ++bi)
			{
				FGPUBoundaryParticle boundary = BoundaryParticles[bi];
				float3 r_cm = pos - boundary.Position;
				float r2_cm = dot(r_cm, r_cm);
				float r2 = r2_cm * CM_TO_M_SQ;

				if (r2 < adhesionRadius2 && r2 > SMALL_NUMBER)
				{
					float w = Poly6Kernel(r2, adhesionRadius2) * Poly6Coeff;

					float3 relativeVelocity = vel - boundary.Velocity;
					float relativeSpeed = length(relativeVelocity);

					float detachFactor = smoothstep(BoundaryDetachSpeedThreshold, BoundaryMaxDetachSpeed, relativeSpeed);
					float transferFactor = (1.0f - detachFactor) * BoundaryVelocityTransferStrength;

					float3 velDiff = boundary.Velocity - vel;
					velocityCorrection += velDiff * w * boundary.Psi * clampedAdhesion * transferFactor;
					weightSum += w * boundary.Psi * clampedAdhesion * transferFactor;
				}
			}
		}
	}

	//=========================================================================
	// Apply Viscosity
	//=========================================================================
	if (doViscosity)
	{
		// XSPH velocity smoothing
		if (weightSum > SMALL_NUMBER)
		{
			velocityCorrection /= weightSum;
			particle.Velocity += ViscosityCoefficient * velocityCorrection;
		}

		// Laplacian viscosity (drag force)
		float mu = ViscosityCoefficient * ViscosityCoefficient * LAPLACIAN_VISCOSITY_SCALE;
		if (mu > SMALL_NUMBER)
		{
			particle.Velocity += mu * laplacianForce * DeltaTime;
		}

		// Velocity drag (air resistance)
		float dragCoeff = ViscosityCoefficient * ViscosityCoefficient * VELOCITY_DRAG_SCALE;
		if (dragCoeff > SMALL_NUMBER)
		{
			float damping = 1.0f - dragCoeff * DeltaTime;
			damping = max(damping, 0.0f);
			particle.Velocity *= damping;
		}
	}

	//=========================================================================
	// Apply Cohesion
	//=========================================================================
	if (doCohesion)
	{
		float3 totalForce = CohesionStrength * cohesionForce;
		float3 acceleration = totalForce / max(m_i, SMALL_NUMBER);

		// Clamp for stability
		if (MaxSurfaceTensionForce > 0.0f)
		{
			float maxAccel = MaxSurfaceTensionForce / max(m_i, SMALL_NUMBER);
			float accelMag = length(acceleration);
			if (accelMag > maxAccel && accelMag > SMALL_NUMBER)
			{
				acceleration = acceleration * (maxAccel / accelMag);
			}
		}

		#define M_TO_CM 100.0f
		particle.Velocity += acceleration * DeltaTime * M_TO_CM;
	}

	Particles[idx] = particle;
}
