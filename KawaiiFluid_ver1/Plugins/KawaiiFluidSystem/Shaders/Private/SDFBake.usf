// Copyright KawaiiFluid Team. All Rights Reserved.
// SDF Volume Bake Compute Shader
// Bakes metaball SDF into a 3D texture for optimized ray marching

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"

//=============================================================================
// Render Particle Structure (must match FKawaiiRenderParticle - 32 bytes)
//=============================================================================

struct FRenderParticle
{
	float3 Position;   // 12 bytes
	float3 Velocity;   // 12 bytes
	float Radius;      // 4 bytes
	float Padding;     // 4 bytes
};

//=============================================================================
// Shader Parameters
//=============================================================================

// Particle Data (Input)
#if USE_SOA_BUFFERS
StructuredBuffer<float3> RenderPositions;  // SoA: 12B per particle (62% bandwidth reduction)
#else
StructuredBuffer<FRenderParticle> RenderParticles;  // AoS: 32B per particle (legacy)
#endif
int ParticleCount;
float ParticleRadius;
float SDFSmoothness;

// Volume Parameters
float3 VolumeMin;           // World-space minimum corner of the volume
float3 VolumeMax;           // World-space maximum corner of the volume
int3 VolumeResolution;      // Resolution of the 3D texture (e.g., 64, 64, 64)

// Output SDF Volume (3D Texture UAV)
RWTexture3D<float> SDFVolume;

//=============================================================================
// SDF Functions (Copied from FluidSDFCommon.ush for compute shader)
//=============================================================================

// Sphere SDF
float sdSphere(float3 p, float3 center, float radius)
{
    return length(p - center) - radius;
}

// Smooth minimum (polynomial smooth min)
float smin(float a, float b, float k)
{
    float h = max(k - abs(a - b), 0.0) / k;
    return min(a, b) - h * h * k * 0.25;
}

//=============================================================================
// Main Compute Shader
//=============================================================================

[numthreads(8, 8, 8)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    // Check bounds
    if (any(DispatchThreadId >= uint3(VolumeResolution)))
        return;

    // Convert voxel coordinates to world position
    // Add 0.5 to sample at voxel center
    float3 uvw = (float3(DispatchThreadId) + 0.5) / float3(VolumeResolution);
    float3 worldPos = lerp(VolumeMin, VolumeMax, uvw);

    // Early out if no particles
    if (ParticleCount <= 0)
    {
        SDFVolume[DispatchThreadId] = 1e10;
        return;
    }

    // Evaluate metaball SDF at this position
#if USE_SOA_BUFFERS
    float sdf = sdSphere(worldPos, RenderPositions[0], ParticleRadius);
    for (int i = 1; i < ParticleCount; ++i)
    {
        float d = sdSphere(worldPos, RenderPositions[i], ParticleRadius);
        sdf = smin(sdf, d, SDFSmoothness);
    }
#else
    float sdf = sdSphere(worldPos, RenderParticles[0].Position, ParticleRadius);
    for (int i = 1; i < ParticleCount; ++i)
    {
        float d = sdSphere(worldPos, RenderParticles[i].Position, ParticleRadius);
        sdf = smin(sdf, d, SDFSmoothness);
    }
#endif

    // Store SDF value in volume texture
    SDFVolume[DispatchThreadId] = sdf;
}
