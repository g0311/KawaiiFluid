// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Fluid Physics - Primitive Collision Pass
// Applies collision with explicit primitives (spheres, capsules, boxes, convexes)

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"
#include "FluidCollisionPrimitives.ush"

//=============================================================================
// Shader Parameters
//=============================================================================

// Particle buffers (SoA - Structure of Arrays)
RWBuffer<float> Positions;
RWBuffer<float> PredictedPositions;
RWBuffer<uint2> PackedVelocities;   // B plan: half3 packed
Buffer<uint> PackedDensityLambda;   // B plan: half2 packed (read-only for feedback)
Buffer<int> SourceIDs;              // Read-only for feedback
RWBuffer<uint> Flags;

int ParticleCount;
float ParticleRadius;

// Collision primitives
StructuredBuffer<FGPUCollisionSphere> CollisionSpheres;
int SphereCount;

StructuredBuffer<FGPUCollisionCapsule> CollisionCapsules;
int CapsuleCount;

StructuredBuffer<FGPUCollisionBox> CollisionBoxes;
int BoxCount;

StructuredBuffer<FGPUCollisionConvex> CollisionConvexes;
int ConvexCount;

StructuredBuffer<FGPUConvexPlane> ConvexPlanes;

StructuredBuffer<FGPUBoneTransform> BoneTransforms;
int BoneCount;

// Collision threshold
float CollisionThreshold;

//=============================================================================
// Unified Collision Feedback Buffer
// All feedback types merged into single buffer with embedded counters
// Layout: [Header:16B][BoneFeedback][SMFeedback][FISMFeedback]
//=============================================================================

// Unified feedback buffer (byte-addressable for header access)
RWByteAddressBuffer UnifiedFeedbackBuffer;

// Enable/disable feedback recording (0 = disabled, 1 = enabled)
int bEnableCollisionFeedback;

// Buffer layout constants (must match C++ GPUCollisionFeedbackManager constants)
// Header: [BoneCount:4][SMCount:4][FISMCount:4][Reserved:4]
#define UNIFIED_HEADER_SIZE 16
#define FEEDBACK_STRUCT_SIZE 96  // sizeof(FGPUCollisionFeedback) = 96 bytes

// Max entries per section
#define MAX_BONE_FEEDBACK 4096
#define MAX_SM_FEEDBACK 1024
#define MAX_FISM_FEEDBACK 1024

// Section offsets (in bytes)
#define BONE_FEEDBACK_OFFSET UNIFIED_HEADER_SIZE
#define SM_FEEDBACK_OFFSET (BONE_FEEDBACK_OFFSET + MAX_BONE_FEEDBACK * FEEDBACK_STRUCT_SIZE)
#define FISM_FEEDBACK_OFFSET (SM_FEEDBACK_OFFSET + MAX_SM_FEEDBACK * FEEDBACK_STRUCT_SIZE)

// Counter offsets in header (in bytes)
#define BONE_COUNTER_OFFSET 0
#define SM_COUNTER_OFFSET 4
#define FISM_COUNTER_OFFSET 8

//=============================================================================
// Collider Contact Count Buffer (for simple collision count)
//=============================================================================

// Number of colliding particles per collider (atomic increment)
RWStructuredBuffer<uint> ColliderContactCounts;

// Maximum collider count
int MaxColliderCount;

//=============================================================================
// Helper Function: Write Feedback Struct to ByteAddressBuffer
//=============================================================================

/**
 * Writes FGPUCollisionFeedback struct to unified buffer at given byte offset
 * FGPUCollisionFeedback layout (96 bytes):
 *   Row 1: ParticleIndex(4) + ColliderIndex(4) + ColliderType(4) + Density(4)
 *   Row 2: ImpactNormal(12) + Penetration(4)
 *   Row 3: ParticleVelocity(12) + ColliderOwnerID(4)
 *   Row 4: ParticleSourceID(4) + ParticleActorID(4) + BoneIndex(4) + Padding1(4)
 *   Row 5: ImpactOffset(12) + Padding2(4)
 *   Row 6: ParticlePosition(12) + Padding3(4)
 */
void WriteFeedbackToBuffer(uint byteOffset, int particleIdx, int colliderIdx, int colliderType,
                           float density, float3 normal, float penetration, float3 velocity,
                           int colliderOwnerID, int particleSourceID, int boneIndex,
                           float3 impactOffset, float3 particlePosition)
{
	// Row 1: ParticleIndex, ColliderIndex, ColliderType, Density
	UnifiedFeedbackBuffer.Store4(byteOffset, uint4(
		asuint(particleIdx),
		asuint(colliderIdx),
		asuint(colliderType),
		asuint(density)
	));

	// Row 2: ImpactNormal.xyz, Penetration
	UnifiedFeedbackBuffer.Store4(byteOffset + 16, uint4(
		asuint(normal.x),
		asuint(normal.y),
		asuint(normal.z),
		asuint(penetration)
	));

	// Row 3: ParticleVelocity.xyz, ColliderOwnerID
	UnifiedFeedbackBuffer.Store4(byteOffset + 32, uint4(
		asuint(velocity.x),
		asuint(velocity.y),
		asuint(velocity.z),
		asuint(colliderOwnerID)
	));

	// Row 4: ParticleSourceID, ParticleActorID(0), BoneIndex, Padding1(0)
	UnifiedFeedbackBuffer.Store4(byteOffset + 48, uint4(
		asuint(particleSourceID),
		0,  // ParticleActorID
		asuint(boneIndex),
		0   // Padding1
	));

	// Row 5: ImpactOffset.xyz, Padding2(0)
	UnifiedFeedbackBuffer.Store4(byteOffset + 64, uint4(
		asuint(impactOffset.x),
		asuint(impactOffset.y),
		asuint(impactOffset.z),
		0   // Padding2
	));

	// Row 6: ParticlePosition.xyz, Padding3(0)
	UnifiedFeedbackBuffer.Store4(byteOffset + 80, uint4(
		asuint(particlePosition.x),
		asuint(particlePosition.y),
		asuint(particlePosition.z),
		0   // Padding3
	));
}

//=============================================================================
// Helper Function: Record Collision Feedback
//=============================================================================

/**
 * Records collision feedback for CPU readback (particle -> player interaction)
 * Uses atomic counter in unified buffer header to safely write to shared buffer
 *
 * Unified Buffer Layout:
 * - Header[0]: BoneCount, Header[4]: SMCount, Header[8]: FISMCount
 * - boneIndex >= 0 -> BoneFeedback section
 * - boneIndex < 0, bHasFluidInteraction = 0 -> SMFeedback section
 * - boneIndex < 0, bHasFluidInteraction = 1 -> FISMFeedback section
 *
 * @param particleIdx - Index of the colliding particle
 * @param colliderIdx - Index of the collider (unique across all types)
 * @param colliderType - Type of collider (0=Sphere, 1=Capsule, 2=Box, 3=Convex)
 * @param density - Particle density at collision time
 * @param normal - Collision surface normal
 * @param penetration - Penetration depth (cm)
 * @param velocity - Particle velocity (for drag force calculation)
 * @param colliderOwnerID - Unique ID of collider owner (for filtering by actor)
 * @param particleSourceID - Particle's SourceID (PresetIndex | ComponentIndex << 16)
 * @param boneIndex - Bone index for per-bone force calculation (-1 = no bone)
 * @param bHasFluidInteraction - 1 if from FluidInteraction component, 0 if from WorldCollision
 * @param impactWorld - Impact position in world space
 * @param particlePosition - Particle world position (for buoyancy center calculation)
 */
void RecordCollisionFeedback(int particleIdx, int colliderIdx, int colliderType,
                             float density, float3 normal, float penetration, float3 velocity,
                             int colliderOwnerID, int particleSourceID, int boneIndex,
                             int bHasFluidInteraction, float3 impactWorld, float3 particlePosition)
{
	// Increment collision count per collider (always executed)
	if (colliderIdx >= 0 && colliderIdx < MaxColliderCount)
	{
		uint dummy;
		InterlockedAdd(ColliderContactCounts[colliderIdx], 1, dummy);
	}

	// Record detailed feedback when enabled
	if (bEnableCollisionFeedback == 0)
	{
		return;
	}

	// Compute impact offset in bone local space
	float3 impactOffset = float3(0, 0, 0);
	if (boneIndex >= 0 && boneIndex < BoneCount)
	{
		impactOffset = WorldToBoneLocal(impactWorld, BoneTransforms[boneIndex]);
	}

	// Route to appropriate section of unified buffer
	uint feedbackIdx;
	uint byteOffset;

	if (boneIndex >= 0)
	{
		// SkeletalMesh bone colliders -> BoneFeedback section
		UnifiedFeedbackBuffer.InterlockedAdd(BONE_COUNTER_OFFSET, 1, feedbackIdx);
		if ((int)feedbackIdx < MAX_BONE_FEEDBACK)
		{
			byteOffset = BONE_FEEDBACK_OFFSET + feedbackIdx * FEEDBACK_STRUCT_SIZE;
			WriteFeedbackToBuffer(byteOffset, particleIdx, colliderIdx, colliderType,
			                      density, normal, penetration, velocity,
			                      colliderOwnerID, particleSourceID, boneIndex,
			                      impactOffset, particlePosition);
		}
	}
	else if (bHasFluidInteraction != 0)
	{
		// FluidInteraction StaticMesh -> FISMFeedback section
		UnifiedFeedbackBuffer.InterlockedAdd(FISM_COUNTER_OFFSET, 1, feedbackIdx);
		if ((int)feedbackIdx < MAX_FISM_FEEDBACK)
		{
			byteOffset = FISM_FEEDBACK_OFFSET + feedbackIdx * FEEDBACK_STRUCT_SIZE;
			WriteFeedbackToBuffer(byteOffset, particleIdx, colliderIdx, colliderType,
			                      density, normal, penetration, velocity,
			                      colliderOwnerID, particleSourceID, boneIndex,
			                      impactOffset, particlePosition);
		}
	}
	else
	{
		// WorldCollision StaticMesh -> SMFeedback section
		UnifiedFeedbackBuffer.InterlockedAdd(SM_COUNTER_OFFSET, 1, feedbackIdx);
		if ((int)feedbackIdx < MAX_SM_FEEDBACK)
		{
			byteOffset = SM_FEEDBACK_OFFSET + feedbackIdx * FEEDBACK_STRUCT_SIZE;
			WriteFeedbackToBuffer(byteOffset, particleIdx, colliderIdx, colliderType,
			                      density, normal, penetration, velocity,
			                      colliderOwnerID, particleSourceID, boneIndex,
			                      impactOffset, particlePosition);
		}
	}
}

//=============================================================================
// Main Compute Shader
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void PrimitiveCollisionCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)ParticleCount)
	{
		return;
	}

	uint idx3 = idx * 3;
	uint flags = Flags[idx];

	// Skip CPU-attached particles only (they follow bone position directly)
	// Boundary-attached particles still need collision detection
	if (HasFlag(flags, GPU_PARTICLE_FLAG_IS_ATTACHED))
	{
		return;
	}

	// Read SoA buffers
	float3 pos = float3(PredictedPositions[idx3], PredictedPositions[idx3 + 1], PredictedPositions[idx3 + 2]);
	float3 originalPos = float3(Positions[idx3], Positions[idx3 + 1], Positions[idx3 + 2]);
	float3 vel = UnpackVelocity(PackedVelocities[idx]);
	float density, lambda;
	UnpackDensityLambda(PackedDensityLambda[idx], density, lambda);
	int sourceID = SourceIDs[idx];
	bool bCollided = false;

	// Check collision with all spheres
	// NOTE: Collision test based on particle center (ParticleRadius not applied)
	for (int si = 0; si < SphereCount; ++si)
	{
		FGPUCollisionSphere sphere = CollisionSpheres[si];
		float sdf = sdSphere(pos, sphere.Center, sphere.Radius);
		float effectiveDist = sdf;  // Center-based

		if (effectiveDist < CollisionThreshold)
		{
			float3 normal = CalcNumericalGradient_Sphere(pos, sphere.Center, sphere.Radius);
			float penetration = max(0.0f, -effectiveDist);
			float3 impactWorld = pos - normal * sdf;

			// Apply collision response
			ApplyCollisionResponseWithFriction(pos, originalPos, vel, normal, penetration, sphere.Friction, sphere.Restitution);
			originalPos = pos;  // Update for subsequent collisions
			bCollided = true;

			// Record feedback for particle -> player interaction (includes velocity for drag calculation)
			RecordCollisionFeedback(idx, si, COLLIDER_TYPE_SPHERE, density, normal, penetration, vel, sphere.OwnerID, sourceID, sphere.BoneIndex, sphere.bHasFluidInteraction, impactWorld, pos);
		}
	}

	// Check collision with all capsules
	// NOTE: Collision test based on particle center (ParticleRadius not applied)
	for (int ci = 0; ci < CapsuleCount; ++ci)
	{
		FGPUCollisionCapsule capsule = CollisionCapsules[ci];
		float sdf = sdCapsule(pos, capsule.Start, capsule.End, capsule.Radius);
		float effectiveDist = sdf;  // Center-based

		if (effectiveDist < CollisionThreshold)
		{
			float3 normal = CalcNumericalGradient_Capsule(pos, capsule.Start, capsule.End, capsule.Radius);
			float penetration = max(0.0f, -effectiveDist);
			float3 impactWorld = pos - normal * sdf;

			// Apply collision response
			ApplyCollisionResponseWithFriction(pos, originalPos, vel, normal, penetration, capsule.Friction, capsule.Restitution);
			originalPos = pos;
			bCollided = true;

			// Record feedback for particle -> player interaction (includes velocity for drag calculation)
			RecordCollisionFeedback(idx, SphereCount + ci, COLLIDER_TYPE_CAPSULE, density, normal, penetration, vel, capsule.OwnerID, sourceID, capsule.BoneIndex, capsule.bHasFluidInteraction, impactWorld, pos);
		}
	}

	// Check collision with all boxes
	// NOTE: Collision test based on particle center (ParticleRadius not applied)
	for (int bi = 0; bi < BoxCount; ++bi)
	{
		FGPUCollisionBox box = CollisionBoxes[bi];
		float sdf = sdBox(pos, box.Center, box.Extent, box.Rotation);
		float effectiveDist = sdf;  // Center-based

		if (effectiveDist < CollisionThreshold)
		{
			float3 normal = CalcNumericalGradient_Box(pos, box.Center, box.Extent, box.Rotation);
			float penetration = max(0.0f, -effectiveDist);
			float3 impactWorld = pos - normal * sdf;

			// Apply collision response
			ApplyCollisionResponseWithFriction(pos, originalPos, vel, normal, penetration, box.Friction, box.Restitution);
			originalPos = pos;

			// Mark as near ground if collision normal is mostly upward
			if (normal.z > 0.5f)
			{
				flags = SetFlag(flags, GPU_PARTICLE_FLAG_NEAR_GROUND);
			}
			bCollided = true;

			// Record feedback for particle -> player interaction (includes velocity for drag calculation)
			RecordCollisionFeedback(idx, SphereCount + CapsuleCount + bi, COLLIDER_TYPE_BOX, density, normal, penetration, vel, box.OwnerID, sourceID, box.BoneIndex, box.bHasFluidInteraction, impactWorld, pos);
		}
	}

	// Check collision with all convex hulls
	for (int cxi = 0; cxi < ConvexCount; ++cxi)
	{
		FGPUCollisionConvex convex = CollisionConvexes[cxi];

		// Early out with bounding sphere (Center-based)
		float boundDist = length(pos - convex.Center) - convex.BoundingRadius;
		if (boundDist > CollisionThreshold)
		{
			continue;
		}

		float sdf = sdConvex(pos, convex.Center, convex.BoundingRadius,
		                     convex.PlaneStartIndex, convex.PlaneCount, ConvexPlanes);
		float effectiveDist = sdf;  // Center-based

		if (effectiveDist < CollisionThreshold)
		{
			// Find the closest plane for normal calculation
			float3 normal = float3(0, 0, 1);
			float maxDist = -1e10f;
			for (int pi = 0; pi < convex.PlaneCount; ++pi)
			{
				FGPUConvexPlane plane = ConvexPlanes[convex.PlaneStartIndex + pi];
				float dist = dot(pos, plane.Normal) - plane.Distance;
				if (dist > maxDist)
				{
					maxDist = dist;
					normal = plane.Normal;
				}
			}

			float penetration = max(0.0f, -effectiveDist);
			float3 impactWorld = pos - normal * sdf;

			// Apply collision response
			ApplyCollisionResponseWithFriction(pos, originalPos, vel, normal, penetration, convex.Friction, convex.Restitution);
			originalPos = pos;

			// Mark as near ground if collision normal is mostly upward
			if (normal.z > 0.5f)
			{
				flags = SetFlag(flags, GPU_PARTICLE_FLAG_NEAR_GROUND);
			}
			bCollided = true;

			// Record feedback for particle -> player interaction (includes velocity for drag calculation)
			RecordCollisionFeedback(idx, SphereCount + CapsuleCount + BoxCount + cxi, COLLIDER_TYPE_CONVEX, density, normal, penetration, vel, convex.OwnerID, sourceID, convex.BoneIndex, convex.bHasFluidInteraction, impactWorld, pos);
		}
	}

	// Clear near ground flag if no collision
	if (!bCollided)
	{
		flags = ClearFlag(flags, GPU_PARTICLE_FLAG_NEAR_GROUND);
	}

	// Write back to SoA buffers
	PredictedPositions[idx3] = pos.x;
	PredictedPositions[idx3 + 1] = pos.y;
	PredictedPositions[idx3 + 2] = pos.z;

	PackedVelocities[idx] = PackVelocity(vel);

	Flags[idx] = flags;
}
