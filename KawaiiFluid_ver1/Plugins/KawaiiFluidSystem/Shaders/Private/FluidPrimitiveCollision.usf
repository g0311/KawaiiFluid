// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Fluid Physics - Primitive Collision Pass
// Applies collision with explicit primitives (spheres, capsules, boxes, convexes)

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"
#include "FluidCollisionPrimitives.ush"

//=============================================================================
// Shader Parameters
//=============================================================================

// Particle buffer
RWStructuredBuffer<FGPUFluidParticle> Particles;
int ParticleCount;
float ParticleRadius;

// Collision primitives
StructuredBuffer<FGPUCollisionSphere> CollisionSpheres;
int SphereCount;

StructuredBuffer<FGPUCollisionCapsule> CollisionCapsules;
int CapsuleCount;

StructuredBuffer<FGPUCollisionBox> CollisionBoxes;
int BoxCount;

StructuredBuffer<FGPUCollisionConvex> CollisionConvexes;
int ConvexCount;

StructuredBuffer<FGPUConvexPlane> ConvexPlanes;

StructuredBuffer<FGPUBoneTransform> BoneTransforms;
int BoneCount;

// Collision threshold
float CollisionThreshold;

//=============================================================================
// Collision Feedback Buffer (for Particle -> Player Interaction)
//=============================================================================

// Feedback buffer for CPU readback
RWStructuredBuffer<FGPUCollisionFeedback> CollisionFeedback;

// Atomic counter for feedback entries
RWStructuredBuffer<uint> CollisionCounter;

// Maximum number of feedback entries (prevents buffer overflow)
int MaxCollisionFeedback;

// Enable/disable feedback recording (0 = disabled, 1 = enabled)
int bEnableCollisionFeedback;

//=============================================================================
// Collider Contact Count Buffer (간단한 충돌 카운트용)
//=============================================================================

// 콜라이더별 충돌 입자 수 (atomic increment)
RWStructuredBuffer<uint> ColliderContactCounts;

// 최대 콜라이더 수
int MaxColliderCount;

//=============================================================================
// Helper Function: Record Collision Feedback
//=============================================================================

/**
 * Records collision feedback for CPU readback (particle -> player interaction)
 * Uses atomic counter to safely write to shared buffer
 *
 * @param particleIdx - Index of the colliding particle
 * @param colliderIdx - Index of the collider (unique across all types)
 * @param colliderType - Type of collider (0=Sphere, 1=Capsule, 2=Box, 3=Convex)
 * @param density - Particle density at collision time
 * @param normal - Collision surface normal
 * @param penetration - Penetration depth (cm)
 * @param velocity - Particle velocity (for drag force calculation)
 * @param colliderOwnerID - Unique ID of collider owner (for filtering by actor)
 * @param particleSourceID - Particle's SourceID (PresetIndex | ComponentIndex << 16)
 * @param boneIndex - Bone index for per-bone force calculation (-1 = no bone)
 * @param impactWorld - Impact position in world space
 */
void RecordCollisionFeedback(int particleIdx, int colliderIdx, int colliderType,
                             float density, float3 normal, float penetration, float3 velocity,
                             int colliderOwnerID, int particleSourceID,  int boneIndex, float3 impactWorld)
{
	// 콜라이더별 충돌 카운트 증가 (항상 실행)
	if (colliderIdx >= 0 && colliderIdx < MaxColliderCount)
	{
		uint dummy;
		InterlockedAdd(ColliderContactCounts[colliderIdx], 1, dummy);
	}

	// 상세 피드백 기록 (본이 있는 콜라이더만 - Per-Bone Force용)
	// BoneIndex < 0 이면 본이 없는 콜라이더 (StaticMeshActor 등)
	if (bEnableCollisionFeedback == 0 || boneIndex < 0)
	{
		return;
	}

	uint feedbackIdx;
	InterlockedAdd(CollisionCounter[0], 1, feedbackIdx);

	if ((int)feedbackIdx < MaxCollisionFeedback)
	{
		FGPUCollisionFeedback feedback;
		feedback.ParticleIndex = particleIdx;
		feedback.ColliderIndex = colliderIdx;
		feedback.ColliderType = colliderType;
		feedback.Density = density;
		feedback.ImpactNormal = normal;
		feedback.Penetration = penetration;
		feedback.ParticleVelocity = velocity;
		feedback.ColliderOwnerID = colliderOwnerID;
		feedback.ParticleSourceID = particleSourceID;
		feedback.ParticleActorID = 0;  // Reserved for future use
		feedback.BoneIndex = boneIndex;
		feedback.Padding1 = 0;
		if (boneIndex >= 0 && boneIndex < BoneCount)
		{
			feedback.ImpactOffset = WorldToBoneLocal(impactWorld, BoneTransforms[boneIndex]);
		}
		else
		{
			feedback.ImpactOffset = float3(0, 0, 0);
		}
		feedback.Padding2 = 0;
		CollisionFeedback[feedbackIdx] = feedback;
	}
}

//=============================================================================
// Main Compute Shader
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void PrimitiveCollisionCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)ParticleCount)
	{
		return;
	}

	FGPUFluidParticle particle = Particles[idx];

	// Skip attached particles (CPU attachment or GPU boundary attachment)
	if (HasFlag(particle.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED) ||
		HasFlag(particle.Flags, GPU_PARTICLE_FLAG_IS_BOUNDARY_ATTACHED))
	{
		return;
	}

	float3 pos = particle.PredictedPosition;
	float3 originalPos = particle.Position;  // Original position for position-level friction
	float3 vel = particle.Velocity;
	bool bCollided = false;

	// Check collision with all spheres
	for (int si = 0; si < SphereCount; ++si)
	{
		FGPUCollisionSphere sphere = CollisionSpheres[si];
		float sdf = sdSphere(pos, sphere.Center, sphere.Radius);
		float effectiveDist = sdf - ParticleRadius;

		if (effectiveDist < CollisionThreshold)
		{
			float3 normal = CalcNumericalGradient_Sphere(pos, sphere.Center, sphere.Radius);
			float penetration = max(0.0f, -effectiveDist);
			float3 impactWorld = pos - normal * sdf;

			// Apply collision response for all colliders (both bone and static)
			ApplyCollisionResponseWithFriction(pos, originalPos, vel, normal, penetration, sphere.Friction, sphere.Restitution);
			originalPos = pos;  // Update for subsequent collisions
			bCollided = true;

			// Record feedback for particle -> player interaction (includes velocity for drag calculation)
			RecordCollisionFeedback(idx, si, COLLIDER_TYPE_SPHERE, particle.Density, normal, penetration, particle.Velocity, sphere.OwnerID, particle.SourceID, sphere.BoneIndex, impactWorld);
		}
	}

	// Check collision with all capsules
	for (int ci = 0; ci < CapsuleCount; ++ci)
	{
		FGPUCollisionCapsule capsule = CollisionCapsules[ci];
		float sdf = sdCapsule(pos, capsule.Start, capsule.End, capsule.Radius);
		float effectiveDist = sdf - ParticleRadius;

		if (effectiveDist < CollisionThreshold)
		{
			float3 normal = CalcNumericalGradient_Capsule(pos, capsule.Start, capsule.End, capsule.Radius);
			float penetration = max(0.0f, -effectiveDist);
			float3 impactWorld = pos - normal * sdf;

			// Apply collision response for all colliders (both bone and static)
			ApplyCollisionResponseWithFriction(pos, originalPos, vel, normal, penetration, capsule.Friction, capsule.Restitution);
			originalPos = pos;
			bCollided = true;

			// Record feedback for particle -> player interaction (includes velocity for drag calculation)
			RecordCollisionFeedback(idx, SphereCount + ci, COLLIDER_TYPE_CAPSULE, particle.Density, normal, penetration, particle.Velocity, capsule.OwnerID, particle.SourceID, capsule.BoneIndex, impactWorld);
		}
	}

	// Check collision with all boxes
	for (int bi = 0; bi < BoxCount; ++bi)
	{
		FGPUCollisionBox box = CollisionBoxes[bi];
		float sdf = sdBox(pos, box.Center, box.Extent, box.Rotation);
		float effectiveDist = sdf - ParticleRadius;

		if (effectiveDist < CollisionThreshold)
		{
			float3 normal = CalcNumericalGradient_Box(pos, box.Center, box.Extent, box.Rotation);
			float penetration = max(0.0f, -effectiveDist);
			float3 impactWorld = pos - normal * sdf;

			// Apply collision response for all colliders (both bone and static)
			ApplyCollisionResponseWithFriction(pos, originalPos, vel, normal, penetration, box.Friction, box.Restitution);
			originalPos = pos;

			// Mark as near ground if collision normal is mostly upward
			if (normal.z > 0.5f)
			{
				particle.Flags = SetFlag(particle.Flags, GPU_PARTICLE_FLAG_NEAR_GROUND);
			}
			bCollided = true;

			// Record feedback for particle -> player interaction (includes velocity for drag calculation)
			RecordCollisionFeedback(idx, SphereCount + CapsuleCount + bi, COLLIDER_TYPE_BOX, particle.Density, normal, penetration, particle.Velocity, box.OwnerID, particle.SourceID, box.BoneIndex, impactWorld);
		}
	}

	// Check collision with all convex hulls
	for (int cxi = 0; cxi < ConvexCount; ++cxi)
	{
		FGPUCollisionConvex convex = CollisionConvexes[cxi];

		// Early out with bounding sphere
		float boundDist = length(pos - convex.Center) - convex.BoundingRadius - ParticleRadius;
		if (boundDist > CollisionThreshold)
		{
			continue;
		}

		float sdf = sdConvex(pos, convex.Center, convex.BoundingRadius,
		                     convex.PlaneStartIndex, convex.PlaneCount, ConvexPlanes);
		float effectiveDist = sdf - ParticleRadius;

		if (effectiveDist < CollisionThreshold)
		{
			// Find the closest plane for normal calculation
			float3 normal = float3(0, 0, 1);
			float maxDist = -1e10f;
			for (int pi = 0; pi < convex.PlaneCount; ++pi)
			{
				FGPUConvexPlane plane = ConvexPlanes[convex.PlaneStartIndex + pi];
				float dist = dot(pos, plane.Normal) - plane.Distance;
				if (dist > maxDist)
				{
					maxDist = dist;
					normal = plane.Normal;
				}
			}

			float penetration = max(0.0f, -effectiveDist);
			float3 impactWorld = pos - normal * sdf;

			// Apply collision response for all colliders (both bone and static)
			ApplyCollisionResponseWithFriction(pos, originalPos, vel, normal, penetration, convex.Friction, convex.Restitution);
			originalPos = pos;

			// Mark as near ground if collision normal is mostly upward
			if (normal.z > 0.5f)
			{
				particle.Flags = SetFlag(particle.Flags, GPU_PARTICLE_FLAG_NEAR_GROUND);
			}
			bCollided = true;

			// Record feedback for particle -> player interaction (includes velocity for drag calculation)
			RecordCollisionFeedback(idx, SphereCount + CapsuleCount + BoxCount + cxi, COLLIDER_TYPE_CONVEX, particle.Density, normal, penetration, particle.Velocity, convex.OwnerID, particle.SourceID, convex.BoneIndex, impactWorld);
		}
	}

	// Clear near ground flag if no collision
	if (!bCollided)
	{
		particle.Flags = ClearFlag(particle.Flags, GPU_PARTICLE_FLAG_NEAR_GROUND);
	}

	// Write back
	particle.PredictedPosition = pos;
	particle.Velocity = vel;
	Particles[idx] = particle;
}
