// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Fluid Physics - Primitive Collision Pass
// Applies collision with explicit primitives (spheres, capsules, boxes, convexes)

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"
#include "FluidCollisionPrimitives.ush"

//=============================================================================
// Shader Parameters
//=============================================================================

// Particle buffers (SoA - Structure of Arrays)
RWBuffer<float> Positions;
RWBuffer<float> PredictedPositions;
RWBuffer<float> Velocities;
Buffer<float> Densities;            // Read-only for feedback
Buffer<int> SourceIDs;              // Read-only for feedback
RWBuffer<uint> Flags;

int ParticleCount;
float ParticleRadius;

// Collision primitives
StructuredBuffer<FGPUCollisionSphere> CollisionSpheres;
int SphereCount;

StructuredBuffer<FGPUCollisionCapsule> CollisionCapsules;
int CapsuleCount;

StructuredBuffer<FGPUCollisionBox> CollisionBoxes;
int BoxCount;

StructuredBuffer<FGPUCollisionConvex> CollisionConvexes;
int ConvexCount;

StructuredBuffer<FGPUConvexPlane> ConvexPlanes;

StructuredBuffer<FGPUBoneTransform> BoneTransforms;
int BoneCount;

// Collision threshold
float CollisionThreshold;

//=============================================================================
// Collision Feedback Buffer (for Particle -> Player Interaction)
//=============================================================================

// Feedback buffer for CPU readback (BoneIndex >= 0, character bones)
RWStructuredBuffer<FGPUCollisionFeedback> CollisionFeedback;

// Atomic counter for feedback entries
RWStructuredBuffer<uint> CollisionCounter;

// Maximum number of feedback entries (prevents buffer overflow)
int MaxCollisionFeedback;

// Enable/disable feedback recording (0 = disabled, 1 = enabled)
int bEnableCollisionFeedback;

//=============================================================================
// StaticMesh Collision Feedback Buffer (WorldCollision, BoneIndex < 0, bHasFluidInteraction = 0)
//=============================================================================

// StaticMesh feedback buffer for CPU readback (WorldCollision without FluidInteraction)
RWStructuredBuffer<FGPUCollisionFeedback> StaticMeshCollisionFeedback;

// Atomic counter for StaticMesh feedback entries
RWStructuredBuffer<uint> StaticMeshCollisionCounter;

// Maximum number of StaticMesh feedback entries
int MaxStaticMeshCollisionFeedback;

//=============================================================================
// FluidInteraction StaticMesh Feedback Buffer (BoneIndex < 0, bHasFluidInteraction = 1)
//=============================================================================

// FluidInteraction StaticMesh feedback buffer for CPU readback (buoyancy center calculation)
RWStructuredBuffer<FGPUCollisionFeedback> FluidInteractionSMCollisionFeedback;

// Atomic counter for FluidInteraction StaticMesh feedback entries
RWStructuredBuffer<uint> FluidInteractionSMCollisionCounter;

// Maximum number of FluidInteraction StaticMesh feedback entries
int MaxFluidInteractionSMCollisionFeedback;

//=============================================================================
// Collider Contact Count Buffer (for simple collision count)
//=============================================================================

// Number of colliding particles per collider (atomic increment)
RWStructuredBuffer<uint> ColliderContactCounts;

// Maximum collider count
int MaxColliderCount;

//=============================================================================
// Helper Function: Record Collision Feedback
//=============================================================================

/**
 * Records collision feedback for CPU readback (particle -> player interaction)
 * Uses atomic counter to safely write to shared buffer
 *
 * 3-Way Buffer Routing:
 * - boneIndex >= 0 -> CollisionFeedback (SkeletalMesh bones)
 * - boneIndex < 0, bHasFluidInteraction = 0 -> StaticMeshCollisionFeedback (WorldCollision)
 * - boneIndex < 0, bHasFluidInteraction = 1 -> FluidInteractionSMCollisionFeedback (FluidInteraction StaticMesh)
 *
 * @param particleIdx - Index of the colliding particle
 * @param colliderIdx - Index of the collider (unique across all types)
 * @param colliderType - Type of collider (0=Sphere, 1=Capsule, 2=Box, 3=Convex)
 * @param density - Particle density at collision time
 * @param normal - Collision surface normal
 * @param penetration - Penetration depth (cm)
 * @param velocity - Particle velocity (for drag force calculation)
 * @param colliderOwnerID - Unique ID of collider owner (for filtering by actor)
 * @param particleSourceID - Particle's SourceID (PresetIndex | ComponentIndex << 16)
 * @param boneIndex - Bone index for per-bone force calculation (-1 = no bone)
 * @param bHasFluidInteraction - 1 if from FluidInteraction component, 0 if from WorldCollision
 * @param impactWorld - Impact position in world space
 * @param particlePosition - Particle world position (for buoyancy center calculation)
 */
void RecordCollisionFeedback(int particleIdx, int colliderIdx, int colliderType,
                             float density, float3 normal, float penetration, float3 velocity,
                             int colliderOwnerID, int particleSourceID, int boneIndex,
                             int bHasFluidInteraction, float3 impactWorld, float3 particlePosition)
{
	// Increment collision count per collider (always executed)
	if (colliderIdx >= 0 && colliderIdx < MaxColliderCount)
	{
		uint dummy;
		InterlockedAdd(ColliderContactCounts[colliderIdx], 1, dummy);
	}

	// Record detailed feedback when enabled
	if (bEnableCollisionFeedback == 0)
	{
		return;
	}

	// Build feedback struct (common for all buffers)
	FGPUCollisionFeedback feedback;
	feedback.ParticleIndex = particleIdx;
	feedback.ColliderIndex = colliderIdx;
	feedback.ColliderType = colliderType;
	feedback.Density = density;
	feedback.ImpactNormal = normal;
	feedback.Penetration = penetration;
	feedback.ParticleVelocity = velocity;
	feedback.ColliderOwnerID = colliderOwnerID;
	feedback.ParticleSourceID = particleSourceID;
	feedback.ParticleActorID = 0;  // Reserved for future use
	feedback.BoneIndex = boneIndex;
	feedback.Padding1 = 0;
	if (boneIndex >= 0 && boneIndex < BoneCount)
	{
		feedback.ImpactOffset = WorldToBoneLocal(impactWorld, BoneTransforms[boneIndex]);
	}
	else
	{
		feedback.ImpactOffset = float3(0, 0, 0);
	}
	feedback.Padding2 = 0;
	feedback.ParticlePosition = particlePosition;
	feedback.Padding3 = 0;

	// 3-Way Branch: Route to appropriate buffer based on boneIndex and bHasFluidInteraction
	uint feedbackIdx;
	if (boneIndex >= 0)
	{
		// SkeletalMesh bone colliders -> CollisionFeedback buffer
		InterlockedAdd(CollisionCounter[0], 1, feedbackIdx);
		if ((int)feedbackIdx < MaxCollisionFeedback)
		{
			CollisionFeedback[feedbackIdx] = feedback;
		}
	}
	else if (bHasFluidInteraction != 0)
	{
		// FluidInteraction StaticMesh (boneIndex < 0, bHasFluidInteraction = 1)
		// -> FluidInteractionSMCollisionFeedback buffer (for buoyancy center calculation)
		InterlockedAdd(FluidInteractionSMCollisionCounter[0], 1, feedbackIdx);
		if ((int)feedbackIdx < MaxFluidInteractionSMCollisionFeedback)
		{
			FluidInteractionSMCollisionFeedback[feedbackIdx] = feedback;
		}
	}
	else
	{
		// WorldCollision StaticMesh (boneIndex < 0, bHasFluidInteraction = 0)
		// -> StaticMeshCollisionFeedback buffer
		InterlockedAdd(StaticMeshCollisionCounter[0], 1, feedbackIdx);
		if ((int)feedbackIdx < MaxStaticMeshCollisionFeedback)
		{
			StaticMeshCollisionFeedback[feedbackIdx] = feedback;
		}
	}
}

//=============================================================================
// Main Compute Shader
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void PrimitiveCollisionCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)ParticleCount)
	{
		return;
	}

	uint idx3 = idx * 3;
	uint flags = Flags[idx];

	// Skip CPU-attached particles only (they follow bone position directly)
	// Boundary-attached particles still need collision detection
	if (HasFlag(flags, GPU_PARTICLE_FLAG_IS_ATTACHED))
	{
		return;
	}

	// Read SoA buffers
	float3 pos = float3(PredictedPositions[idx3], PredictedPositions[idx3 + 1], PredictedPositions[idx3 + 2]);
	float3 originalPos = float3(Positions[idx3], Positions[idx3 + 1], Positions[idx3 + 2]);
	float3 vel = float3(Velocities[idx3], Velocities[idx3 + 1], Velocities[idx3 + 2]);
	float density = Densities[idx];
	int sourceID = SourceIDs[idx];
	bool bCollided = false;

	// Check collision with all spheres
	for (int si = 0; si < SphereCount; ++si)
	{
		FGPUCollisionSphere sphere = CollisionSpheres[si];
		float sdf = sdSphere(pos, sphere.Center, sphere.Radius);
		float effectiveDist = sdf - ParticleRadius;

		if (effectiveDist < CollisionThreshold)
		{
			float3 normal = CalcNumericalGradient_Sphere(pos, sphere.Center, sphere.Radius);
			float penetration = max(0.0f, -effectiveDist);
			float3 impactWorld = pos - normal * sdf;

			// Apply collision response for all colliders (both bone and static)
			ApplyCollisionResponseWithFriction(pos, originalPos, vel, normal, penetration, sphere.Friction, sphere.Restitution);
			originalPos = pos;  // Update for subsequent collisions
			bCollided = true;

			// Record feedback for particle -> player interaction (includes velocity for drag calculation)
			RecordCollisionFeedback(idx, si, COLLIDER_TYPE_SPHERE, density, normal, penetration, vel, sphere.OwnerID, sourceID, sphere.BoneIndex, sphere.bHasFluidInteraction, impactWorld, pos);
		}
	}

	// Check collision with all capsules
	for (int ci = 0; ci < CapsuleCount; ++ci)
	{
		FGPUCollisionCapsule capsule = CollisionCapsules[ci];
		float sdf = sdCapsule(pos, capsule.Start, capsule.End, capsule.Radius);
		float effectiveDist = sdf - ParticleRadius;

		if (effectiveDist < CollisionThreshold)
		{
			float3 normal = CalcNumericalGradient_Capsule(pos, capsule.Start, capsule.End, capsule.Radius);
			float penetration = max(0.0f, -effectiveDist);
			float3 impactWorld = pos - normal * sdf;

			// Apply collision response for all colliders (both bone and static)
			ApplyCollisionResponseWithFriction(pos, originalPos, vel, normal, penetration, capsule.Friction, capsule.Restitution);
			originalPos = pos;
			bCollided = true;

			// Record feedback for particle -> player interaction (includes velocity for drag calculation)
			RecordCollisionFeedback(idx, SphereCount + ci, COLLIDER_TYPE_CAPSULE, density, normal, penetration, vel, capsule.OwnerID, sourceID, capsule.BoneIndex, capsule.bHasFluidInteraction, impactWorld, pos);
		}
	}

	// Check collision with all boxes
	for (int bi = 0; bi < BoxCount; ++bi)
	{
		FGPUCollisionBox box = CollisionBoxes[bi];
		float sdf = sdBox(pos, box.Center, box.Extent, box.Rotation);
		float effectiveDist = sdf - ParticleRadius;

		if (effectiveDist < CollisionThreshold)
		{
			float3 normal = CalcNumericalGradient_Box(pos, box.Center, box.Extent, box.Rotation);
			float penetration = max(0.0f, -effectiveDist);
			float3 impactWorld = pos - normal * sdf;

			// Apply collision response for all colliders (both bone and static)
			ApplyCollisionResponseWithFriction(pos, originalPos, vel, normal, penetration, box.Friction, box.Restitution);
			originalPos = pos;

			// Mark as near ground if collision normal is mostly upward
			if (normal.z > 0.5f)
			{
				flags = SetFlag(flags, GPU_PARTICLE_FLAG_NEAR_GROUND);
			}
			bCollided = true;

			// Record feedback for particle -> player interaction (includes velocity for drag calculation)
			RecordCollisionFeedback(idx, SphereCount + CapsuleCount + bi, COLLIDER_TYPE_BOX, density, normal, penetration, vel, box.OwnerID, sourceID, box.BoneIndex, box.bHasFluidInteraction, impactWorld, pos);
		}
	}

	// Check collision with all convex hulls
	for (int cxi = 0; cxi < ConvexCount; ++cxi)
	{
		FGPUCollisionConvex convex = CollisionConvexes[cxi];

		// Early out with bounding sphere
		float boundDist = length(pos - convex.Center) - convex.BoundingRadius - ParticleRadius;
		if (boundDist > CollisionThreshold)
		{
			continue;
		}

		float sdf = sdConvex(pos, convex.Center, convex.BoundingRadius,
		                     convex.PlaneStartIndex, convex.PlaneCount, ConvexPlanes);
		float effectiveDist = sdf - ParticleRadius;

		if (effectiveDist < CollisionThreshold)
		{
			// Find the closest plane for normal calculation
			float3 normal = float3(0, 0, 1);
			float maxDist = -1e10f;
			for (int pi = 0; pi < convex.PlaneCount; ++pi)
			{
				FGPUConvexPlane plane = ConvexPlanes[convex.PlaneStartIndex + pi];
				float dist = dot(pos, plane.Normal) - plane.Distance;
				if (dist > maxDist)
				{
					maxDist = dist;
					normal = plane.Normal;
				}
			}

			float penetration = max(0.0f, -effectiveDist);
			float3 impactWorld = pos - normal * sdf;

			// Apply collision response for all colliders (both bone and static)
			ApplyCollisionResponseWithFriction(pos, originalPos, vel, normal, penetration, convex.Friction, convex.Restitution);
			originalPos = pos;

			// Mark as near ground if collision normal is mostly upward
			if (normal.z > 0.5f)
			{
				flags = SetFlag(flags, GPU_PARTICLE_FLAG_NEAR_GROUND);
			}
			bCollided = true;

			// Record feedback for particle -> player interaction (includes velocity for drag calculation)
			RecordCollisionFeedback(idx, SphereCount + CapsuleCount + BoxCount + cxi, COLLIDER_TYPE_CONVEX, density, normal, penetration, vel, convex.OwnerID, sourceID, convex.BoneIndex, convex.bHasFluidInteraction, impactWorld, pos);
		}
	}

	// Clear near ground flag if no collision
	if (!bCollided)
	{
		flags = ClearFlag(flags, GPU_PARTICLE_FLAG_NEAR_GROUND);
	}

	// Write back to SoA buffers
	PredictedPositions[idx3] = pos.x;
	PredictedPositions[idx3 + 1] = pos.y;
	PredictedPositions[idx3 + 2] = pos.z;

	Velocities[idx3] = vel.x;
	Velocities[idx3 + 1] = vel.y;
	Velocities[idx3 + 2] = vel.z;

	Flags[idx] = flags;
}
