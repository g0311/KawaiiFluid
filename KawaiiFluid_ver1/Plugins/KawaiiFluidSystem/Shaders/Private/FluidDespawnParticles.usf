// Copyright KawaiiFluid Team. All Rights Reserved.
// Stream Compaction Shaders for Particle Despawn (shared by ID-based despawn)

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"

// ===================================================================================
// Struct Definitions (Must match C++)
// ===================================================================================

struct FGPUFluidParticle
{
	float3 Position;           // 12 bytes
	float Mass;                // 4 bytes (total: 16)
	float3 PredictedPosition;  // 12 bytes
	float Density;             // 4 bytes (total: 32)
	float3 Velocity;           // 12 bytes
	float Lambda;              // 4 bytes (total: 48)
	int ParticleID;            // 4 bytes
	int SourceID;              // 4 bytes
	uint Flags;                // 4 bytes
	uint NeighborCount;        // 4 bytes (total: 64)
};

// ===================================================================================
// Parameter Definitions
// ===================================================================================

// Shared Parameters
StructuredBuffer<FGPUFluidParticle> Particles;
int ParticleCount;

// CompactParticlesCS Parameters
StructuredBuffer<uint> MarkedFlags;
StructuredBuffer<uint> PrefixSums;
RWStructuredBuffer<FGPUFluidParticle> CompactedParticles;

// WriteTotalCountCS Parameters
RWStructuredBuffer<uint> OutTotalCount;

// ===================================================================================
// Kernel: CompactParticlesCS
// Compacts alive particles to new buffer based on prefix sums
// ===================================================================================
[numthreads(256, 1, 1)]
void CompactParticlesCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	const uint Index = DispatchThreadId.x;

	if (Index >= (uint)ParticleCount)
		return;

	// Copy only alive particles
	if (MarkedFlags[Index] == 1)
	{
		// PrefixSum value is the new index
		uint NewIndex = PrefixSums[Index];

		// Copy entire particle data
		CompactedParticles[NewIndex] = Particles[Index];
	}
}

// ===================================================================================
// Kernel: WriteTotalCountCS
// Calculates total dead count for async readback
// ===================================================================================
[numthreads(1, 1, 1)]
void WriteTotalCountCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	// Calculate total alive count from the last particle's PrefixSum
	// Assumes Inclusive Scan: Last PrefixSum value = Total Count
	if (ParticleCount > 0)
	{
		uint LastIndex = ParticleCount - 1;
		uint TotalAlive = PrefixSums[LastIndex] + MarkedFlags[LastIndex];

		OutTotalCount[0] = ParticleCount - TotalAlive;
	}
	else
	{
		OutTotalCount[0] = 0;
	}
}
