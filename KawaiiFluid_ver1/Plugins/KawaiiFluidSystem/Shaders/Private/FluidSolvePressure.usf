// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Fluid Physics - Solve Pressure Pass
// Applies position corrections based on density constraints (XPBD)
//
// [DEPRECATED] This shader is deprecated and will be removed in a future version.
// Use FluidSolveDensityPressure.usf instead, which combines density and pressure
// calculation into a single neighbor traversal for better performance.

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"
#include "FluidSpatialHash.ush"

//=============================================================================
// Shader Parameters
//=============================================================================

RWStructuredBuffer<FGPUFluidParticle> Particles;
StructuredBuffer<uint> CellCounts;
StructuredBuffer<uint> ParticleIndices;

int ParticleCount;
float SmoothingRadius;
float RestDensity;
float SpikyCoeff;
float Poly6Coeff;
float CellSize;

// Tensile Instability Correction (PBF paper Eq.13-14)
// s_corr = -k * (W(r)/W(Δq))^n
// Prevents particle clustering at low-density regions (splash, surface)
int bEnableTensileInstability;
float TensileK;
int TensileN;
float InvW_DeltaQ;  // Precomputed 1/W(Δq, h)

//=============================================================================
// Main Compute Shader
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void SolvePressureCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)ParticleCount)
	{
		return;
	}

	FGPUFluidParticle particle = Particles[idx];

	// Skip attached particles (CPU or boundary) from pressure solving
	// CRITICAL: Attached particles must be excluded to prevent explosion!
	if (HasFlag(particle.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED))
	{
		return;
	}

	float3 pos = particle.PredictedPosition;
	float lambda_i = particle.Lambda;

	// IMPORTANT: Convert smoothing radius from cm to m for kernel calculations
	// Kernel coefficients (SpikyCoeff) are precomputed with h in meters
	float h = SmoothingRadius * CM_TO_M;  // Convert to meters
	float h2 = h * h;

	// Position correction accumulator (will be in meters, convert back at end)
	float3 deltaP = float3(0.0f, 0.0f, 0.0f);

	// Get cell coordinate for this particle (still use cm for spatial hash)
	int3 centerCell = WorldToCell(pos, CellSize);
	int cellRadius = (int)ceil(SmoothingRadius / CellSize);  // Use original cm value

	// Iterate over neighboring cells
	for (int dz = -cellRadius; dz <= cellRadius; ++dz)
	{
		for (int dy = -cellRadius; dy <= cellRadius; ++dy)
		{
			for (int dx = -cellRadius; dx <= cellRadius; ++dx)
			{
				int3 neighborCell = centerCell + int3(dx, dy, dz);
				uint hash = HashCell(neighborCell);
				uint count = min(CellCounts[hash], (uint)MAX_PARTICLES_PER_CELL);
				uint startIdx = hash * MAX_PARTICLES_PER_CELL;

				for (uint i = 0; i < count; ++i)
				{
					uint neighborIdx = ParticleIndices[startIdx + i];

					// Skip self and invalid indices
					if (neighborIdx == idx || neighborIdx >= (uint)ParticleCount)
					{
						continue;
					}

					FGPUFluidParticle neighbor = Particles[neighborIdx];

					float3 neighborPos = neighbor.PredictedPosition;
					float3 r_cm = pos - neighborPos;           // Distance in cm
					float r2_cm = dot(r_cm, r_cm);             // r² in cm²

					// Convert to meters for kernel calculations
					float r2 = r2_cm * CM_TO_M_SQ;             // r² in m²

					// Skip if outside smoothing radius or too close (both in m²)
					if (r2 >= h2 || r2 < SMALL_NUMBER)
					{
						continue;
					}

					float rLen = sqrt(r2);                     // Distance in meters
					float3 r = r_cm * CM_TO_M;                 // Convert r vector to meters
					float lambda_j = neighbor.Lambda;

					// Spiky gradient (using meter units)
					float3 gradW = SpikyGradient(r, rLen, h);
					// IMPORTANT: Multiply by CM_TO_M to match CPU calculation scale
					gradW *= SpikyCoeff * CM_TO_M;

					// Tensile Instability Correction (PBF Eq.13-14)
					// s_corr = -k * (W(r)/W(Δq))^n
					// Prevents particle clustering at surface/splash regions
					float scorr = 0.0f;
					if (bEnableTensileInstability)
					{
						// Poly6 kernel ratio: W(r)/W(Δq) = (h²-r²)³ / (h²-Δq²)³
						// Coefficient cancels out in ratio, so we don't need Poly6Coeff
						float diff = h2 - r2;
						float W_r = diff * diff * diff;

						// W(Δq) where Δq = 0.2h (PBF paper default)
						float deltaQ2 = 0.04f * h2;  // (0.2h)² = 0.04h²
						float diffQ = h2 - deltaQ2;  // 0.96h²
						float W_deltaQ = diffQ * diffQ * diffQ;

						// Ratio NOT clamped - ratio > 1 when r < Δq provides repulsion for close particles
						float ratio = (W_deltaQ > 0.0f) ? (W_r / W_deltaQ) : 0.0f;

						// s_corr = -k * ratio^n
						// Manually compute ratio^n for common exponents to avoid loop/pow issues
						float ratioN = 1.0f;
						if (TensileN == 4)
						{
							float ratio2 = ratio * ratio;
							ratioN = ratio2 * ratio2;
						}
						else if (TensileN == 2)
						{
							ratioN = ratio * ratio;
						}
						else if (TensileN == 6)
						{
							float ratio2 = ratio * ratio;
							ratioN = ratio2 * ratio2 * ratio2;
						}
						scorr = -TensileK * ratioN;
					}

					// Position correction: Δp = (λ_i + λ_j + s_corr) * ∇W (result in meters)
					deltaP += (lambda_i + lambda_j + scorr) * gradW;
				}
			}
		}
	}

	// Apply correction (divided by rest density for proper scaling)
	// With CM_TO_M applied to gradW, deltaP is now in cm-compatible units
	// No additional unit conversion needed (matches CPU behavior)
	float3 deltaP_cm = deltaP / RestDensity;
	particle.PredictedPosition += deltaP_cm;

	Particles[idx] = particle;
}
