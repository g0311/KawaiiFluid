// Copyright KawaiiFluid Team. All Rights Reserved.
// SDF (Signed Distance Field) Common Functions for Ray Marching

#pragma once

#include "../KawaiiRenderParticle.ush"
#include "FluidSpatialHash.ush"

//=============================================================================
// SDF Primitives
//=============================================================================

// Sphere SDF: returns signed distance from point p to sphere surface
float sdSphere(float3 p, float3 center, float radius)
{
	return length(p - center) - radius;
}

//=============================================================================
// SDF Operations
//=============================================================================

// Smooth minimum (polynomial smooth min)
// k: smoothness factor (higher = smoother blend, typical: 4.0 ~ 16.0)
// Reference: https://iquilezles.org/articles/smin/
float smin(float a, float b, float k)
{
	float h = max(k - abs(a - b), 0.0) / k;
	return min(a, b) - h * h * k * 0.25;
}

//=============================================================================
// Metaball SDF Evaluation
//=============================================================================

// Evaluate metaball SDF from FKawaiiRenderParticle buffer
float EvaluateMetaballSDFFromRenderParticles(
	float3 p,
	StructuredBuffer<FKawaiiRenderParticle> RenderParticles,
	int ParticleCount,
	float ParticleRadius,
	float Smoothness)
{
	if (ParticleCount <= 0)
		return 1e10;

	float sdf = sdSphere(p, RenderParticles[0].Position, ParticleRadius);

	for (int i = 1; i < ParticleCount; ++i)
	{
		float d = sdSphere(p, RenderParticles[i].Position, ParticleRadius);
		sdf = smin(sdf, d, Smoothness);
	}

	return sdf;
}

// Calculate normal using 3-tap forward difference
float3 CalculateSDFNormal3TapFromRenderParticles(
	float3 p,
	float centerSDF,
	StructuredBuffer<FKawaiiRenderParticle> RenderParticles,
	int ParticleCount,
	float ParticleRadius,
	float Smoothness)
{
	const float eps = 0.001;

	float3 n;
	n.x = EvaluateMetaballSDFFromRenderParticles(p + float3(eps, 0, 0), RenderParticles, ParticleCount, ParticleRadius, Smoothness) - centerSDF;
	n.y = EvaluateMetaballSDFFromRenderParticles(p + float3(0, eps, 0), RenderParticles, ParticleCount, ParticleRadius, Smoothness) - centerSDF;
	n.z = EvaluateMetaballSDFFromRenderParticles(p + float3(0, 0, eps), RenderParticles, ParticleCount, ParticleRadius, Smoothness) - centerSDF;

	return normalize(n);
}

//=============================================================================
// Spatial Hash SDF Evaluation (Multi-pass version with dynamic layout)
//=============================================================================

// Evaluate metaball SDF with Spatial Hash acceleration (O(k) instead of O(N))
// Uses CellData: {startIndex, count} and sorted ParticleIndices
// Always 3x3x3 search (27 cells) - cell size must be >= SearchRadius
float EvaluateMetaballSDFWithSpatialHash(
	float3 p,
	StructuredBuffer<FKawaiiRenderParticle> RenderParticles,
	StructuredBuffer<uint2> CellData,
	StructuredBuffer<uint> SpatialHashParticleIndices,
	int ParticleCount,
	float ParticleRadius,
	float Smoothness,
	float CellSize)
{
	if (ParticleCount <= 0)
		return 1e10;

	int3 CenterCell = WorldToCell(p, CellSize);

	float sdf = 1e10;
	bool bFoundAny = false;

	[unroll]
	for (int dz = -1; dz <= 1; ++dz)
	{
		[unroll]
		for (int dy = -1; dy <= 1; ++dy)
		{
			[unroll]
			for (int dx = -1; dx <= 1; ++dx)
			{
				int3 NeighborCell = CenterCell + int3(dx, dy, dz);
				uint Hash = HashCell(NeighborCell);

				uint2 Cell = CellData[Hash];
				uint StartIndex = Cell.x;
				uint Count = Cell.y;

				for (uint i = 0; i < Count; ++i)
				{
					uint ParticleIdx = SpatialHashParticleIndices[StartIndex + i];
					if (ParticleIdx >= (uint)ParticleCount)
						continue;

					float3 ParticlePos = RenderParticles[ParticleIdx].Position;
					float d = length(p - ParticlePos) - ParticleRadius;

					if (!bFoundAny)
					{
						sdf = d;
						bFoundAny = true;
					}
					else
					{
						float h = max(Smoothness - abs(sdf - d), 0.0) / Smoothness;
						sdf = min(sdf, d) - h * h * Smoothness * 0.25;
					}
				}
			}
		}
	}

	return bFoundAny ? sdf : 1e10;
}

// Analytic Gradient Normal calculation (1-Loop, no finite differences)
// Uses smin blend weights to compute weighted average of particle directions
float3 CalculateNormalAnalyticWithSpatialHash(
	float3 p,
	float centerSDF,
	StructuredBuffer<FKawaiiRenderParticle> RenderParticles,
	StructuredBuffer<uint2> CellData,
	StructuredBuffer<uint> SpatialHashParticleIndices,
	int ParticleCount,
	float ParticleRadius,
	float Smoothness,
	float CellSize)
{
	if (ParticleCount <= 0)
		return float3(0, 1, 0);

	float3 gradient = float3(0, 0, 0);
	float totalWeight = 0.0;

	int3 CenterCell = WorldToCell(p, CellSize);

	[unroll]
	for (int dz = -1; dz <= 1; ++dz)
	{
		[unroll]
		for (int dy = -1; dy <= 1; ++dy)
		{
			[unroll]
			for (int dx = -1; dx <= 1; ++dx)
			{
				int3 NeighborCell = CenterCell + int3(dx, dy, dz);
				uint Hash = HashCell(NeighborCell);

				uint2 Cell = CellData[Hash];
				uint StartIndex = Cell.x;
				uint Count = Cell.y;

				for (uint i = 0; i < Count; ++i)
				{
					uint ParticleIdx = SpatialHashParticleIndices[StartIndex + i];
					if (ParticleIdx >= (uint)ParticleCount)
						continue;

					float3 ParticlePos = RenderParticles[ParticleIdx].Position;
					float3 r = p - ParticlePos;
					float dist = length(r);

					if (dist < 0.0001)
						continue;

					float d = dist - ParticleRadius;

					// smin blend weight
					float h = max(Smoothness - abs(centerSDF - d), 0.0) / Smoothness;
					float weight = h * h;

					gradient += weight * (r / dist);
					totalWeight += weight;
				}
			}
		}
	}

	if (totalWeight < 0.0001)
		return float3(0, 1, 0);

	return normalize(gradient);
}
